Only in ./: a2f.o
diff ./allocate_epwq.f90 ../../epw-qian/src/allocate_epwq.f90
134c134
<   if (eimp_mode == 5 .or. eimp_mode == 6) &
---
>   IF (eimp_mode == 5 .or. eimp_mode == 6) &
136c136,137
<   !
---
> 
> 
Only in ./: allocate_epwq.o
diff ./bcast_epw_input.f90 ../../epw-qian/src/bcast_epw_input.f90
53,54c53,55
<                             vg_el, vg_ph, relax_time, fscheck, ifc_read, &
<                             ! JWZ
---
>                             vg_el, vg_ph, relax_time, fscheck, ifc_read, epthick, phdrag, phwmax, phkmax, &
>                             alloy_read, shengbte_read, alloy_pot, frac_type, &
>                             ! zjw
58,59c59
<                             epbrestore, eimp_sr, elop, screen_polar, dvimpq, &
<                             eimp_ls_mode, eph_interp
---
>                             epbrestore, eimp_sr, elop, screen_polar
83a84,85
>   CALL mp_bcast (phwmax, ionode_id, world_comm)
>   CALL mp_bcast (phkmax, ionode_id, world_comm)
85a88
>   CALL mp_bcast (frac_type, ionode_id, world_comm)
105,106c108,111
<   CALL mp_bcast (bte_o, ionode_id, world_comm)
<   CALL mp_bcast (elop, ionode_id, world_comm)
---
>   CALL mp_bcast (phdrag, ionode_id, world_comm)
>   CALL mp_bcast (shengbte_read, ionode_id, world_comm)
>   CALL mp_bcast (alloy_read, ionode_id, world_comm)
>   CALL mp_bcast (alloy_pot, ionode_id, world_comm)
180d184
<   CALL mp_bcast (dvimpq, ionode_id, world_comm)  !
185d188
<   CALL mp_bcast (eph_interp, ionode_id, world_comm)  !
217d219
<   CALL mp_bcast (eimp_ls_mode, ionode_id, world_comm)  !
246a249
>   CALL mp_bcast (epthick, ionode_id, world_comm)    !
275,276d277
<   
<   !
Only in ./: bcast_epw_input.o
Only in ./: broyden.o
diff ./bte_check.f90 ../../epw-qian/src/bte_check.f90
96,98d95
<      !DO ibnd = 1, nbndsub
<      !   IF (et(ibnd,ik) .GT. ef_m) et(ibnd,ik) = et(ibnd,ik) + delta_egap
<      !ENDDO
101c98
<      ENDDO  
---
>      ENDDO 
Only in ./: bte_check.o
diff ./bte_driver.f90 ../../epw-qian/src/bte_driver.f90
2,134d1
< SUBROUTINE driver_tdbte_el ()
< !----------------------------------------------------------------------------
<   USE kinds,      ONLY : DP
<   USE cell_base,  ONLY : at, bg
<   USE phcom,      ONLY : nmodes
<   USE epwcom,     ONLY : nbndsub, bte, nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, run
<   USE elph2,      ONLY : ibndmin, ibndmax, nbnd_red, &
<                          vel_ful, f_t_ful, f_0_ful
<   USE bte_var
<   USE para_thl
< #ifdef __PARA
<   USE io_global,  ONLY : ionode_id, stdout
<   USE mp,         ONLY : mp_barrier
<   USE mp_global,  ONLY : my_pool_id, inter_pool_comm
< #ENDIF
<   !
<   IMPLICIT NONE
<   !
<   REAL(KIND=DP)              :: transpt(3,3,7)
<   REAL(KIND=DP), ALLOCATABLE :: f_t_pol(:,:)
<   INTEGER                    :: ik, ik0, ibnd, imode
<   INTEGER                    :: nk_pol, ik_pol, ik_star, ik_stop
<   LOGICAL                    :: converge = .FALSE., file_exist
<   INTEGER                    :: iter = 0, iter_rec = 0
<   ! date and time
<   CHARACTER(LEN=8)           :: date_
<   CHARACTER(LEN=10)          :: time_
<   CHARACTER(LEN=5)           :: zone_
<   INTEGER                    :: values_(8)
<   REAL(KIND=DP)              :: t0, t1, ta, tb, tab
<   !
<   !
<   mkq1 = nkf1/nqf1
<   mkq2 = nkf2/nqf2
<   mkq3 = nkf3/nqf3
<   !
<   ! load the needed file
<   CALL kq_load ()
<   CALL kq_red_load ()
<   CALL meta_load ()
<   !
<   ! generate new k list
<   CALL cpu_index ()
<   !
<   ! rotate and copy group velocity from irreducible to full BZ
<   CALL rotate_vel ()
<   !
<   ! initialization of paralellization
<   CALL para_bounds (ik_star, ik_stop, nk_ful_red)
<   nk_pol = ik_stop-ik_star+1
<   !
<   ALLOCATE (f_t_pol(nbnd_red,nk_pol))
<   ALLOCATE (f_t_ful(nbnd_red,nk_ful_red))
<   ALLOCATE (f_0_ful(nbnd_red,nk_ful_red))
<   f_t_ful = 0.0d0
<   f_0_ful = 0.0d0
<   f_t_pol = 0.0d0
<   !
<   ! compute the initial (excited) electron distribution function
<   CALL tdbte_f_0 ()
<   !
<   ! load f_0_ful if BTE/META/f_t_ful exists
<   IF (bte .EQ. 30) THEN
<      INQUIRE(FILE='BTE/META/f_t_ful',EXIST=file_exist)
<      IF (file_exist) CALL ft_load (iter_rec)
<      iter = iter_rec
<   ENDIF
<   !
<   ! td-bte
<   WRITE (stdout,'(/5x,a/)') 'Start calculation...'
<   !
<   DO WHILE (.NOT. converge)
<      !
<      CALL CPU_TIME (t0)
<      !
<      DO ik0 = ik_star, ik_stop
<         !
<         ! ik0 is the id of original kpoint in full BZ ranging from ik_star to ik_stop (totally, from 1 to nk_ful)
<         ! ik_pol = 1 ~ nk_pol, used in storing F_k_pol
<         ik_pol = ik0-ik_star+1
<         !
<         CALL CPU_TIME (ta)
<         CALL iter_tdbte_el (ik0, ik_pol, nk_pol, f_t_pol)
<         CALL CPU_TIME (tb)
<         tab = tab + (tb-ta)
<         !
<         IF (MOD(ik0-ik_star+1,1000) .EQ. 0 .OR. MOD(ik0-ik_star+1,nk_pol) .EQ. 0) THEN
<            CALL DATE_AND_TIME (date_,time_,zone_,values_)
<            WRITE (stdout,'(13x,a,i3,a,i6,a,i6,a,f8.1,a,i2,a,i2,a,i2)') 'Timestep ', iter, '  |  k = (', ik0-ik_star+1, '/', nk_pol, &
<            ') completed  |  Time : ', tab, ' s', values_(5), ':', values_(6), ':', values_(7)
<            tab = 0.0d0
<         ENDIF
<         !
<      ENDDO
<      !
<      CALL mp_barrier (inter_pool_comm)
<      !
<      CALL gether_thl (f_t_ful, f_t_pol, ik_star, ik_stop, seq2nscat)
<      !
<      ! check simulation step
<      IF (iter .EQ. run) converge = .TRUE.
<      !
<      CALL CPU_TIME (t1)
<      !
<      ! output
<      CALL export_ft (iter, converge, 1, 1)
<      CALL export_result (transpt, iter, converge, 1, 1, t1-t0)
<      !
<      ! save the f_t of current iteration as a metafile
<      IF (.NOT. converge) THEN
<         !
<         CALL ft_save (iter)
<         f_0_ful = f_t_ful
<         f_t_ful = 0.0d0
<         !
<      ELSE
<         IF (my_pool_id .EQ. ionode_id) CALL SYSTEM ('rm BTE/META/f_t_ful') 
<      ENDIF
<      !
<      iter = iter + 1
<      !
<   ENDDO ! converge 
<   !
<   !
<   DEALLOCATE (f_0_ful)
<   DEALLOCATE (f_t_ful)
<   DEALLOCATE (f_t_pol)
<   !
< END SUBROUTINE driver_tdbte_el
< 
< 
< 
< !----------------------------------------------------------------------------
140c7,8
<   USE epwcom,     ONLY : nbndsub, bte, nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, neptemp, nepdope, mixing
---
>   USE epwcom,     ONLY : nbndsub, bte, nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, neptemp, nepdope, mixing, phdrag, &
>                          eimp_mode, bte_o, smearing, alloy_pot, eptemp, epdope
143c11,14
<                          F_k_ful, F_k_ful_tmp, tau0_k_ful, mfp_k_ful
---
>                          F_k_ful, F_k_ful_tmp, tau0_k_ful, mfp_k_ful, mfp_q_ful, wf_all, vph_ful, &
>                          sigmai_mode_all_ela_intra, etf_all, vel_all, ef_epw, sigmai_mode_all_ela_inter, &
>                          sigmai_mode_all_alloy_inter, sigmai_mode_all_alloy_intra, &
>                          sigmai_mode_all_inter, sigmai_mode_all_intra
146a18
>   USE constants_epw, ONLY : ryd2thz, au2ps, au2m, au2s, au2nm, ryd2ev
149c21,22
<   USE mp,         ONLY : mp_barrier
---
>   USE mp,         ONLY : mp_barrier, mp_sum
>   USE mp_world,   ONLY : world_comm, mpime
150a24,25
>   use cell_base,  only : omega
>   use io_files,   only : prefix
158,161c33,42
<   REAL(KIND=DP), ALLOCATABLE :: F_k_pol(:,:,:)
<   REAL(KIND=DP)              :: transpt(3,3,7), mob_0(3), mob_1(3)
<   INTEGER                    :: ik, ik0, ibnd, imode, ir, itemp, idope
<   INTEGER                    :: nk_pol, ik_pol, ik_star, ik_stop
---
>   REAL(KIND=DP), ALLOCATABLE :: F_k_pol(:,:,:), N_q_pol(:,:,:)
>   REAL(KIND=DP)              :: transpt(3,3,24), mob_0(3), mob_1(3), spd_0(3), spd_1(3), &
>                                 eptemp0, vel_k(3), vel0, tau0, tau_abs(nmodes), &
>                                 tau_emi(nmodes), tau_eimp, tau_eimp_intra, tau_eimp_inter, tau_alloy, &
>                                 scat0, scat_abs, scat_emi, scat_inter, scat_intra, &
>                                 scat_eimp, scat_eimp_intra, scat_eimp_inter, scat_alloy, scat_alloy_inter, &
>                                 scat_alloy_intra
>   INTEGER                    :: ik, ik0, ibnd, imode, ir, itemp, idope, iq, iq0, &
>                                 ik_ful_red, ik_irr, ik_ful, ibnd0, nxk
>   INTEGER                    :: nk_pol, ik_pol, ik_star, ik_stop, nq_pol, iq_pol, iq_star, iq_stop
169c50,53
<   REAL(KIND=DP)              :: t0, t1, ta, tb, tab
---
>   REAL(KIND=DP)              :: t0, t1, ta, tb, tab, ta_phd, tb_phd, tab_phd
>   character(len=256) :: tempfilek_fbz, filint_k_fbz, chr_deg, chr_temp, chr_ef, &
>                         tempfilek_ibz, filint_k_ibz, file_scat_rate
> 
192a77,86
>   IF (phdrag) THEN
>      !
>      CALL rotate_vph ()
>      !
>      CALL para_bounds (iq_star, iq_stop, nq_ful_red)
>      nq_pol = iq_stop-iq_star+1
>      !
>   ENDIF
>   !
>   !
203a98,102
>   if (bte_o) then
>      tempfilek_ibz = trim(prefix) // '.k_ibz.'
>      tempfilek_fbz = trim(prefix) // '.k_fbz.'
>   endif
>   !
207a107,110
>      eptemp0 = eptemp(itemp) / 0.000086173423d0 * ryd2ev
>      write(chr_temp,'(f6.1)') eptemp0
>      chr_temp = trim(adjustl(chr_temp))
>      !
209a113,124
>         write(chr_ef,'(ES10.2)') epdope(idope)
>         chr_ef = trim(adjustl(chr_ef))
>         !
>         if (bte_o) then
>            filint_k_ibz = trim(adjustl(tempfilek_ibz)) // trim(adjustl(smearing)) &
>                          // '_T' // trim(adjustl(chr_temp)) &
>                          // '_' // trim(adjustl(chr_ef))
>            file_scat_rate = 'Scat_rate_' // trim(adjustl(smearing)) &
>                          // '_T' // trim(adjustl(chr_temp)) &
>                          // '_' // trim(adjustl(chr_ef))
>         endif
>         ! 
232a148,164
>         !
>         IF (phdrag) THEN
>            !
>            ALLOCATE (mfp_q_ful(nmodes,nq_ful_red))  
>            ALLOCATE (int_N_q_ful(3,neptemp,nmodes,nq_ful_red))
>            ALLOCATE (N_q_ful(3,neptemp,nmodes,nq_ful_red))
>            ALLOCATE (dN_q_ful(3,neptemp,nmodes,nq_ful_red))
>            ALLOCATE (tau0_q_ful(neptemp,nmodes,nq_ful_red))
>            N_q_ful = 0.0d0
>            int_N_q_ful = 0.0d0
>            dN_q_ful = 0.0d0
>            tau0_q_ful = 0.0d0
>            !
>            CALL bte_tau0_ph (itemp, idope)
>         ENDIF
>         !
>         !
239a172,214
>            !
>            ! phonon drag
>            IF (phdrag) THEN
>               !
>               N_q_ful = 0.0d0
>               dN_q_ful = 0.0d0
>            int_N_q_ful = 0.0d0
>               !
>               tab_phd = 0.0d0
>               DO iq0 = iq_star, iq_stop
>                  !
>                  CALL CPU_TIME (ta_phd)
>                  CALL iter_bte_ph (iq0, itemp, idope, iter)
>                  CALL CPU_TIME (tb_phd)
>                  tab_phd = tab_phd + (tb_phd-ta_phd)
>                  !
>                  IF (MOD(iq0-iq_star+1,1000) .EQ. 0 .OR. MOD(iq0-iq_star+1,nq_pol) .EQ. 0) THEN
>                     WRITE (stdout,'(16x,a,i6,a,i6,a,f7.1,a,i2,a,i2,a,i2)') 'phdrag  |  q = (', iq0-iq_star+1, '/', nq_pol, &
>                     ') completed | Time : ', tab_phd, ' s | ', values_(5), ':', values_(6), ':', values_(7)
>                     tab_phd = 0.0d0
>                  ENDIF
>                  !
>               ENDDO
>               !
> #ifdef __PARA
>   CALL mp_barrier (world_comm)
>   CALL mp_sum (N_q_ful,inter_pool_comm)
>   CALL mp_sum (dN_q_ful,inter_pool_comm)
>   CALL mp_sum (int_N_q_ful,inter_pool_comm)
> #ENDIF
>  !  open(12159,file='N.dat',status='replace')
>  !  do iq=1,nq_ful_red
>  !  do imode=1,nmodes
>  !    write(12159,'(4es15.5)') wf_all(imode,rful2rirr_q(iq))*ryd2thz, tau0_q_ful(imode,iq)*au2ps, &
>  !                             SQRT(DOT_PRODUCT(vph_ful(:,imode,iq),vph_ful(:,imode,iq)))*(au2m/au2s), &
>  !                             SQRT(DOT_PRODUCT(dN_q_ful(:,imode,iq),dN_q_ful(:,imode,iq)))*au2nm
>  ! enddo
>  ! enddo
>  !STOP
>               !
>            ENDIF
>            !
>            !
261c236,238
<            CALL mp_barrier (inter_pool_comm)
---
> #ifdef __PARA
>   CALL mp_barrier (world_comm)
> #ENDIF
263a241
>            !
269a248,367
> #ifdef __PARA
>   CALL mp_barrier (world_comm)
> #ENDIF
>            !
>        ! output to file
>         IF (iter .GE. 0) THEN
>         if (bte_o .and. (mpime == ionode_id)) then
>            OPEN (unit = 30000, file = filint_k_ibz)
>            OPEN (unit = 4444, file = file_scat_rate)
> !           OPEN (unit = 30001, file = filint_k_fbz)
> 
>            write (30000,*) trim(adjustl(prefix))
>            write (30000,*) omega
>            write (30000,*) ef_epw(itemp,idope) * ryd2ev
>            write (30000,*) nk_irr_red, nbnd_red, eimp_mode, nk_ful
>            do ik_irr = 1, nk_irr_red
>               !
>               nxk = 0
>               do ik_ful = 1, nk_ful_red
>                  if (rful2rirr(ik_ful) == ik_irr) then
>                     ik_ful_red = ik_ful
>                     nxk = nxk + 1
>                  endif
>               enddo
>               DO ibnd = 1, nbnd_red
>                  ibnd0 = ibnd + ibndmin - 1
> 
>                  vel_k = vel_ful(:,ibnd,ik_ful_red)
> !                 vel0 = sqrt(vel_all(1,ibnd0,ik_irr)**2 + vel_all(2,ibnd0,ik_irr)**2 + &
> !                             vel_all(3,ibnd0,ik_irr)**2)
>                  vel0 = sqrt(vel_k(1)**2 + vel_k(2)**2 + vel_k(3)**2)
> 
>                  scat0 = 2*(sum(sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik_irr)) + &
>                         sum(sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik_irr)))
>                  scat_inter = 2*sum(sigmai_mode_all_inter(itemp,idope,1:nmodes,ibnd,ik_irr))
>                  scat_intra = 2*sum(sigmai_mode_all_intra(itemp,idope,1:nmodes,ibnd,ik_irr))
>                  scat_abs = 2*sum(sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik_irr))
>                  scat_emi = 2*sum(sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik_irr))
> 
>                  tau0 = sum(sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik_irr)) + &
>                         sum(sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik_irr))
>                  tau_abs = sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik_irr)
>                  tau_emi = sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik_irr)
> 
>                  if (eimp_mode > 0) then
>                     scat_eimp_intra = 2*sigmai_mode_all_ela_intra(itemp,idope,ibnd,ik_irr)
>                     scat_eimp_inter = 2*sigmai_mode_all_ela_inter(itemp,idope,ibnd,ik_irr)
>                     scat_eimp = scat_eimp_intra + scat_eimp_inter
>                     IF (alloy_pot) THEN
>                     scat_alloy = 2*(sigmai_mode_all_alloy_inter(itemp,idope,ibnd,ik_irr) + sigmai_mode_all_alloy_intra(itemp,idope,ibnd,ik_irr))
>                     scat_alloy_inter = 2*sigmai_mode_all_alloy_inter(itemp,idope,ibnd,ik_irr)
>                     scat_alloy_intra = 2*sigmai_mode_all_alloy_intra(itemp,idope,ibnd,ik_irr)
>                     ENDIF
> 
>                     tau_eimp_intra = sigmai_mode_all_ela_intra(itemp,idope,ibnd,ik_irr)
>                     tau_eimp_inter = sigmai_mode_all_ela_inter(itemp,idope,ibnd,ik_irr)
>                     tau_eimp = tau_eimp_intra + tau_eimp_inter
>                     IF (alloy_pot) tau_alloy = sigmai_mode_all_alloy_inter(itemp,idope,ibnd,ik_irr) + sigmai_mode_all_alloy_intra(itemp,idope,ibnd,ik_irr) 
>                  endif
> 
>                  do imode = 1, nmodes
>                     if (tau_abs(imode)/=0.0d0) tau_abs(imode) = 0.5d0 / tau_abs(imode)
>                     if (tau_emi(imode)/=0.0d0) tau_emi(imode) = 0.5d0 / tau_emi(imode)
>                  enddo
> 
>                  if (eimp_mode == 0) then
>                     if (tau0/=0.0d0) tau0 = 0.5d0 / tau0
>                  else
>                     tau0 = tau0 + tau_eimp
>                     if (tau0/=0.0d0) tau0 = 0.5d0 / tau0
> 
>                     if (tau_eimp/=0.0d0) tau_eimp = 0.5d0 / tau_eimp
>                     if (tau_eimp_intra/=0.0d0) tau_eimp_intra = 0.5d0 / tau_eimp_intra
>                     if (tau_eimp_inter/=0.0d0) tau_eimp_inter = 0.5d0 / tau_eimp_inter
>                     IF ((alloy_pot) .and. (tau_alloy/=0.0d0)) tau_alloy = 0.5d0/tau_alloy
>                  endif
> 
>                  if (eimp_mode == 0) then
>                     write(4444, 200) xkf_irr(1:3,rirr2irr(ik_irr)), etf_all(ibnd0,ik_irr) * ryd2ev, &
>                  2.0670687d4*scat0, 2.0670687d4*scat_intra, 2.0670687d4*scat_inter, &
>                  2.0670687d4*scat_abs, 2.0670687d4*scat_emi
> 
>                     write(30000, 100) ik_irr, ibnd0, xkf_irr(1:3,rirr2irr(ik_irr)), nxk, &
>                                etf_all(ibnd0,ik_irr) * ryd2ev, &
>                                vel_k(1:3), tau0, tau_abs(1:nmodes), tau_emi(1:nmodes)
> 
>                  elseif (eimp_mode > 0) then
> 
>                     IF (alloy_pot) THEN
>                  write(4444, 200) xkf_irr(1:3,rirr2irr(ik_irr)), etf_all(ibnd0,ik_irr) * ryd2ev, &
>                  2.0670687d4*scat0, 2.0670687d4*scat_intra, 2.0670687d4*scat_inter, &
>                  2.0670687d4*scat_abs, 2.0670687d4*scat_emi, &
>                  2.0670687d4*scat_eimp, 2.0670687d4*scat_eimp_intra, 2.0670687d4*scat_eimp_inter, &
>                  2.0670687d4*scat_alloy, 2.0670687d4*scat_alloy_intra, 2.0670687d4*scat_alloy_inter
> 
>                      write(30000, 100) ik_irr, ibnd0, xkf_irr(1:3,rirr2irr(ik_irr)), nxk, &
>                                etf_all(ibnd0,ik_irr) * ryd2ev, &
>                                vel_k(1:3), tau0, tau_abs(1:nmodes), tau_emi(1:nmodes), &
>                                tau_eimp, tau_eimp_intra, tau_eimp_inter, tau_alloy
>                     ELSE
>                      write(30000, 100) ik_irr, ibnd0, xkf_irr(1:3,rirr2irr(ik_irr)), nxk, &
>                                etf_all(ibnd0,ik_irr) * ryd2ev, &
>                                vel_k(1:3), tau0, tau_abs(1:nmodes), tau_emi(1:nmodes), &
>                                tau_eimp, tau_eimp_intra, tau_eimp_inter   
> 
>                        write(4444, 200) xkf_irr(1:3,rirr2irr(ik_irr)), etf_all(ibnd0,ik_irr) * ryd2ev, &
>                  2.0670687d4*scat0, 2.0670687d4*scat_intra, 2.0670687d4*scat_inter, &
>                  2.0670687d4*scat_abs, 2.0670687d4*scat_emi, &
>                  2.0670687d4*scat_eimp, 2.0670687d4*scat_eimp_intra, 2.0670687d4*scat_eimp_inter
>                    
>                     ENDIF
>                  endif
>               ENDDO
>            ENDDO
>            close(30000)
>            close(4444)
>         endif
>         ENDIF
>         !
>            !
274a373
>               !
277a377,385
>               !
>               IF (phdrag) THEN
>                  !
>                  DO ir = 1, 3
>                     spd_0(ir) = transpt(ir,ir,9)
>                  ENDDO
>                  !
>               ENDIF
>               !
278a387
>               !
283a393,407
>               !
>               IF (phdrag) THEN
>                  !
>                  DO ir = 1, 3
>                     spd_1(ir) = transpt(ir,ir,9)
>                  ENDDO
>                  IF (MAXVAL(ABS((spd_1(:)-spd_0(:))/spd_0(:))) .LT. conv_thr .AND. converge .EQ. .TRUE.) THEN
>                     converge = .TRUE.
>                  ELSE
>                     converge = .FALSE.
>                  ENDIF
>                  spd_0 = spd_1
>                  !
>               ENDIF
>               !
287a412,415
>            IF (iter .GE. 1) THEN 
>              converge = .TRUE.  ! Forced (might be false) convergence, check the output yourself carefully
>            ENDIF
>            !
302a431,434
>            IF (iter .GT. 1) THEN 
>                 EXIT ! 1 time iteration at maximum
>            ENDIF
>            !
305c437,439
<         CALL mp_barrier (inter_pool_comm)
---
> #ifdef __PARA
>   CALL mp_barrier (world_comm)
> #ENDIF
311a446,452
>         IF (phdrag) THEN
>            DEALLOCATE (mfp_q_ful)
>            DEALLOCATE (N_q_ful)
>            DEALLOCATE (int_N_q_ful)
>            DEALLOCATE (dN_q_ful)
>            DEALLOCATE (tau0_q_ful)
>         ENDIF
321c462,465
<   IF (my_pool_id .EQ. ionode_id) CALL SYSTEM ('rm BTE/META/F_k_ful') 
---
>   IF (my_pool_id .EQ. ionode_id) CALL SYSTEM ('rm BTE/META/F_k_ful')
> ! 
> 100 format(5x,i6,2x,i5,3(1x,f16.10),2x,i4,35(2x,g14.7))
> 200 format(3(1x,f16.10),2x,35(2x,g14.7))
333,334c477,478
<   USE epwcom,     ONLY : nbndsub, bte, nkf1, nkf2, nkf3, neptemp, nepdope, eptemp, epdope, relax_time, &
<                          eimp_mode, bte_o, smearing
---
>   USE epwcom,     ONLY : nbndsub, bte, nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, neptemp, nepdope, &
>                          eptemp, epdope, relax_time, phdrag, eimp_mode, bte_o, smearing, alloy_pot
337,339c481,484
<                          F_k_ful, tau0_k_ful, mfp_k_ful, &
<                          sigmai_mode_all_ela_intra, etf_all, vel_all, &
<                          ef_epw, sigmai_mode_all_ela_inter
---
>                          sigmai_mode_all_inter, sigmai_mode_all_intra, & 
>                          F_k_ful, tau0_k_ful, mfp_k_ful, mfp_q_ful, vph_ful, ef_epw, &
>                          sigmai_mode_all_ela_inter, sigmai_mode_all_ela_intra, &
>                          sigmai_mode_all_alloy_inter, sigmai_mode_all_alloy_intra, etf_all, vel_all
342c487
<   USE constants_epw, ONLY : kB, au2fs
---
>   USE constants_epw, ONLY : kB, au2fs, ryd2ev
345c490,491
<   USE mp,         ONLY : mp_barrier
---
>   USE mp,         ONLY : mp_barrier, mp_sum
>   USE mp_world,   ONLY : world_comm, mpime
347d492
< #ENDIF
350c495
<   USE mp_world,   ONLY : mpime
---
> #ENDIF
355,356c500
<   real(kind=DP), parameter :: ryd2ev = 13.6058d0
<   REAL(KIND=DP) :: transpt(3,3,7), &
---
>   REAL(KIND=DP)     :: transpt(3,3,24), &  !zjw
359,364c503,512
<                    tau_eimp_inter
<   INTEGER       :: ik_ful_red, ibnd, imode, itemp, idope, &
<                    ik_irr, ik_ful, ibnd0, nxk
<   REAL(KIND=DP) :: t0, t1
<   INTEGER       :: iter = 0
<   LOGICAL       :: converge = .TRUE.
---
>                    tau_eimp_inter, tau_alloy, &
>                    scat0, scat_abs, scat_emi, scat_inter, scat_intra, &
>                    scat_eimp, scat_eimp_intra, scat_eimp_inter, scat_alloy, scat_alloy_inter, &
>                    scat_alloy_intra
>   INTEGER           :: ik_ful_red, ibnd, imode, itemp, idope, &
>                        ik_irr, ik_ful, ibnd0, nxk
>   INTEGER           :: iq0, iq_star, iq_stop, nq_pol
>   INTEGER           :: iter = 0
>   LOGICAL           :: converge = .TRUE.
>   ! zjw
366c514
<                         tempfilek_ibz, filint_k_ibz
---
>                         tempfilek_ibz, filint_k_ibz, file_scat_rate
367a516,521
>   ! date and time
>   CHARACTER(LEN=8)  :: date_
>   CHARACTER(LEN=10) :: time_
>   CHARACTER(LEN=5)  :: zone_
>   INTEGER           :: values_(8)
>   REAL(KIND=DP)     :: t0, t1, ta, tb, tab, ta_phd, tb_phd, tab_phd
380d533
<   write(stdout,*) 'here 1'
384,385c537,550
<   write(stdout,*) 'here 2'
< 
---
>   IF (phdrag) THEN
>      !
>      mkq1 = nkf1/nqf1 ! must be 1 if phdrag=T
>      mkq2 = nkf2/nqf2
>      mkq3 = nkf3/nqf3
>      !
>      CALL rotate_vph ()
>      !
>      CALL para_bounds (iq_star, iq_stop, nq_ful_red)
>      nq_pol = iq_stop-iq_star+1
>      !
>   ENDIF
>   !
>   !
395a561
>   ! zjw
397a564
>      ! zjw
402a570
>         ! zjw
410,411c578,580
< !           filint_k_fbz = trim(adjustl(tempfilek_fbz)) // 'tetra_T' // trim(adjustl(chr_temp)) &
< !                         // '_' // trim(adjustl(chr_ef))
---
>            file_scat_rate = 'Scat_' // trim(adjustl(smearing)) &
>                          // '_T' // trim(adjustl(chr_temp)) &
>                          // '_' // trim(adjustl(chr_ef))
413a583
>         !
422,423d591
<         CALL CPU_TIME (t0)
<         !
430a599,617
>         !
>         IF (phdrag) THEN
>            !
>            ALLOCATE (int_N_q_ful(3,neptemp,nmodes,nq_ful_red))
>            ALLOCATE (N_q_ful(3,neptemp,nmodes,nq_ful_red))
>            ALLOCATE (dN_q_ful(3,neptemp,nmodes,nq_ful_red))
>            ALLOCATE (tau0_q_ful(neptemp,nmodes,nq_ful_red))
>            ALLOCATE (mfp_q_ful(nmodes,nq_ful_red))
>            N_q_ful = 0.0d0
>        int_N_q_ful = 0.0d0
>            dN_q_ful = 0.0d0
>            tau0_q_ful = 0.0d0
>            !
>            CALL bte_tau0_ph (itemp, idope)
>         ENDIF
>         !
>         !
>         CALL CPU_TIME (t0)
>         !
440c627
<         ! output to file
---
>         ! zjw, output to file
442a630
>            OPEN (unit = 4444, file = file_scat_rate)
460,464c648,653
< 
<                  vel_k = vel_ful(:,ibnd,ik_ful_red)
< !                 vel0 = sqrt(vel_all(1,ibnd0,ik_irr)**2 + vel_all(2,ibnd0,ik_irr)**2 + &
< !                             vel_all(3,ibnd0,ik_irr)**2)
<                  vel0 = sqrt(vel_k(1)**2 + vel_k(2)**2 + vel_k(3)**2)
---
>                  scat0 = 2*(sum(sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik_irr)) + &
>                         sum(sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik_irr)))
>                  scat_inter = 2*sum(sigmai_mode_all_inter(itemp,idope,1:nmodes,ibnd,ik_irr))
>                  scat_intra = 2*sum(sigmai_mode_all_intra(itemp,idope,1:nmodes,ibnd,ik_irr))
>                  scat_abs = 2*sum(sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik_irr))
>                  scat_emi = 2*sum(sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik_irr))
469a659
> 
470a661,669
>                     scat_eimp_intra = 2*sigmai_mode_all_ela_intra(itemp,idope,ibnd,ik_irr)
>                     scat_eimp_inter = 2*sigmai_mode_all_ela_inter(itemp,idope,ibnd,ik_irr)
>                     scat_eimp = scat_eimp_intra + scat_eimp_inter
>                     IF (alloy_pot) THEN
>                     scat_alloy = 2*(sigmai_mode_all_alloy_inter(itemp,idope,ibnd,ik_irr) + sigmai_mode_all_alloy_intra(itemp,idope,ibnd,ik_irr))
>                     scat_alloy_inter = 2*sigmai_mode_all_alloy_inter(itemp,idope,ibnd,ik_irr)
>                     scat_alloy_intra = 2*sigmai_mode_all_alloy_intra(itemp,idope,ibnd,ik_irr)
>                     ENDIF
> 
473a673
>                     IF (alloy_pot) tau_alloy = sigmai_mode_all_alloy_inter(itemp,idope,ibnd,ik_irr) + sigmai_mode_all_alloy_intra(itemp,idope,ibnd,ik_irr) 
489a690
>                     IF ((alloy_pot) .and. (tau_alloy/=0.0d0)) tau_alloy = 0.5d0/tau_alloy
490a692
> 
491a694,697
>                     write(4444, 200) xkf_irr(1:3,rirr2irr(ik_irr)), etf_all(ibnd0,ik_irr) * ryd2ev, &
>                  2.0670687d4*scat0, 2.0670687d4*scat_intra, 2.0670687d4*scat_inter, &
>                  2.0670687d4*scat_abs, 2.0670687d4*scat_emi
> 
494a701
> 
496c703,716
<                     write(30000, 100) ik_irr, ibnd0, xkf_irr(1:3,rirr2irr(ik_irr)), nxk, &
---
> 
>                     IF (alloy_pot) THEN
>                  
>                  write(4444, 200) xkf_irr(1:3,rirr2irr(ik_irr)), etf_all(ibnd0,ik_irr) * ryd2ev, &
>                  2.0670687d4*scat0, 2.0670687d4*scat_intra, 2.0670687d4*scat_inter, &
>                  2.0670687d4*scat_abs, 2.0670687d4*scat_emi, &
>                  2.0670687d4*scat_eimp, 2.0670687d4*scat_eimp_intra, 2.0670687d4*scat_eimp_inter, 2.0670687d4*scat_alloy, 2.0670687d4*scat_alloy_intra, 2.0670687d4*scat_alloy_inter
> 
>                   write(30000, 100) ik_irr, ibnd0, xkf_irr(1:3,rirr2irr(ik_irr)), nxk, &
>                                etf_all(ibnd0,ik_irr) * ryd2ev, &
>                                vel_k(1:3), tau0, tau_abs(1:nmodes), tau_emi(1:nmodes), &
>                                tau_eimp, tau_eimp_intra, tau_eimp_inter, tau_alloy
>                     ELSE
>                      write(30000, 100) ik_irr, ibnd0, xkf_irr(1:3,rirr2irr(ik_irr)), nxk, &
499c719,726
<                                tau_eimp, tau_eimp_intra, tau_eimp_inter
---
>                                tau_eimp, tau_eimp_intra, tau_eimp_inter   
> 
>                      write(4444, 200) xkf_irr(1:3,rirr2irr(ik_irr)), etf_all(ibnd0,ik_irr) * ryd2ev, &
>                  2.0670687d4*scat0,2.0670687d4*scat_intra, 2.0670687d4*scat_inter, &
>                  2.0670687d4*scat_abs, 2.0670687d4*scat_emi, &                  
>                  2.0670687d4*scat_eimp, 2.0670687d4*scat_eimp_intra, 2.0670687d4*scat_eimp_inter
>                 
>                     ENDIF
503a731
>            close(4444)
505a734,766
>         ! phonon drag
>         IF (phdrag) THEN
>            !
>            N_q_ful = 0.0d0
>            dN_q_ful = 0.0d0
>         int_N_q_ful = 0.0d0
>            !
>            tab_phd = 0.0d0
>            DO iq0 = iq_star, iq_stop
>               !
>               CALL CPU_TIME (ta_phd)
>               CALL iter_bte_ph (iq0, itemp, idope, iter)
>               CALL CPU_TIME (tb_phd)
>               tab_phd = tab_phd + (tb_phd-ta_phd)
>               !
>               IF (MOD(iq0-iq_star+1,1000) .EQ. 0 .OR. MOD(iq0-iq_star+1,nq_pol) .EQ. 0) THEN
>                  CALL DATE_AND_TIME (date_,time_,zone_,values_)
>                  WRITE (stdout,'(16x,a,i6,a,i6,a,f7.1,a,i2,a,i2,a,i2)') 'phdrag  |  q = (', iq0-iq_star+1, '/', nq_pol, &
>                  ') completed | Time : ', tab_phd, ' s | ', values_(5), ':', values_(6), ':', values_(7)
>                  tab_phd = 0.0d0
>               ENDIF
>               !
>            ENDDO
>            !
> #ifdef __PARA
>   CALL mp_barrier (world_comm)
>   CALL mp_sum (int_N_q_ful,inter_pool_comm)
>   CALL mp_sum (N_q_ful,inter_pool_comm)
>   CALL mp_sum (dN_q_ful,inter_pool_comm)
> #ENDIF
>            !
>         ENDIF
>         !
523a785,791
>         IF (phdrag) THEN
>            DEALLOCATE (mfp_q_ful)
>            DEALLOCATE (N_q_ful)
>            DEALLOCATE (int_N_q_ful)
>            DEALLOCATE (dN_q_ful)
>            DEALLOCATE (tau0_q_ful)
>         ENDIF
528c796
<   !
---
> !
529a798
> 200 format(3(1x,f16.10),2x,35(2x,g14.7))
535a805,937
> SUBROUTINE driver_tdbte_el ()
> !----------------------------------------------------------------------------
>   USE kinds,      ONLY : DP
>   USE cell_base,  ONLY : at, bg
>   USE phcom,      ONLY : nmodes
>   USE epwcom,     ONLY : nbndsub, bte, nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, run, phdrag, alloy_pot
>   USE elph2,      ONLY : ibndmin, ibndmax, nbnd_red, &
>                          vel_ful, f_t_ful, f_0_ful
>   USE bte_var
>   USE para_thl
> #ifdef __PARA
>   USE io_global,  ONLY : ionode_id, stdout
>   USE mp,         ONLY : mp_barrier
>   USE mp_global,  ONLY : my_pool_id, inter_pool_comm
> #ENDIF
>   !
>   IMPLICIT NONE
>   !
>   REAL(KIND=DP)              :: transpt(3,3,24)
>   REAL(KIND=DP), ALLOCATABLE :: f_t_pol(:,:)
>   INTEGER                    :: ik, ik0, ibnd, imode
>   INTEGER                    :: nk_pol, ik_pol, ik_star, ik_stop
>   LOGICAL                    :: converge = .FALSE., file_exist
>   INTEGER                    :: iter = 0, iter_rec = 0
>   ! date and time
>   CHARACTER(LEN=8)           :: date_
>   CHARACTER(LEN=10)          :: time_
>   CHARACTER(LEN=5)           :: zone_
>   INTEGER                    :: values_(8)
>   REAL(KIND=DP)              :: t0, t1, ta, tb, tab
>   !
>   !
>   mkq1 = nkf1/nqf1
>   mkq2 = nkf2/nqf2
>   mkq3 = nkf3/nqf3
>   !
>   ! load the needed file
>   CALL kq_load ()
>   CALL kq_red_load ()
>   CALL meta_load ()
>   !
>   ! generate new k list
>   CALL cpu_index ()
>   !
>   ! rotate and copy group velocity from irreducible to full BZ
>   CALL rotate_vel ()
>   !
>   ! initialization of paralellization
>   CALL para_bounds (ik_star, ik_stop, nk_ful_red)
>   nk_pol = ik_stop-ik_star+1
>   !
>   ALLOCATE (f_t_pol(nbnd_red,nk_pol))
>   ALLOCATE (f_t_ful(nbnd_red,nk_ful_red))
>   ALLOCATE (f_0_ful(nbnd_red,nk_ful_red))
>   f_t_ful = 0.0d0
>   f_0_ful = 0.0d0
>   f_t_pol = 0.0d0
>   !
>   ! compute the initial (excited) electron distribution function
>   CALL tdbte_f_0 ()
>   !
>   ! load f_0_ful if BTE/META/f_t_ful exists
>   IF (bte .EQ. 30) THEN
>      INQUIRE(FILE='BTE/META/f_t_ful',EXIST=file_exist)
>      IF (file_exist) CALL ft_load (iter_rec)
>      iter = iter_rec
>   ENDIF
>   !
>   ! td-bte
>   WRITE (stdout,'(/5x,a/)') 'Start calculation...'
>   !
>   DO WHILE (.NOT. converge)
>      !
>      CALL CPU_TIME (t0)
>      !
>      DO ik0 = ik_star, ik_stop
>         !
>         ! ik0 is the id of original kpoint in full BZ ranging from ik_star to ik_stop (totally, from 1 to nk_ful)
>         ! ik_pol = 1 ~ nk_pol, used in storing F_k_pol
>         ik_pol = ik0-ik_star+1
>         !
>         CALL CPU_TIME (ta)
>         CALL iter_tdbte_el (ik0, ik_pol, nk_pol, f_t_pol)
>         CALL CPU_TIME (tb)
>         tab = tab + (tb-ta)
>         !
>         IF (MOD(ik0-ik_star+1,1000) .EQ. 0 .OR. MOD(ik0-ik_star+1,nk_pol) .EQ. 0) THEN
>            CALL DATE_AND_TIME (date_,time_,zone_,values_)
>            WRITE (stdout,'(13x,a,i3,a,i6,a,i6,a,f8.1,a,i2,a,i2,a,i2)') 'Timestep ', iter, '  |  k = (', ik0-ik_star+1, '/', nk_pol, &
>            ') completed  |  Time : ', tab, ' s', values_(5), ':', values_(6), ':', values_(7)
>            tab = 0.0d0
>         ENDIF
>         !
>      ENDDO
>      !
>      CALL mp_barrier (inter_pool_comm)
>      !
>      CALL gether_thl (f_t_ful, f_t_pol, ik_star, ik_stop, seq2nscat)
>      !
>      ! check simulation step
>      IF (iter .EQ. run) converge = .TRUE.
>      !
>      CALL CPU_TIME (t1)
>      !
>      ! output
>      CALL export_ft (iter, converge, 1, 1)
>      CALL export_result (transpt, iter, converge, 1, 1, t1-t0)
>      !
>      ! save the f_t of current iteration as a metafile
>      IF (.NOT. converge) THEN
>         !
>         CALL ft_save (iter)
>         f_0_ful = f_t_ful
>         f_t_ful = 0.0d0
>         !
>      ELSE
>         IF (my_pool_id .EQ. ionode_id) CALL SYSTEM ('rm BTE/META/f_t_ful') 
>      ENDIF
>      !
>      iter = iter + 1
>      !
>   ENDDO ! converge 
>   !
>   !
>   DEALLOCATE (f_0_ful)
>   DEALLOCATE (f_t_ful)
>   DEALLOCATE (f_t_pol)
>   !
> END SUBROUTINE driver_tdbte_el
> 
> 
> 
> !----------------------------------------------------------------------------
556c958
<   REAL(KIND=DP) :: transpt(3,3,7)
---
>   REAL(KIND=DP) :: transpt(3,3,24)
613c1015
<         CALL bte_transpt (transpt, itemp, idope)
---
>         !CALL bte_transpt (transpt, itemp, idope)
621,623c1023,1025
<         CALL export_cumu (iter, converge, itemp, idope)
<         CALL export_onsager (iter, converge, itemp, idope)
<         CALL export_result (transpt, iter, converge, itemp, idope, t1-t0)
---
>         !CALL export_cumu (iter, converge, itemp, idope)
>         !CALL export_onsager (iter, converge, itemp, idope)
>         !CALL export_result (transpt, iter, converge, itemp, idope, t1-t0)
644,646c1046,1050
<   USE epwcom, ONLY : bte, nbndsub, nkf1, nkf2, nkf3, eimp_mode
<   USE elph2,  ONLY : nbnd_red, sigmai_mode_all_abs, sigmai_mode_all_emi, &
<                      sigmai_mode_all_ela_intra, sigmai_mode_all_ela_inter, tau0_k_ful
---
>   USE epwcom, ONLY : bte, nbndsub, nkf1, nkf2, nkf3, alloy_read, eimp_mode, alloy_pot
>   USE constants_epw, ONLY : ryd2ev
>   USE elph2,  ONLY : nbnd_red, sigmai_mode_all_abs, sigmai_mode_all_emi, tau0_k_ful, ibndmin, etf_all, &
>                      sigmai_mode_all_ela_intra, sigmai_mode_all_ela_inter, sigmai_mode_all_alloy_inter, &
>                      sigmai_mode_all_alloy_intra  !zjw
652,653c1056,1057
<   REAL(KIND=DP)       :: sigmai
<   INTEGER             :: ik_ful_red, ibnd, imode, ik_irr_red
---
>   REAL(KIND=DP)       :: sigmai, energy
>   INTEGER             :: ik_ful_red, ibnd, ibnd0, imode, ik_irr_red, i
663a1068,1069
>   ! etf_all(ibnd0,ik)*ryd2ev
> !
664a1071
>         ibnd0 = ibnd+ibndmin-1
668,671c1075,1078
<         sigmai = SUM(sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik_irr_red)) + &
<                  SUM(sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik_irr_red))
< 
<         if (eimp_mode > 0) then
---
>         sigmai =  SUM(sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik_irr_red)) + &
>                   SUM(sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik_irr_red)) 
>         ! zjw 
>         if ((eimp_mode > 0) .and. (.not. alloy_pot)) then
674a1082,1109
>         ! al-el method 1: calculated from input perturbed potential dv_tot
>         !
>         If (alloy_pot)  THEN
>                   sigmai = sigmai + sigmai_mode_all_alloy_inter(itemp,idope,ibnd,ik_irr_red) + &
>                                 sigmai_mode_all_alloy_intra(itemp,idope,ibnd,ik_irr_red) + &
>                                 sigmai_mode_all_ela_intra(itemp,idope,ibnd,ik_irr_red) + &
>                                 sigmai_mode_all_ela_inter(itemp,idope,ibnd,ik_irr_red)
>         ENDIF
>         !
>         ! al-el method 2: use input al-el scattering rate
>         IF (alloy_read)  THEN
>             energy = 0.0d0
>             !
>             energy = etf_all(ibnd0,ik_irr_red)*ryd2ev
>             !
>             i = 1
>          IF (energy .GE. alelrate(1,1) .AND. energy .LE. alelrate(4000,1)) THEN
>             i = int((energy - alelrate(1,1))/1.0d-4)    ! alel_rate.txt energy range 0.4eV with 4000 data points
>             !
>             IF (i .EQ. 4000) THEN
>        sigmai = sigmai + 0.5d0 * alelrate(i,2)
>             !
>             ELSE
>        sigmai = sigmai + 0.5d0 * alelrate(i,2)*(energy - alelrate(i,1))/1.0d-4 + 0.5d0 * alelrate(i+1,2)*(alelrate(i+1,1)-energy)/1.0d-4
>             !
>             ENDIF  ! i
>          ENDIF  ! energy range
>         ENDIF   ! alloy_read
689a1125,1169
> !----------------------------------------------------------------------------
> SUBROUTINE bte_tau0_ph (itemp, idope)
> !----------------------------------------------------------------------------
> #INCLUDE "f_defs.h"
>   USE kinds,  ONLY : DP
>   USE phcom,  ONLY : nmodes
>   USE epwcom, ONLY : bte
>   USE elph2,  ONLY : gammai_mode_all, vph_ful
>   USE constants_epw, ONLY : au2ps, ryd2thz
>   USE bte_var
>   !
>   IMPLICIT NONE
>   !
>   INTEGER, INTENT(IN) :: itemp, idope
>   REAL(KIND=DP)       :: gammai
>   INTEGER             :: iq_ful_red, imode, iq_irr_red, iq_ful
>   !
>   !
>   DO iq_ful_red = 1, nq_ful_red
>      !
>      iq_irr_red = rful2rirr_q(iq_ful_red)
>      iq_ful     = rful2ful_q(iq_ful_red)
>      !
>      DO imode = 1, nmodes
>         !
>         !
>         gammai = 0.0d0
>         !
>         gammai = ph_rate_ful(itemp,imode,iq_ful) + 2.0d0*gammai_mode_all(itemp,idope,imode,iq_irr_red)
>         !
>         IF (gammai .NE. 0.0d0) THEN
>            tau0_q_ful(itemp,imode,iq_ful_red) = 1.0d0 / gammai
>         ELSE
>            tau0_q_ful(itemp,imode,iq_ful_red) = 0.0d0
>         ENDIF
>         !
>      ENDDO
>      !
>   ENDDO
>   !
>   !
> END SUBROUTINE bte_tau0_ph
> 
> 
> 
Only in ./: bte_driver.o
diff ./bte_export.f90 ../../epw-qian/src/bte_export.f90
8a9,10
> ! export cumulative phonon drag (contribution by phonons) properties, added by Qian, Jan 2018 
> !
11,13c13,17
<   USE epwcom,        ONLY : nbndsub, epdim
<   USE elph2,         ONLY : nbnd_red, mfp_k_ful
<   USE constants_epw, ONLY : au2nm
---
>   USE phcom,         ONLY : nmodes
>   USE epwcom,        ONLY : nbndsub, epdim, phdrag
>   USE elph2,         ONLY : gammai_mode_all, ibndmin, ibndmax, nbnd_red, wf_all, etf_all, F_k_ful, &
>                             sigmai_mode_all_abs, sigmai_mode_all_emi, mfp_k_ful, mfp_q_ful
>   USE constants_epw, ONLY : au2nm, ryd2thz, twopi, ryd2ev
28c32
<                                 L11_tot(3,3), inv_L11_tot(3,3), &
---
>                                 L11_tot(3,3), inv_L11(3,3), inv_L11_tot(3,3), &
33,35c37,41
<   REAL(KIND=DP), ALLOCATABLE :: mfp(:)
<   REAL(KIND=DP)              :: mfp_max, mfp_min, mfp_del
<   INTEGER                    :: mfp_num = 300
---
>   REAL(KIND=DP)              :: L33(3,3), L44(3,3), L33_q(3,3), L44_q(3,3), wqq, L33_m(3,3,nmodes), L44_m(3,3,nmodes),&
>                                 length, xq_fbz(3), xk_fbz(3), L44_e(3,3), L44_k(3,3), ekk, sigmai, xful_cry(3)
>   REAL(KIND=DP), ALLOCATABLE :: mfp(:), mfp_ph(:), freq_ph(:)
>   REAL(KIND=DP)              :: mfp_max, mfp_min, mfp_del, mfp_ph_max, mfp_ph_min, mfp_ph_del, freq_max, freq_del
>   INTEGER                    :: mfp_num = 1000
37c43
<   REAL(KIND=DP), ALLOCATABLE :: cod(:,:,:), etc(:,:,:), seb(:,:,:), pof(:,:,:), &
---
>   REAL(KIND=DP), ALLOCATABLE :: cod(:,:,:), etc(:,:,:), seb(:,:,:), pof(:,:,:), spd(:,:,:), ltc(:,:,:), &
39,42c45,54
<                                 cod_lower(:,:,:), etc_lower(:,:,:), seb_lower(:,:,:), pof_lower(:,:,:)
<   !
<   INTEGER                    :: ik, ibnd, i, j, ip, ir, uorl
<   CHARACTER(LEN=256)         :: onsager_ufmt, cumu_fmt, cumu_upper_fmt, cumu_lower_fmt
---
>                                 cod_lower(:,:,:), etc_lower(:,:,:), seb_lower(:,:,:), pof_lower(:,:,:), &
>                                 spd_f(:,:,:), ltc_f(:,:,:),spd_f_m(:,:,:,:), ltc_f_m(:,:,:,:), &
>                                 spd_m(:,:,:,:), ltc_m(:,:,:,:), spd_e(:,:,:), spd_x(:,:,:), spd_l(:,:,:), &
>                                 seb_x(:,:,:), seb_l(:,:,:), seb_g(:,:,:), spd_g(:,:,:)
>   !
>   INTEGER                    :: ik, ik_ful, ik_irr_red, ik_ful_red, iq, iq_ful, iq_irr_red, ibnd, ibnd0, imode,&
>                                 i, j, ip, ir, uorl
>   CHARACTER(LEN=256)         :: onsager_ufmt, phdrag_ufmt, phdragcumu_MFP_fmt, cumu_fmt, cumu_upper_fmt, &
>                                 cumu_lower_fmt, phdragcumu_freq_fmt, rate_RTA_3Dphdrag_fmt, phdragcumu_k_MFP_fmt, &
>                                 rate_k_RTA_3Dphdrag_fmt, phdrag_k_ufmt
52a65,69
>      !
>      phdrag_ufmt = 'BTE/META/phdrag_q_'//TRIM(ADJUSTL(txnx))
>      phdrag_k_ufmt = 'BTE/META/phdrag_k_'//TRIM(ADJUSTL(txnx))
>      !
>      !
55a73,75
>      phdragcumu_MFP_fmt = 'BTE/'//TRIM(ADJUSTL(txnx))//'/phdrag_MFPcumu.dat'
>      phdragcumu_k_MFP_fmt = 'BTE/'//TRIM(ADJUSTL(txnx))//'/phdrag_k_MFPcumu.dat'
>      phdragcumu_freq_fmt = 'BTE/'//TRIM(ADJUSTL(txnx))//'/phdrag_freqcumu.dat'
60c80
<      ! 1. find the maximum and minimun of mfp
---
>      ! 1. find the maximum and minimun of mfp, freq
62a83,85
>      mfp_ph_min = +1.0d+30
>      mfp_ph_max = -1.0d+30
>      freq_max  = 0.0d0
74a98,114
>      IF (phdrag) THEN 
>       DO iq = 1, nq_ful_red
>         iq_irr_red = rful2rirr_q(iq)
>         DO imode = 1, nmodes
>            !
>            IF (mfp_q_ful(imode,iq) .LT. mfp_ph_min .AND. mfp_q_ful(imode,iq) .GE. 0.0d0) mfp_ph_min = mfp_q_ful(imode,iq)
>            IF (mfp_q_ful(imode,iq) .GT. mfp_ph_max) mfp_ph_max = mfp_q_ful(imode,iq)
>            !
>            IF (wf_all(imode,iq_irr_red) .GT. freq_max) freq_max = wf_all(imode,iq_irr_red)
>            !
>         ENDDO
>       ENDDO
>       !
>       mfp_ph_del = (mfp_ph_max-mfp_ph_min)/DBLE(mfp_num-1)
>       freq_del = (freq_max)/DBLE(mfp_num-1)
>       !
>      ENDIF
111a152,153
>      IF (phdrag) ALLOCATE (mfp_ph(mfp_num))
>      IF (phdrag) ALLOCATE (freq_ph(mfp_num))
114a157,159
>      ALLOCATE (seb_x(3,3,mfp_num))
>      ALLOCATE (seb_l(3,3,mfp_num))
>      ALLOCATE (seb_g(3,3,mfp_num))
115a161,172
>      IF (phdrag) ALLOCATE (spd_e(3,3,mfp_num))
>      IF (phdrag) ALLOCATE (spd_x(3,3,mfp_num))
>      IF (phdrag) ALLOCATE (spd_l(3,3,mfp_num))
>      IF (phdrag) ALLOCATE (spd_g(3,3,mfp_num))
>      IF (phdrag) ALLOCATE (spd(3,3,mfp_num))
>      IF (phdrag) ALLOCATE (ltc(3,3,mfp_num))
>      IF (phdrag) ALLOCATE (spd_f(3,3,mfp_num))
>      IF (phdrag) ALLOCATE (ltc_f(3,3,mfp_num))
>      IF (phdrag) ALLOCATE (spd_m(3,3,nmodes,mfp_num))
>      IF (phdrag) ALLOCATE (ltc_m(3,3,nmodes,mfp_num))
>      IF (phdrag) ALLOCATE (spd_f_m(3,3,nmodes,mfp_num))
>      IF (phdrag) ALLOCATE (ltc_f_m(3,3,nmodes,mfp_num))
124a182,183
>      IF (phdrag) mfp_ph = 0.0d0
>      IF (phdrag) freq_ph = 0.0d0
127a187,189
>      seb_x = 0.0d0
>      seb_l = 0.0d0
>      seb_g = 0.0d0
128a191,202
>      IF (phdrag) ltc = 0.0d0
>      IF (phdrag) spd = 0.0d0
>      IF (phdrag) spd_e = 0.0d0
>      IF (phdrag) spd_x = 0.0d0
>      IF (phdrag) spd_l = 0.0d0
>      IF (phdrag) spd_g = 0.0d0
>      IF (phdrag) ltc_f = 0.0d0
>      IF (phdrag) spd_f = 0.0d0
>      IF (phdrag) ltc_m = 0.0d0
>      IF (phdrag) spd_m = 0.0d0
>      IF (phdrag) ltc_f_m = 0.0d0
>      IF (phdrag) spd_f_m = 0.0d0
138a213,215
>      IF (phdrag) OPEN (33333,FILE=phdrag_k_ufmt,FORM='unformatted',ACCESS='direct',RECL=(1+9)*DP,STATUS='old')
>      OPEN (7777,FILE='BTE/META/rful2ful',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='old')
>      OPEN (6666,FILE='BTE/META/xkf_ful_cryst',FORM='unformatted',ACCESS='direct',RECL=3*DP,STATUS='old')
147a225
>         IF (phdrag) L44_e = 0.0d0
157a236,239
>            !
>            READ (7777,REC=ik) ik_ful
>            READ (6666,REC=ik_ful) xful_cry(1:3)
>            !
161a244
>                  IF (phdrag) READ (33333,REC=(ik-1)*nbnd_red+ibnd)  ekk, L44_k(1:3,1:3)
167a251
>                  IF (phdrag) L44_k = 0.0d0
175a260,297
>               ! seperate valleys' contributions
>         IF ((SQRT((xful_cry(1)-0.5d0)**2 + (xful_cry(2)-0.5d0)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.5d0)**2 + xful_cry(2)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT(xful_cry(1)**2 + (xful_cry(2)-0.5d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT(xful_cry(1)**2 + xful_cry(2)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.5d0)**2 + (xful_cry(2)-1.0d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2 + (xful_cry(2)-0.5d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2 + (xful_cry(2)-1.0d0)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.5d0)**2 + (xful_cry(2)-1.0d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2 + (xful_cry(2)-0.5d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2 + xful_cry(2)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.5d0)**2 + xful_cry(2)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT(xful_cry(1)**2 + (xful_cry(2)-0.5d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT(xful_cry(1)**2 + (xful_cry(2)-1.0d0)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625)) THEN  ! crystal: L 0.5 0.5 0.5, 0/1 0/1 0.5, 0/1 0.5 0/1, 0.5 0/1 0/1
>         !
>         seb_l(:,:,ip) =  seb_l(:,:,ip) + L12_k
>         !
>         ELSEIF ((SQRT((xful_cry(1)-0.425d0)**2 + (xful_cry(2)-0.425d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.425d0)**2 + (xful_cry(3)-0.425d0)**2+ xful_cry(2)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(3)-0.425d0)**2 + (xful_cry(2)-0.425d0)**2+ xful_cry(1)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.425d0)**2 + (xful_cry(2)-0.425d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.425d0)**2 + (xful_cry(3)-0.425d0)**2+ (xful_cry(2)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(3)-0.425d0)**2 + (xful_cry(2)-0.425d0)**2+ (xful_cry(1)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.575d0)**2 + (xful_cry(2)-0.575d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.575d0)**2 + (xful_cry(3)-0.575d0)**2+ xful_cry(2)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(3)-0.575d0)**2 + (xful_cry(2)-0.575d0)**2+ xful_cry(1)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.575d0)**2 + (xful_cry(2)-0.575d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.575d0)**2 + (xful_cry(3)-0.575d0)**2+ (xful_cry(2)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(3)-0.575d0)**2 + (xful_cry(2)-0.575d0)**2+ (xful_cry(1)-1.0d0)**2) .LT. 0.0625)) THEN   ! Si crystal: near X 0/1 0.425 0.425 or 0/1 0.575 0.575
>         !
>         seb_x(:,:,ip) =  seb_x(:,:,ip) + L12_k
>         !
>         ELSEIF ((SQRT(xful_cry(1)**2+ xful_cry(2)**2 + xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2+ (xful_cry(2)-1.0d0)**2 + (xful_cry(3)-1.0d0)**2) .LT. 0.0625)) THEN  !gamma
>         !
>         seb_g(:,:,ip) =  seb_g(:,:,ip) + L12_k
>         !
>         ENDIF ! select coordinates
>         !
>         !
>               !
>               IF (phdrag) THEN 
>                 L44_e = L44_e + L44_k
>               !
>               ! seperate valleys' contributions
>         IF ((SQRT((xful_cry(1)-0.5d0)**2 + (xful_cry(2)-0.5d0)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.5d0)**2 + xful_cry(2)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT(xful_cry(1)**2 + (xful_cry(2)-0.5d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT(xful_cry(1)**2 + xful_cry(2)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.5d0)**2 + (xful_cry(2)-1.0d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2 + (xful_cry(2)-0.5d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2 + (xful_cry(2)-1.0d0)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.5d0)**2 + (xful_cry(2)-1.0d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2 + (xful_cry(2)-0.5d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2 + xful_cry(2)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.5d0)**2 + xful_cry(2)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT(xful_cry(1)**2 + (xful_cry(2)-0.5d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT(xful_cry(1)**2 + (xful_cry(2)-1.0d0)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625)) THEN  ! crystal: L 0.5 0.5 0.5, 0/1 0/1 0.5, 0/1 0.5 0/1, 0.5 0/1 0/1
>         !
>         spd_l(:,:,ip) =  spd_l(:,:,ip) + L44_k
>         !
>         ELSEIF ((SQRT((xful_cry(1)-0.425d0)**2 + (xful_cry(2)-0.425d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.425d0)**2 + (xful_cry(3)-0.425d0)**2+ xful_cry(2)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(3)-0.425d0)**2 + (xful_cry(2)-0.425d0)**2+ xful_cry(1)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.425d0)**2 + (xful_cry(2)-0.425d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.425d0)**2 + (xful_cry(3)-0.425d0)**2+ (xful_cry(2)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(3)-0.425d0)**2 + (xful_cry(2)-0.425d0)**2+ (xful_cry(1)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.575d0)**2 + (xful_cry(2)-0.575d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.575d0)**2 + (xful_cry(3)-0.575d0)**2+ xful_cry(2)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(3)-0.575d0)**2 + (xful_cry(2)-0.575d0)**2+ xful_cry(1)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.575d0)**2 + (xful_cry(2)-0.575d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.575d0)**2 + (xful_cry(3)-0.575d0)**2+ (xful_cry(2)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(3)-0.575d0)**2 + (xful_cry(2)-0.575d0)**2+ (xful_cry(1)-1.0d0)**2) .LT. 0.0625)) THEN   ! Si crystal: near X 0/1 0.425 0.425 or 0/1 0.575 0.575
>         !
>         spd_x(:,:,ip) =  spd_x(:,:,ip) + L44_k
>         !
>         ELSEIF ((SQRT(xful_cry(1)**2+ xful_cry(2)**2 + xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2+ (xful_cry(2)-1.0d0)**2 + (xful_cry(3)-1.0d0)**2) .LT. 0.0625)) THEN  !gamma
>         !
>         !
>         spd_g(:,:,ip) =  spd_g(:,:,ip) + L44_k
>         !
>         ENDIF ! select coordinates
>         !
>               ENDIF ! if phonon drag
>               !
190,191c312,313
<            ENDDO
<         ENDDO
---
>            ENDDO !ibnd
>         ENDDO !nk_ful_red
198a321
>            IF (phdrag) L44_e(3,3)   = 1.0d0
210,223c333
<         cod(:,:,ip) = L11                         
<         etc(:,:,ip) = L22 - MATMUL(MATMUL(L21,inv_L11_tot),L12)  
<         seb(:,:,ip) = MATMUL(inv_L11_tot,L12)
<         pof(:,:,ip) = MATMUL(MATMUL(seb(:,:,ip),seb(:,:,ip)),cod(:,:,ip))
<         !
<         cod_upper(:,:,ip) = L11_upper                         
<         etc_upper(:,:,ip) = L22_upper - MATMUL(MATMUL(L21_upper,inv_L11_tot),L12_upper)  
<         seb_upper(:,:,ip) = MATMUL(inv_L11_tot,L12_upper)
<         pof_upper(:,:,ip) = MATMUL(MATMUL(seb_upper(:,:,ip),seb_upper(:,:,ip)),cod_upper(:,:,ip))
<         !
<         cod_lower(:,:,ip) = L11_lower                         
<         etc_lower(:,:,ip) = L22_lower - MATMUL(MATMUL(L21_lower,inv_L11_tot),L12_lower)  
<         seb_lower(:,:,ip) = MATMUL(inv_L11_tot,L12_lower)
<         pof_lower(:,:,ip) = MATMUL(MATMUL(seb_lower(:,:,ip),seb_lower(:,:,ip)),cod_lower(:,:,ip))
---
>         IF (FindDet(L11,3) .EQ. 0.0d0) THEN
225c335,366
<      ENDDO
---
>          cod(:,:,ip) = 0.0d0                       
>         !
>          cod_upper(:,:,ip) = 0                       
>         !
>          cod_lower(:,:,ip) = 0                        
>         !
>         ELSE
>          inv_L11 = imat(L11)
>          cod(:,:,ip) = L11                         
>          etc(:,:,ip) = L22 - MATMUL(MATMUL(L21,inv_L11_tot),L12)  
>          seb(:,:,ip) = MATMUL(inv_L11_tot,L12)* 1.0d+6        ! [uV/K]
>          seb_x(:,:,ip) = MATMUL(inv_L11_tot,seb_x(:,:,ip))* 1.0d+6        ! [uV/K]
>          seb_l(:,:,ip) = MATMUL(inv_L11_tot,seb_l(:,:,ip))* 1.0d+6        ! [uV/K]
>          seb_g(:,:,ip) = MATMUL(inv_L11_tot,seb_g(:,:,ip))* 1.0d+6        ! [uV/K]
>          pof(:,:,ip) = MATMUL(MATMUL(seb(:,:,ip),seb(:,:,ip)),cod(:,:,ip))
>          IF (phdrag) spd_e(:,:,ip) = MATMUL(inv_L11_tot,L44_e) * 1.0d+6        ! [uV/K]
>          IF (phdrag) spd_x(:,:,ip) = MATMUL(inv_L11_tot,spd_x(:,:,ip)) * 1.0d+6        ! [uV/K]
> 	 IF (phdrag) spd_l(:,:,ip) = MATMUL(inv_L11_tot,spd_l(:,:,ip)) * 1.0d+6        ! [uV/K]
> 	 IF (phdrag) spd_g(:,:,ip) = MATMUL(inv_L11_tot,spd_g(:,:,ip)) * 1.0d+6        ! [uV/K]
>         !
>          cod_upper(:,:,ip) = L11_upper                         
>          etc_upper(:,:,ip) = L22_upper - MATMUL(MATMUL(L21_upper,inv_L11_tot),L12_upper)  
>          seb_upper(:,:,ip) = MATMUL(inv_L11_tot,L12_upper)
>          pof_upper(:,:,ip) = MATMUL(MATMUL(seb_upper(:,:,ip),seb_upper(:,:,ip)),cod_upper(:,:,ip))
>         !
>          cod_lower(:,:,ip) = L11_lower                         
>          etc_lower(:,:,ip) = L22_lower - MATMUL(MATMUL(L21_lower,inv_L11_tot),L12_lower)  
>          seb_lower(:,:,ip) = MATMUL(inv_L11_tot,L12_lower)
>          pof_lower(:,:,ip) = MATMUL(MATMUL(seb_lower(:,:,ip),seb_lower(:,:,ip)),cod_lower(:,:,ip))
>         !
>         ENDIF
>      ENDDO  ! ip
232a374,376
>      CALL mp_sum (seb_x,inter_pool_comm)
>      CALL mp_sum (seb_l,inter_pool_comm)
>      CALL mp_sum (seb_g,inter_pool_comm)
233a378,381
>      IF (phdrag) CALL mp_sum (spd_e,inter_pool_comm)
>      IF (phdrag) CALL mp_sum (spd_x,inter_pool_comm)
>      IF (phdrag) CALL mp_sum (spd_l,inter_pool_comm)
>      IF (phdrag) CALL mp_sum (spd_g,inter_pool_comm)
244a393,450
>      CLOSE (7777)
>      CLOSE (6666)
>      IF (phdrag) CLOSE (33333)
>      !
>      !
>      IF (phdrag) THEN
>       !
>       ! cumulation on phonon MFP
>       !
>       CALL para_bounds (ip_star, ip_stop, mfp_num)
>       !
>       OPEN (1221,FILE=phdrag_ufmt,FORM='unformatted',ACCESS='direct',RECL=(1+2*9)*DP,STATUS='old')
>       !
>       DO ip = ip_star, ip_stop
>         !
>         mfp_ph(ip) = mfp_ph_min + DBLE(ip-1)*mfp_ph_del
>         !
>         L33 = 0.0d0
>         L44 = 0.0d0
>         L33_m = 0.0d0
>         L44_m = 0.0d0         
>         !
>         DO imode = 1, nmodes
>            DO iq = 1, nq_ful_red
>               !
>               IF (mfp_q_ful(imode,iq) .LE. mfp_ph(ip)) THEN
>                  READ (1221,REC=(iq-1)*nmodes+imode) wqq, L44_q(1:3,1:3), L33_q(1:3,1:3)
>               ELSE
>                  !
>                  L33_q = 0.0d0
>                  L44_q = 0.0d0
>                  !  
>               ENDIF
>                  L33 = L33 + L33_q
>                  L44 = L44 + L44_q
>                  L33_m(:,:,imode) = L33_m(:,:,imode) + L33_q
>                  L44_m(:,:,imode) = L44_m(:,:,imode) + L44_q
>             ENDDO ! iq
>             !
>         ENDDO  ! imode      
>            !
>            IF (epdim .EQ. 2) THEN
>            !
>            L33(3,3)   = 1.0d0
>            L44(3,3)   = 1.0d0
>            L33_m(3,3,:)   = 1.0d0
>            L44_m(3,3,:)   = 1.0d0
>            !
>            ENDIF
>            !
>            ltc(:,:,ip) = L33                                     ! [W/m/K]
>            spd(:,:,ip) = MATMUL(inv_L11_tot,L44) * 1.0d+6        ! [uV/K]
>            DO imode = 1, nmodes
>             ltc_m(:,:,imode,ip) = L33_m(:,:,imode)                                     ! [W/m/K]
>             spd_m(:,:,imode,ip) = MATMUL(inv_L11_tot,L44_m(:,:,imode)) * 1.0d+6        ! [uV/K]
>            ENDDO  
>            !
>      ENDDO ! MFP(ip)
245a452,459
> #ifdef __PARA
>      CALL mp_barrier (inter_pool_comm)
>      CALL mp_sum (mfp_ph,inter_pool_comm)
>      CALL mp_sum (ltc,inter_pool_comm)
>      CALL mp_sum (spd,inter_pool_comm)
>      CALL mp_sum (ltc_m,inter_pool_comm)
>      CALL mp_sum (spd_m,inter_pool_comm)
> #ENDIF 
247,267c461,464
<      ! 4. normalization
<     ! DO ir = 1, 3
<     !    DO ip = 1, mfp_num
<     !       !
<     !       cod(ir,ir,ip) = cod(ir,ir,ip)/cod(ir,ir,mfp_num)
<     !       etc(ir,ir,ip) = etc(ir,ir,ip)/etc(ir,ir,mfp_num)
<     !       seb(ir,ir,ip) = seb(ir,ir,ip)/seb(ir,ir,mfp_num)
<     !       pof(ir,ir,ip) = pof(ir,ir,ip)/pof(ir,ir,mfp_num)
<     !       !
<     !       cod_upper(ir,ir,ip) = cod_upper(ir,ir,ip)/cod(ir,ir,mfp_num)
<     !       etc_upper(ir,ir,ip) = etc_upper(ir,ir,ip)/etc(ir,ir,mfp_num)
<     !       seb_upper(ir,ir,ip) = seb_upper(ir,ir,ip)/seb(ir,ir,mfp_num)
<     !       pof_upper(ir,ir,ip) = pof_upper(ir,ir,ip)/pof(ir,ir,mfp_num)
<     !       !
<     !       cod_lower(ir,ir,ip) = cod_lower(ir,ir,ip)/cod(ir,ir,mfp_num)
<     !       etc_lower(ir,ir,ip) = etc_lower(ir,ir,ip)/etc(ir,ir,mfp_num)
<     !       seb_lower(ir,ir,ip) = seb_lower(ir,ir,ip)/seb(ir,ir,mfp_num)
<     !       pof_lower(ir,ir,ip) = pof_lower(ir,ir,ip)/pof(ir,ir,mfp_num)
<     !       !
<     !    ENDDO
<     ! ENDDO
---
>      CLOSE (1221)
>      !
>      CALL para_bounds (ip_star, ip_stop, mfp_num)
>      ! cumulation on phonon frequency
268a466,527
>      OPEN (2332,FILE=phdrag_ufmt,FORM='unformatted',ACCESS='direct',RECL=(1+2*9)*DP,STATUS='old')
>      !
>       DO ip = ip_star, ip_stop
>         !
>         freq_ph(ip) = DBLE(ip-1)*freq_del
>         !
>         L33 = 0.0d0
>         L44 = 0.0d0
>         L33_m = 0.0d0
>         L44_m = 0.0d0 
>         !
>         DO imode = 1, nmodes
>            DO iq = 1, nq_ful_red
>            iq_irr_red = rful2rirr_q(iq)
>               !
>               IF (wf_all(imode,iq_irr_red) .LE. freq_ph(ip)) THEN
>                  READ (2332,REC=(iq-1)*nmodes+imode) wqq, L44_q(1:3,1:3), L33_q(1:3,1:3)
>               ELSE
>                  !
>                  L33_q = 0.0d0
>                  L44_q = 0.0d0
>                  !  
>               ENDIF
>                  L33 = L33 + L33_q
>                  L44 = L44 + L44_q
>                  L33_m(:,:,imode) = L33_m(:,:,imode) + L33_q
>                  L44_m(:,:,imode) = L44_m(:,:,imode) + L44_q
>            ENDDO  ! iq
>         ENDDO  ! imode     
>            !
>            IF (epdim .EQ. 2) THEN
>            !
>            L33(3,3)   = 1.0d0
>            L44(3,3)   = 1.0d0
>            L33_m(3,3,:)   = 1.0d0
>            L44_m(3,3,:)   = 1.0d0
>            !
>            ENDIF
>            !
>            ltc_f(:,:,ip) = L33                                     ! [W/m/K]
>            spd_f(:,:,ip) = MATMUL(inv_L11_tot,L44) * 1.0d+6        ! [uV/K]
>            !
>            DO imode = 1, nmodes
>             ltc_f_m(:,:,imode,ip) = L33_m(:,:,imode)                                     ! [W/m/K]
>             spd_f_m(:,:,imode,ip) = MATMUL(inv_L11_tot,L44_m(:,:,imode)) * 1.0d+6        ! [uV/K]
>            ENDDO 
>      ENDDO ! freq_ph(ip)
>      !
> #ifdef __PARA
>      CALL mp_barrier (inter_pool_comm)
>      CALL mp_sum (freq_ph,inter_pool_comm)
>      CALL mp_sum (ltc_f,inter_pool_comm)
>      CALL mp_sum (spd_f,inter_pool_comm)
>      CALL mp_sum (ltc_f_m,inter_pool_comm)
>      CALL mp_sum (spd_f_m,inter_pool_comm)
> #ENDIF   
>      !
>      CLOSE (2332) 
>      !
>      ENDIF  ! phdrag
>      !
>      ! 4. normalization
273a533,535
>         IF (phdrag) OPEN (7223,FILE=phdragcumu_MFP_fmt,STATUS='replace')
>         IF (phdrag)  OPEN (8992,FILE=phdragcumu_freq_fmt,STATUS='replace')
>         IF (phdrag) OPEN (4455,FILE=phdragcumu_k_MFP_fmt,STATUS='replace')
275a538,539
>         OPEN (2224,FILE='BTE/'//TRIM(ADJUSTL(txnx))//'/Seebeck_k_MFPcum_XLG.dat',STATUS='replace')
>      !
280,282c544,546
<                WRITE (9999,'(es14.4,12es13.5)') mfp(ip)*au2nm, cod(1,1,ip), etc(1,1,ip), seb(1,1,ip)*1.0d+6, pof(1,1,ip)*1.0d+4, &
<                                                                cod(2,2,ip), etc(2,2,ip), seb(2,2,ip)*1.0d+6, pof(2,2,ip)*1.0d+4, &
<                                                                cod(3,3,ip), etc(3,3,ip), seb(3,3,ip)*1.0d+6, pof(3,3,ip)*1.0d+4
---
>                WRITE (9999,'(es14.4,12es13.5)') mfp(ip)*au2nm, cod(1,1,ip), etc(1,1,ip), seb(1,1,ip), pof(1,1,ip)*1.0d+4, &
>                                                                cod(2,2,ip), etc(2,2,ip), seb(2,2,ip), pof(2,2,ip)*1.0d+4, &
>                                                                cod(3,3,ip), etc(3,3,ip), seb(3,3,ip), pof(3,3,ip)*1.0d+4
291a556,569
>                WRITE (2224,'(es14.4,4es13.5)') mfp(ip)*au2nm, (seb(1,1,ip)+seb(2,2,ip)+seb(3,3,ip))/3.0d0, &
>                (seb_x(1,1,ip)+seb_x(2,2,ip)+seb_x(3,3,ip))/3.0d0,(seb_l(1,1,ip)+seb_l(2,2,ip)+seb_l(3,3,ip))/3.0d0, &
>                (seb_g(1,1,ip)+seb_g(2,2,ip)+seb_g(3,3,ip))/3.0d0
>                !
>                IF (phdrag) WRITE (4455,'(es14.4,4es13.5)') mfp(ip)*au2nm, &
>                (spd_e(1,1,ip)+spd_e(2,2,ip)+spd_e(3,3,ip))/3.0d0, (spd_x(1,1,ip)+spd_x(2,2,ip)+spd_x(3,3,ip))/3.0d0, &
>                (spd_l(1,1,ip)+spd_l(2,2,ip)+spd_l(3,3,ip))/3.0d0, (spd_g(1,1,ip)+spd_g(2,2,ip)+spd_g(3,3,ip))/3.0d0
>                IF (phdrag) WRITE (7223,'(es14.4,18es13.5)') mfp_ph(ip)*au2nm, spd(1,1,ip), ltc(1,1,ip),spd(2,2,ip), ltc(2,2,ip),&
>                                                                  spd(3,3,ip), ltc(3,3,ip),spd_m(1,1,1:6,ip),&
>                                                                  ltc_m(1,1,1:6,ip)
>                IF (phdrag) WRITE (8992,'(es14.4,18es13.5)') freq_ph(ip)*ryd2thz, spd_f(1,1,ip), ltc_f(1,1,ip), spd_f(2,2,ip), &
>                                                                  ltc_f(2,2,ip), spd_f(3,3,ip), ltc_f(3,3,ip), &
>                                                                  spd_f_m(1,1,1:6,ip), ltc_f_m(1,1,1:6,ip)
>                !
294,295c572,573
<                WRITE (9999,'(es14.4,8es13.5)') mfp(ip)*au2nm, cod(1,1,ip), etc(1,1,ip), seb(1,1,ip)*1.0d+6, pof(1,1,ip)*1.0d+4, &
<                                                               cod(2,2,ip), etc(2,2,ip), seb(2,2,ip)*1.0d+6, pof(2,2,ip)*1.0d+4
---
>                WRITE (9999,'(es14.4,8es13.5)') mfp(ip)*au2nm, cod(1,1,ip), etc(1,1,ip), seb(1,1,ip), pof(1,1,ip)*1.0d+4, &
>                                                               cod(2,2,ip), etc(2,2,ip), seb(2,2,ip), pof(2,2,ip)*1.0d+4
301a580,584
>                IF (phdrag) WRITE (7223,'(es14.4,16es13.5)') mfp_ph(ip)*au2nm, spd(1,1,ip), ltc(1,1,ip),spd(2,2,ip), ltc(2,2,ip),&
>                                                                  spd_m(1,1,1:6,ip), ltc_m(1,1,1:6,ip)
>                IF (phdrag) WRITE (8992,'(es14.4,16es13.5)') freq_ph(ip)*ryd2thz, spd_f(1,1,ip), ltc_f(1,1,ip), spd_f(2,2,ip), &
>                                                                  ltc_f(2,2,ip), spd_f_m(1,1,1:6,ip), &
>                                                                  ltc_f_m(1,1,1:6,ip)              
308a592,595
>         CLOSE (2224)
>         IF (phdrag) CLOSE (7223)
>         IF (phdrag) CLOSE (8992)
>         IF (phdrag) CLOSE (4455)
310c597,672
<      ENDIF
---
>         ! output each q phdrag contribution, el-ph scattering rate, MFP
>            !
>            !
>            rate_RTA_3Dphdrag_fmt = 'BTE/'//TRIM(ADJUSTL(txnx))//'/rful_q_phdrag_3D.dat'
>            !
>            !
>            IF (phdrag) THEN
>            !
>            OPEN (2332,FILE=phdrag_ufmt,FORM='unformatted',ACCESS='direct',RECL=(1+2*9)*DP,STATUS='old')
>            OPEN (8788,FILE='BTE/META/xqf_fbz_cart',FORM='unformatted',ACCESS='direct',RECL=3*DP,STATUS='old')
>            OPEN (9899,FILE=rate_RTA_3Dphdrag_fmt,STATUS='replace')
>            
>            DO iq = 1, nq_ful_red
>             iq_ful = rful2ful_q(iq)
>             READ (8788,REC=iq_ful) xq_fbz(1:3)
>            !
>             length = SQRT(DOT_PRODUCT(xq_fbz,xq_fbz))
>            !
>             DO imode = 1, nmodes
>              READ (2332,REC=(iq-1)*nmodes+imode) wqq, L44_q(1:3,1:3), L33_q(1:3,1:3)
>              L44_q = MATMUL(inv_L11_tot,L44_q)*1.0d+6  ! = spd_q 
>            !
>              WRITE (9899,'(i8,f12.6,f11.4,3es14.4)') iq_irr_red, length, wqq*ryd2thz, mfp_q_ful(imode,iq)*au2nm, &
>                    				     (L44_q(1,1)+L44_q(2,2)+L44_q(3,3))/3.0d0, L33_q(1,1) 
>            !
>            ! [THz]
>            ! L33_q                                     ! [W/m/K]
>            ! MATMUL(inv_L11_tot,L44_q) * 1.0d+6        ! [uV/K]
>            !
>             ENDDO  ! nmodes
>            ENDDO  ! nq_ful_red	   
>            !
>            CLOSE (2332) 
>            CLOSE (8788)
>            CLOSE (9899)
>            !
>            ! output each k phdrag contribution, el-ph scattering rate, MFP
>            !
>            !
>            rate_k_RTA_3Dphdrag_fmt = 'BTE/'//TRIM(ADJUSTL(txnx))//'/rful_k_phdrag_3D.dat'
>            !
>            !
>            OPEN (44444,FILE=phdrag_k_ufmt,FORM='unformatted',ACCESS='direct',RECL=(1+9)*DP,STATUS='old')
>            OPEN (99999,FILE='BTE/META/xkf_fbz_cart',FORM='unformatted',ACCESS='direct',RECL=3*DP,STATUS='old')
>            OPEN (66666,FILE=rate_k_RTA_3Dphdrag_fmt,STATUS='replace')
>            
>            DO ik_ful_red = 1, nk_ful_red
>             ik_ful = rful2ful(ik_ful_red)
>             ! ik = ful2rful(ik_ful) ! nk_ful_red
>             READ (99999,REC=ik_ful) xk_fbz(1:3)
>            !
>             length = SQRT(DOT_PRODUCT(xk_fbz,xk_fbz))
>            !
>             DO ibnd = 1, nbnd_red
>            !
>            !sigmai = 2.0d0 * ( SUM(sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik_irr_red)) + SUM(sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik_irr_red)) )
>            !
>                READ (44444,REC=(ik_ful_red-1)*nbnd_red+ibnd) ekk, L44_k(1:3,1:3)
>                L44_k = MATMUL(inv_L11_tot,L44_k)*1.0d+6  ! = spd_k
>            !
>                WRITE (66666,'(i8,f12.6,f11.4,2es14.4)') ik_ful_red, length, ekk*ryd2ev, &
>                                                         mfp_k_ful(ibnd,ik_ful_red)*au2nm, L44_k(1,1)
>            !
>            ! [THz] [Thz]
>            ! Output L44_k = (inv_L11,L44_k) * 1.0d+6        ! [uV/K]
>            !
>             ENDDO  ! nbnd_red
>            ENDDO  ! nk_irr_red	   
>            !
> 
>            CLOSE (44444) 
>            CLOSE (99999)
>            CLOSE (66666)
>            !
>            ENDIF !phdrag
>      ENDIF ! mypool
313a676,677
>      IF (phdrag) DEALLOCATE (mfp_ph)
>      IF (phdrag) DEALLOCATE (freq_ph)
316a681,683
>      DEALLOCATE (seb_x)
>      DEALLOCATE (seb_l)
>      DEALLOCATE (seb_g)
317a685,696
>      IF (phdrag) DEALLOCATE (ltc)
>      IF (phdrag) DEALLOCATE (spd)
>      IF (phdrag) DEALLOCATE (spd_e)
>      IF (phdrag) DEALLOCATE (spd_x)
>      IF (phdrag) DEALLOCATE (spd_l)
>      IF (phdrag) DEALLOCATE (spd_g)
>      IF (phdrag) DEALLOCATE (ltc_f)
>      IF (phdrag) DEALLOCATE (spd_f)
>      IF (phdrag) DEALLOCATE (ltc_m)
>      IF (phdrag) DEALLOCATE (spd_m)
>      IF (phdrag) DEALLOCATE (ltc_f_m)
>      IF (phdrag) DEALLOCATE (spd_f_m)
327c706
<   ENDIF
---
>   ENDIF 
337c716
< ! export electron scattering rate of each mode under RTA
---
> ! export el-ph electron scattering rate of each mode under RTA, anbd al-el scattering rate
344c723
<   USE epwcom,        ONLY : nbndsub, bte
---
>   USE epwcom,        ONLY : nbndsub, bte, alloy_pot
346c725,726
<                             etf_all, sigmai_mode_all_abs, sigmai_mode_all_emi, mfp_k_ful, vel_ful
---
>                             etf_all, sigmai_mode_all_abs, sigmai_mode_all_emi, sigmai_mode_all_alloy_inter, &
>                             sigmai_mode_all_alloy_intra, mfp_k_ful, vel_ful
395c775,779
<               sigmai = 2.0d0 * ( SUM(sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik)) + SUM(sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik)) )
---
>               IF (alloy_pot) THEN
>               sigmai = 2.0d0 * ( SUM(sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik)) + SUM(sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik)) + sigmai_mode_all_alloy_inter(itemp,idope,ibnd,ik) + sigmai_mode_all_alloy_intra(itemp,idope,ibnd,ik))
>               ELSE
>               sigmai = 2.0d0 * ( SUM(sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik)) + SUM(sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik)))
>               ENDIF
399,401c783,795
<               IF (sigmai .NE. 0.0d0) WRITE (9999,'(i12,i5,f10.4,96es14.4)') ik_ful, ibnd0, etf_all(ibnd0,ik)*ryd2ev, &
<                                      2.0d0*sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik)*ryd2thz*twopi, &
<                                      2.0d0*sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik)*ryd2thz*twopi  
---
>               IF (sigmai .NE. 0.0d0) THEN
>                IF (alloy_pot) THEN
> WRITE (9999,'(i12,i5,f10.4,96es14.4)') ik_ful, ibnd0, etf_all(ibnd0,ik)*ryd2ev, &
> 2.0d0*sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik)*ryd2thz*twopi, & ! ryd2thz*twopi = 1/au2ps
> 2.0d0*sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik)*ryd2thz*twopi, &    ! 2*sigmai is in units of [1/au_s]
> 2.0d0*sigmai_mode_all_alloy_intra(itemp,idope,ibnd,ik)*ryd2thz*twopi, &
> 2.0d0*sigmai_mode_all_alloy_inter(itemp,idope,ibnd,ik)*ryd2thz*twopi
>                ELSE
> WRITE (9999,'(i12,i5,f10.4,96es14.4)') ik_ful, ibnd0, etf_all(ibnd0,ik)*ryd2ev, &
> 2.0d0*sigmai_mode_all_abs(itemp,idope,1:nmodes,ibnd,ik)*ryd2thz*twopi, & ! ryd2thz*twopi = 1/au2ps
> 2.0d0*sigmai_mode_all_emi(itemp,idope,1:nmodes,ibnd,ik)*ryd2thz*twopi   ! 2*sigmai is in units of [1/au_s]
>                ENDIF
>               ENDIF
542c936
< ! export electron MFP
---
> ! export electron info
544c938
< ! ik (irr), ibnd (red), energy [eV], MFP [nm]
---
> ! ik (irr), ibnd (red), energy [eV], scattering rate[THz], velocity[m/s]
604c998
<               WRITE (9999,'(i12,i5,5es24.15)') ik_ful, ibnd, ekk*ryd2ev, sigmai*ryd2thz*twopi, vkk(1:3)*au2m/au2s ! [eV], [THz], [m/s]
---
>               WRITE (9999,'(i12,i5,5es24.15)') ik_ful, ibnd0, ekk*ryd2ev, sigmai*ryd2thz*twopi, vkk(1:3)*au2m/au2s ! [eV], [THz], [m/s]
818,819c1212,1213
<   USE epwcom,        ONLY : bte, neptemp, nepdope, nqf1, nqf2, nqf3
<   USE elph2,         ONLY : gammai_mode_all, wf_irr, vph_irr
---
>   USE epwcom,        ONLY : bte, neptemp, nepdope, nqf1, nqf2, nqf3, phdrag
>   USE elph2,         ONLY : gammai_mode_all, wf_irr, vph_irr, wf_all
824,825c1218,1221
<   USE io_global,     ONLY : ionode_id
<   USE mp_global,     ONLY : my_pool_id
---
>   USE io_global,     ONLY : ionode_id, stdout, ionode
>   USE mp,            ONLY : mp_barrier, mp_bcast, mp_sum
>   USE mp_global,     ONLY : my_pool_id, nproc_pool, intra_image_comm, &
>                             inter_pool_comm, me_pool, root_pool, intra_pool_comm, npool
830,831c1226,1228
<   INTEGER             :: iq, imode, itemp, idope, iq_ful
<   REAL(KIND=DP)       :: xq_fbz(3), length
---
>   INTEGER             :: iq, iq_irr, imode, itemp, idope, iq_ful, nq_tot
>   REAL(KIND=DP)       :: xq_fbz(3), length, wf(nmodes)
>   
845,846c1242,1243
<            rate_RTA_fmt = 'BTE/'//TRIM(ADJUSTL(txnx))//'/rate_RTA.dat'
<            rate_RTA_3D_fmt = 'BTE/'//TRIM(ADJUSTL(txnx))//'/rate_RTA_3D.dat'
---
>            rate_RTA_fmt = 'BTE/'//TRIM(ADJUSTL(txnx))//'/rate_RTA_phe.dat'
>            rate_RTA_3D_fmt = 'BTE/'//TRIM(ADJUSTL(txnx))//'/rate_RTA_phe_3D.dat'
849,850c1246,1261
<            DO iq = 1, nq_irr
<               WRITE (1111,'(i8,96es14.4)') iq, wf_irr(1:nmodes,iq)*rydcm1, 2.0d0*gammai_mode_all(itemp,idope,1:nmodes,iq)*ryd2thz*twopi            
---
> 
>            IF (phdrag) THEN
>               nq_tot = nq_irr_red
>            ELSE
>               nq_tot = nq_irr
>            ENDIF
>            !
>            DO iq = 1, nq_tot
>               !
>               IF (phdrag) THEN
>                  wf(:) = wf_all(:,iq)
>               ELSE
>                  wf(:) = wf_irr(:,iq)
>               ENDIF
>               !
>               WRITE (1111,'(i8,96es14.4)') iq, wf(1:nmodes)*rydcm1, 2.0d0*gammai_mode_all(itemp,idope,1:nmodes,iq)*ryd2thz*twopi            
855,865c1266,1292
<            OPEN (7777,FILE='BTE/META/irr2ful_q',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='old')
<            OPEN (8888,FILE='BTE/META/xqf_fbz_cart',FORM='unformatted',ACCESS='direct',RECL=3*DP,STATUS='old')
<            OPEN (9999,FILE=rate_RTA_3D_fmt,STATUS='replace')
<            DO iq = 1, nq_irr
<               !
<               READ (7777,REC=iq) iq_ful
<               READ (8888,REC=iq_ful) xq_fbz(1:3)
<               length = SQRT(DOT_PRODUCT(xq_fbz,xq_fbz))
<               !
<               DO imode = 1, nmodes
<                  WRITE (9999,'(i8,f12.6,f11.4,es14.4)') iq, length, wf_irr(imode,iq)*rydcm1, 2.0d0*gammai_mode_all(itemp,idope,imode,iq)*ryd2thz*twopi     
---
>               OPEN (7777,FILE='BTE/META/irr2ful_q',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='old')
>               OPEN (8888,FILE='BTE/META/xqf_fbz_cart',FORM='unformatted',ACCESS='direct',RECL=3*DP,STATUS='old')
>               OPEN (9999,FILE=rate_RTA_3D_fmt,STATUS='replace')
>                  !
>               DO iq = 1, nq_tot
>                  !
>                  IF (phdrag) THEN
>                    iq_irr = rirr2irr_q(iq)
>                    READ (7777,REC=iq_irr) iq_ful
>                  ELSE
>                    READ (7777,REC=iq) iq_ful
>                  ENDIF
>                  !
>                  READ (8888,REC=iq_ful) xq_fbz(1:3)
>                  length = SQRT(DOT_PRODUCT(xq_fbz,xq_fbz))
>                  !
>                  DO imode = 1, nmodes
>                  !
>                  IF (.NOT. phdrag) THEN
>                    WRITE (9999,'(i8,f12.6,f11.4,es14.4)') iq, length, wf_irr(imode,iq)*rydcm1, 2.0d0*gammai_mode_all(itemp,idope,imode,iq)*ryd2thz*twopi 
>                  ELSE
>                    WRITE (9999,'(i8,f12.6,f11.4,es14.4)') iq, length, wf_all(imode,iq)*rydcm1, 2.0d0*gammai_mode_all(itemp,idope,imode,iq)*ryd2thz*twopi
>                  ! [cm-1] [THz]
>                  ENDIF
>                  !    
>                  ENDDO
>                  !            
867,872c1294,1299
<               !            
<            ENDDO
<            CLOSE (7777)
<            CLOSE (8888)
<            CLOSE (9999)
<            !
---
>               CLOSE (7777)
>               CLOSE (8888)
>               CLOSE (9999)
>               !
>               !
> 
877a1305
>      CALL mp_barrier (inter_pool_comm)
889a1318,1320
> ! export el-ph scattering rate, Jan, 2018 
> ! in the format of BTE.qpoints, BTE.v, BTE.w_final, BTE.omega, BTE.cumulative_kappa_scalar
> !
899,900c1330,1333
<   USE io_global,     ONLY : ionode_id
<   USE mp_global,     ONLY : my_pool_id
---
>   USE io_global,     ONLY : ionode_id, stdout, ionode
>   USE mp,            ONLY : mp_barrier, mp_bcast, mp_sum
>   USE mp_global,     ONLY : my_pool_id, nproc_pool, intra_image_comm, &
>                             inter_pool_comm, me_pool, root_pool, intra_pool_comm, npool
905,907c1338,1340
<   INTEGER             :: iq, imode, itemp, idope, i, j, k
<   REAL(KIND=DP)       :: rate_ful(nmodes)
<   CHARACTER(LEN=256)  :: ShengBTE_fmt
---
>   INTEGER             :: iq, iq_ful, imode, itemp, idope, i, j, k
>   REAL(KIND=DP)       :: rate_ful(nmodes), xq_irr(3), wf_weight
>   CHARACTER(LEN=256)  :: ShengBTE_fmt, bte_w_final, bte_v, bte_qpoints
913a1347,1377
>       bte_qpoints = 'BTE/epw-BTE.qpoints'
>       bte_v = 'BTE/epw-BTE.v'
>       OPEN (2345,FILE=bte_v,STATUS='replace') 
>       OPEN (3456,FILE=bte_qpoints,STATUS='replace')   
>       OPEN (3333,FILE='BTE/META/xqf_irr_cryst',FORM='unformatted',ACCESS='direct',RECL=3*DP,STATUS='old')
>       OPEN (1155,FILE='BTE/META/wqf_irr',FORM='unformatted',ACCESS='direct',RECL=DP,STATUS='old')
>       OPEN (7777,FILE='BTE/META/irr2ful_q',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='old')
>      !
>       DO imode = 1, nmodes
>          DO iq = 1, nq_irr     
>             WRITE(2345,'(3e20.10)') vph_irr(:,imode,iq)*(au2m/au2s)/1000.0d0   
>          ENDDO       
>       ENDDO
>      !
>      DO iq = 1, nq_irr     
>       !    
>       READ (7777,REC=iq) iq_ful
>       !
>       READ (3333,REC=iq) xq_irr(1), xq_irr(2), xq_irr(3)
>       READ (1155,REC=iq) wf_weight
>       !
>       WRITE (3456,'(i9,x,i9,x,i9,x,3(e20.10,1x))') iq, iq_ful, NINT(nqf1*nqf2*nqf3*wf_weight), xq_irr(1:3)
>       !
>       !
>      ENDDO
>       CLOSE (7777)
>       CLOSE (2345)
>       CLOSE (3456)
>       CLOSE (3333)
>       CLOSE (1155)
>      !
920a1385
>            bte_w_final = 'BTE/'//TRIM(ADJUSTL(txnx))//'/epw-BTE.w_final'
923a1389
>            !
949a1416,1427
>            OPEN (1234,FILE=bte_w_final,STATUS='replace') 
>            !
>            DO imode = 1, nmodes
>              DO iq = 1, nq_irr
>              !
>               WRITE(1234,'(2e20.10)') wf_irr(imode,iq)*ryd2thz*twopi, 2.0d0*ABS(gammai_mode_all(itemp,idope,imode,iq))*ryd2thz*twopi       
>              ENDDO
>              !
>            ENDDO
>            !
>            CLOSE (1234)
>            !
954a1433
>      CALL mp_barrier (inter_pool_comm)
1163,1164c1642,1643
<   USE epwcom,        ONLY : nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, epdim, neptemp, nepdope, &
<                             nbndsub, eptemp, efermi_read, fsthick, fermi_energy, epdope, egap_rbm, mixing, &
---
>   USE epwcom,        ONLY : nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, epdim, phdrag, &
>                             nbndsub, eptemp, efermi_read, fsthick, epthick, fermi_energy, epdope, egap_rbm, mixing, &
1166c1645
<                             elop, screen_polar, eimp_ls_mode, eph_interp
---
>                             elop, screen_polar
1178c1657
<   REAL(KIND=DP), INTENT(IN) :: transpt(3,3,7), time
---
>   REAL(KIND=DP), INTENT(IN) :: transpt(3,3,24), time
1183,1184c1662
<   REAL(KIND=DP)             :: ef0, doping, temp, mob0, cod0, seb0, etc0, pf0, &
<                                pft0
---
>   REAL(KIND=DP)             :: ef0, doping, temp
1256a1735
>         WRITE (100000,'(7x,a,f10.4,a)')             'epthick     = ', epthick*ryd2ev, ' [eV]'
1275,1277d1753
<         WRITE (100000,'(7x,a,2x,i6,a)')             'e-imp-ls mode    = ', eimp_ls_mode
<         WRITE (100000,'(7x,a,2x,i6,a)')             '    (0: both long and short range; 1: only long range; '
<         WRITE (100000,'(7x,a,2x,i6,a)')             '     2: only short range;          3: none )'
1312c1788,1796
<         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(3,1,1), transpt(3,2,1), transpt(3,3,1)  
---
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(3,1,1), transpt(3,2,1), transpt(3,3,1) 
>         WRITE (100000,'(7x,a)')                     '-------------------------------------------------------'
>         WRITE (100000,'(7x,a,3es16.6)')             'MOB_e |', transpt(1,1,16), transpt(1,2,16), transpt(1,3,16)  
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(2,1,16), transpt(2,2,16), transpt(2,3,16)  
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(3,1,16), transpt(3,2,16), transpt(3,3,16)  
>         WRITE (100000,'(7x,a)')                     '-------------------------------------------------------'
>         WRITE (100000,'(7x,a,3es16.6)')             'MOB_h |', transpt(1,1,17), transpt(1,2,17), transpt(1,3,17)  
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(2,1,17), transpt(2,2,17), transpt(2,3,17)  
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(3,1,17), transpt(3,2,17), transpt(3,3,17)   
1317a1802,1809
>         WRITE (100000,'(7x,a,3es16.6)')             'COD_e |', transpt(1,1,18), transpt(1,2,18), transpt(1,3,18)  
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(2,1,18), transpt(2,2,18), transpt(2,3,18)  
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(3,1,18), transpt(3,2,18), transpt(3,3,18) 
>         WRITE (100000,'(7x,a)')                     '      -------------------------------------------------'
>         WRITE (100000,'(7x,a,3es16.6)')             'COD_h |', transpt(1,1,19), transpt(1,2,19), transpt(1,3,19)  
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(2,1,19), transpt(2,2,19), transpt(2,3,19)  
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(3,1,19), transpt(3,2,19), transpt(3,3,19) 
>         WRITE (100000,'(7x,a)')                     '      -------------------------------------------------'
1325a1818,1825
>         WRITE (100000,'(7x,a,3es16.6)')             'SEB_e |', transpt(1,1,20), transpt(1,2,20), transpt(1,3,20)  
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(2,1,20), transpt(2,2,20), transpt(2,3,20)  
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(3,1,20), transpt(3,2,20), transpt(3,3,20) 
>         WRITE (100000,'(7x,a)')                     '      -------------------------------------------------'
>         WRITE (100000,'(7x,a,3es16.6)')             'SEB_h |', transpt(1,1,21), transpt(1,2,21), transpt(1,3,21)  
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(2,1,21), transpt(2,2,21), transpt(2,3,21)  
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(3,1,21), transpt(3,2,21), transpt(3,3,21) 
>         WRITE (100000,'(7x,a)')                     '      -------------------------------------------------'
1336a1837,1864
>         WRITE (100000,'(7x,a)')                     '      -------------------------------------------------'
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '  LTC |', transpt(1,1,8), transpt(1,2,8), transpt(1,3,8)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(2,1,8), transpt(2,2,8), transpt(2,3,8)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(3,1,8), transpt(3,2,8), transpt(3,3,8) 
>         IF (phdrag) WRITE (100000,'(7x,a)')         '      -------------------------------------------------'
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') ' SLTC |', transpt(1,1,9), transpt(1,2,9), transpt(1,3,9)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(2,1,9), transpt(2,2,9), transpt(2,3,9)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(3,1,9), transpt(3,2,9), transpt(3,3,9)
>         WRITE (100000,'(7x,a)')                     '      -------------------------------------------------'
>         WRITE (100000,'(7x,a,3es16.6)')             '  BTC |', transpt(1,1,10), transpt(1,2,10), transpt(1,3,10)
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(2,1,10), transpt(2,2,10), transpt(2,3,10)
>         WRITE (100000,'(7x,a,3es16.6)')             '      |', transpt(3,1,10), transpt(3,2,10), transpt(3,3,10) 
>         IF (phdrag) WRITE (100000,'(7x,a)')         '      -------------------------------------------------'
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '  SPD |', transpt(1,1,11), transpt(1,2,11), transpt(1,3,11)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(2,1,11), transpt(2,2,11), transpt(2,3,11)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(3,1,11), transpt(3,2,11), transpt(3,3,11) 
>         IF (phdrag) WRITE (100000,'(7x,a/)')        '      -------------------------------------------------' 
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '  SPK |', transpt(1,1,12), transpt(1,2,12), transpt(1,3,12)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(2,1,12), transpt(2,2,12), transpt(2,3,12)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(3,1,12), transpt(3,2,12), transpt(3,3,12) 
>         IF (phdrag) WRITE (100000,'(7x,a/)')        '      -------------------------------------------------'
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '  SPX |', transpt(1,1,13), transpt(1,2,13), transpt(1,3,13)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(2,1,13), transpt(2,2,13), transpt(2,3,13)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(3,1,13), transpt(3,2,13), transpt(3,3,13) 
>         IF (phdrag) WRITE (100000,'(7x,a/)')        '      -------------------------------------------------' 
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '  SPL |', transpt(1,1,14), transpt(1,2,14), transpt(1,3,14)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(2,1,14), transpt(2,2,14), transpt(2,3,14)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(3,1,14), transpt(3,2,14), transpt(3,3,14) 
1338,1344c1866,1884
<         IF (converge) WRITE (100000,'(7x,a)')       'MOB = Electron mobility [cm^2/V/s]'
<         IF (converge) WRITE (100000,'(7x,a)')       'COD = Electron conductivity [1/Ohm/m]'
<         IF (converge) WRITE (100000,'(7x,a)')       'ETC = Electron thermal conductivity [W/m/K]'
<         IF (converge) WRITE (100000,'(7x,a)')       'SEB = Seebeck coefficient [uV/K]'
<         IF (converge) WRITE (100000,'(7x,a)')       'PEL = Peltier coefficient [uV]'
<         IF (converge) WRITE (100000,'(7x,a)')       'POF = Power factor [uW/cm/K^2]'
<         IF (converge) WRITE (100000,'(7x,a/)')      'LOZ = Lorentz number [W*Ohm/K^2]'
---
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '  SPG |', transpt(1,1,15), transpt(1,2,15), transpt(1,3,15)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(2,1,15), transpt(2,2,15), transpt(2,3,15)  
>         IF (phdrag) WRITE (100000,'(7x,a,3es16.6)') '      |', transpt(3,1,15), transpt(3,2,15), transpt(3,3,15) 
>         IF (converge) WRITE (100000,'(7x,a/)')      '-------------------------------------------------------' 
>         IF (converge) WRITE (100000,'(7x,a)')               'MOB = Electron mobility [cm^2/V/s]'
>         IF (converge) WRITE (100000,'(7x,a)')               'COD = Electron conductivity [1/Ohm/m]'
>         IF (converge) WRITE (100000,'(7x,a)')               'ETC = Electron thermal conductivity [W/m/K]'
>         IF (converge) WRITE (100000,'(7x,a)')               'SEB = Seebeck coefficient [uV/K]'
>         IF (converge) WRITE (100000,'(7x,a)')               'PEL = Peltier coefficient [uV]'
>         IF (converge) WRITE (100000,'(7x,a)')               'POF = Power factor [uW/cm/K^2]'
>         IF (converge) WRITE (100000,'(7x,a)')               'LOZ = Lorentz number [W*Ohm/K^2]'
>         IF (converge .AND. phdrag) WRITE (100000,'(7x,a)')  'LTC = Lattice thermal conductivity [W/m/K]'
>         IF (converge .AND. phdrag) WRITE (100000,'(7x,a)')  'SLTC = Lattice thermal conductivity using ph lifetime from ShengBTE [W/m/K]'
>         IF (converge) WRITE (100000,'(7x,a)')               'BTC = Bipolar thermal conductivity [W/m/K]'
>         IF (converge .AND. phdrag) WRITE (100000,'(7x,a/)') 'SPD = Phonon-drag Seebeck coefficient [uV/K]'
>         IF (converge .AND. phdrag) WRITE (100000,'(7x,a/)') 'SPK ~ SPD but sum_k(sum_q) [uV/K]'
>         IF (converge .AND. phdrag) WRITE (100000,'(7x,a/)') 'SPX ~ SPD but sum_k(sum_q) from near X valley [uV/K]'
>         IF (converge .AND. phdrag) WRITE (100000,'(7x,a/)') 'SPL ~ SPD but sum_k(sum_q) from L valley [uV/K]'
>         IF (converge .AND. phdrag) WRITE (100000,'(7x,a/)') 'SPG ~ SPD but sum_k(sum_q) from Gamma walley [uV/K]'
1352,1427d1891
< 
<      close(100000)
< 
<      ! ============================== write a more compact version
<      ! ====================== JW
<      !
<      if (iter .eq. 0) then
<         OPEN (100000,FILE='bte.out',POSITION='append')
<         if ((itemp == 1) .and. (idope == 1)) then
<            WRITE (100000,'(7x,a)')                     ''
<            WRITE (100000,'(7x,a)')                     'MIT NANOENGINEERING GROUP'
<            WRITE (100000,'(7x,a)')                     'T.H. LIU and J. ZHOU'
<            WRITE (100000,'(7x,a)')                     'ELECTRON-PHONON BOLTZMANN TRANSPORT EQUATION SOLVER (v5.0)     '
<            WRITE (100000,'(7x,a)')                     ''                      
<            WRITE (100000,'(7x,a)')                     ''
< 
<            WRITE (100000,'(7x,a,i4,a,i4,a,i4,a,i12,a)') 'k-mesh: ', nkf1, ' * ', nkf2, ' * ', nkf3, '  = ', nkf1*nkf2*nkf3, ' points'
<            WRITE (100000,'(7x,a,i4,a,i4,a,i4,a,i12,a)') 'q-mesh: ', nqf1, ' * ', nqf2, ' * ', nqf3, '  = ', nqf1*nqf2*nqf3, ' points'
<            WRITE (100000,'(a)') ''
<            WRITE (100000,'(7x,a,i5)')                  'Dimension   = ', epdim
<            WRITE (100000,'(7x,a,i5,a,i3)')             'Band (e)    = ', ibndmin, '  to', ibndmax
<            WRITE (100000,'(7x,a,i5)')                  'Mode (ph)   = ', nmodes
<            WRITE (100000,'(7x,a,f10.4,a,f10.4,a)')     'Bandgap     = ', vbnd_emax*ryd2ev, '  to', cbnd_emin*ryd2ev, ' [eV]'
<            WRITE (100000,'(7x,a,f10.4,a,f10.4,a)')     'fsthick     = ', vfsthick*ryd2ev, '  / ', cfsthick*ryd2ev, ' [eV]'
<            WRITE (100000,'(a)') ''
<            WRITE (100000,'(7x,a,es14.4,a,f7.1,a)')     'n_intr      = ', n_intr(1,1), ' [cm^-3] at T =', temp, ' [K]'
<            WRITE (100000,'(a)') ''
<            WRITE (100000,'(7x,a,a5)')                  'Smearing                 =    ', smearing
<            WRITE (100000,'(7x,a,f8.4)')                'Mixing ratio             = ', mixing
<            WRITE (100000,'(7x,a,l8)')                  'GW band structure        = ', eig_read
<            WRITE (100000,'(7x,a,f8.4,a)')              'RBM bandgap              = ', egap_rbm, ' [eV]'
<            WRITE (100000,'(7x,a,l8)')                  'Spin-orbital interaction = ', lspinorb
<            WRITE (100000,'(a)') ''
<            WRITE (100000,'(7x,a,l8)')                  'Polar interaction        = ', lpolar
<            WRITE (100000,'(7x,a,l8)')                  'Polar e-LO phonon considered?  = ', elop
<            WRITE (100000,'(7x,a,l8)')                  'Screening of polar scattering considered?  = ', screen_polar
<            WRITE (100000,'(7x,a)') ''
<            WRITE (100000,'(7x,a,l8)')                  'Use direct interpolation for ep-matrix?   : ', eph_interp
<            WRITE (100000,'(7x,a,l8)')                  'ASR to ep-matrix (eph)   = ', asr_eph
<            WRITE (100000,'(a)') ''
<            WRITE (100000,'(7x,a,a5/)')                 'n/p-type semiconductor   =        ', nptype
<            WRITE (100000,'(7x,a,2x,i6,a)')             'e-imp scattering mode    = ', eimp_mode
<            WRITE (100000,'(7x,a,2x,i6,a)')             '    (0: none; 1: Brooks-Herring relaxation time; 2: B-H momentum relaxation time)'
<            WRITE (100000,'(7x,a,2x,i6,a)')             'e-imp-ls mode    = ', eimp_ls_mode
<            WRITE (100000,'(7x,a,2x,i6,a)')             '    (0: both long and short range; 1: only long range; '
<            WRITE (100000,'(7x,a,2x,i6,a)')             '     2: only short range;          3: none )'
< 
<            WRITE (100000,'(7x,a)') ''
<            write (100000,'()')
<            WRITE (100000,'(7x,a)') '========================================================================================================================='
<            WRITE (100000,'(7x,a)')                     '   T(K)  Fermi level Doping(cm^-3)  n_carr     n_charge    Mobility      cond      Seebeck        PF         PF*T    thermal cond'
<         endif
< 
<         mob0 = (transpt(1,1,1)+transpt(2,2,1)+transpt(3,3,1))/3.d0
<         cod0 = (transpt(1,1,2)+transpt(2,2,2)+transpt(3,3,2))/3.d0
<         etc0 = (transpt(1,1,3)+transpt(2,2,3)+transpt(3,3,3))/3.d0
<         seb0 = (transpt(1,1,4)+transpt(2,2,4)+transpt(3,3,4))/3.d0
<         pf0 = cod0 * ((seb0/1d6)**2.d0) * 1d4
<         pft0 = (pf0 / 1d4) * (eptemp(itemp) / kB)
<         WRITE (100000,'(7x,f7.1,2x,f10.4,1x,15(2x,es10.2))') eptemp(itemp)/kB, ef_epw(itemp,idope)*ryd2ev, epdope(idope), &
<                                                     n_elec(itemp,idope)+n_hole(itemp,idope), n_hole(itemp,idope)-n_elec(itemp,idope), &
<                                                     mob0, cod0, seb0, pf0, pft0, etc0
< 
<         if ((itemp == neptemp) .and. (idope == nepdope)) then
<            WRITE (100000,'(7x,a)') '-------------------------------------------------------'
<            WRITE (100000,'(7x,a)')                        ''
<            WRITE (100000,'(7x,a)')                        'MOB = Electron mobility [cm^2/V/s]'
<            WRITE (100000,'(7x,a)')                        'COD = Electron conductivity [1/Ohm/m]'
<            WRITE (100000,'(7x,a)')                        'ETC = Electron thermal conductivity [W/m/K]'
<            WRITE (100000,'(7x,a)')                        'SEB = Seebeck coefficient [uV/K]'
<            WRITE (100000,'(7x,a)')                        'PEL = Peltier coefficient [uV]'
<            WRITE (100000,'(7x,a)')                        ''
<         endif
<         !
<         close(100000)
<      endif
Only in ./: bte_export.o
diff ./bte.f90 ../../epw-qian/src/bte.f90
68a69
>           rful2rirr_q(:)       ,& ! red-ful-BZ => red-irr-BZ
88a90,107
>   !========== all-mesh ==========
>   INTEGER                    :: &
>           nqf1_phd             ,&
>           nqf2_phd             ,&
>           nqf3_phd             ,&
>           nq_ful_phd           ,&
>           nmodes_phd
>   REAL(KIND=DP)              :: &
>           eptemp_phd
>   !
>   REAL(KIND=DP), ALLOCATABLE :: &
>            N_q_ful(:,:,:,:)      ,&
>        int_N_q_ful(:,:,:,:)      ,&
>           dN_q_ful(:,:,:,:)      ,&
>           ph_rate_ful(:,:,:)     ,&
>           alelrate(:,:)         ,&  ! read in electron (eV) and average alloy-electron scatteting rate (THz)    
>           tau0_q_ful(:,:,:)
>   !
236a256,313
>   FUNCTION FindDet (matrix, n)
>   !----------------------------------------------------------------------------
>     !Function to find the determinant of a square matrix
>     !Author : Louisda16th a.k.a Ashwith J. Rego
>     !Description: The subroutine is based on two key points:
>     !1] A determinant is unaltered when row operations are performed: Hence, using this principle,
>     !row operations (column operations would work as well) are used
>     !to convert the matrix into upper traingular form
>     !2]The determinant of a triangular matrix is obtained by finding the product of the diagonal elements
>     !
>     USE kinds,        ONLY : DP
>     !
>     IMPLICIT NONE
>     REAL(KIND=DP), DIMENSION(n,n) :: matrix
>     INTEGER, INTENT(IN)           :: n
>     REAL(KIND=DP)                 :: FindDet, m, temp
>     INTEGER                       :: i, j, k, l
>     LOGICAL                       :: DetExists = .TRUE.
>     !
>     l = 1
>     !Convert to upper triangular form
>     DO k = 1, n-1
>         IF (matrix(k,k) == 0.0d0) THEN
>             DetExists = .FALSE.
>             DO i = k+1, n
>                 IF (matrix(i,k) /= 0.0d0) THEN
>                     DO j = 1, n
>                         temp = matrix(i,j)
>                         matrix(i,j)= matrix(k,j)
>                         matrix(k,j) = temp
>                     END DO
>                     DetExists = .TRUE.
>                     l=-l
>                     EXIT
>                 ENDIF
>             END DO
>             IF (DetExists .EQV. .FALSE.) THEN
>                 FindDet = 0.0d0
>                 RETURN
>             END IF
>         ENDIF
>         DO j = k+1, n
>             m = matrix(j,k)/matrix(k,k)
>             DO i = k+1, n
>                 matrix(j,i) = matrix(j,i) - m*matrix(k,i)
>             END DO
>         END DO
>     END DO
>     !
>     !Calculate determinant by finding product of diagonal elements
>     FindDet = l
>     DO i = 1, n
>         FindDet = FindDet * matrix(i,i)
>     END DO
>     !
>   END FUNCTION FindDet
> 
> !----------------------------------------------------------------------------
Only in ./: bte_func.mod
diff ./bte_io.f90 ../../epw-qian/src/bte_io.f90
7c7
<   USE epwcom,    ONLY : bte, nkf1, nkf2, nkf3, nqf1, nqf2, nqf3
---
>   USE epwcom,    ONLY : bte, nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, phdrag
82a83,98
>   IF (phdrag) THEN
>      !
>      IF (ALLOCATED (xqf_irr)) DEALLOCATE (xqf_irr)
>      ALLOCATE (xqf_irr(3,nq_irr))
>      xqf_irr = 0.0d0
>      !
>      IF (ALLOCATED (irr2ful_q)) DEALLOCATE (irr2ful_q)
>      ALLOCATE (irr2ful_q(nk_irr))
>      irr2ful_q = 0
>      !
>      IF (ALLOCATED (xkf_ful)) DEALLOCATE (xkf_ful)
>      ALLOCATE (xkf_ful(3,nk_ful))
>      xkf_ful = 0.0d0
>      !
>   ENDIF
>   !
88a105,108
>      IF (ALLOCATED (xkf_ful)) DEALLOCATE (xkf_ful)
>      ALLOCATE (xkf_ful(3,nk_ful))
>      xkf_ful = 0.0d0
>      !
128a149,170
>      IF (phdrag) THEN
>         !
>         OPEN (9999,FILE='BTE/META/xqf_irr_cryst',FORM='unformatted',ACCESS='direct',RECL=3*DP,STATUS='old')
>         DO iq = 1, nq_irr
>            READ (9999,REC=iq) xqf_irr(1:3,iq)
>         ENDDO
>         CLOSE (9999)
>         !
>         OPEN (9999,FILE='BTE/META/irr2ful_q',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='old')
>         DO iq = 1, nq_irr
>            READ (9999,REC=iq) irr2ful_q(iq)
>         ENDDO
>         CLOSE (9999)
>         !
>         OPEN (9999,FILE='BTE/META/xkf_ful_cryst',FORM='unformatted',ACCESS='direct',RECL=3*DP,STATUS='old')
>         DO ik = 1, nk_ful
>            READ (9999,REC=ik) xkf_ful(1:3,ik)
>         ENDDO
>         CLOSE (9999)
>         !
>      ENDIF
>      !
129a172
>         !
134a178,184
>         !
>         OPEN (9999,FILE='BTE/META/xkf_ful_cryst',FORM='unformatted',ACCESS='direct',RECL=3*DP,STATUS='old')
>         DO ik = 1, nk_ful
>            READ (9999,REC=ik) xkf_ful(1:3,ik)
>         ENDDO
>         CLOSE (9999)
>         !
144a195,197
>   IF (phdrag) CALL mp_bcast (xqf_irr,ionode_id,inter_pool_comm)
>   IF (phdrag) CALL mp_bcast (irr2ful_q,ionode_id,inter_pool_comm)
>   IF (phdrag) CALL mp_bcast (xkf_ful,ionode_id,inter_pool_comm)
145a199
>   IF (bte .EQ. 2) CALL mp_bcast (xkf_ful,ionode_id,inter_pool_comm)
160c214
<   USE epwcom,    ONLY : nkf1, nkf2, nkf3, nqf1, nqf2, nqf3
---
>   USE epwcom,    ONLY : nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, phdrag
175c229
<   IF (ALLOCATED (ful2irr)) DEALLOCATE (ful2irr) ! save memory
---
>   IF (ALLOCATED (ful2irr) .AND. .NOT. phdrag) DEALLOCATE (ful2irr) ! save memory
265,266c319,320
<   USE epwcom,    ONLY : nbndsub, bte, nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, neptemp, nepdope, &
<                         efermi_read, fermi_energy, eimp_mode
---
>   USE epwcom,    ONLY : nbndsub, bte, nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, neptemp, nepdope, efermi_read, &
>                         fermi_energy, phdrag, eimp_mode, alloy_pot
269,270c323,326
<                         n_hole, n_elec, n_intr, cbnd_emin, vbnd_emax, cfsthick, vfsthick, &
<                         sigmai_mode_all_ela_intra, sigmai_mode_all_ela_inter
---
>                         n_hole, n_elec, n_intr, cbnd_emin, vbnd_emax, cfsthick, vfsthick, wf_irr, &
>                         vph_irr, wf_all, vph_all, sigmai_mode_all_ela_intra, sigmai_mode_all_ela_inter, &
>                         sigmai_mode_all_alloy_intra, sigmai_mode_all_alloy_inter, &
>                         sigmai_mode_all_intra, sigmai_mode_all_inter
299c355
<         OPEN (99999,FILE='BTE/META/sigmai_mode',FORM='unformatted',ACCESS='direct',RECL=2*DP,STATUS='replace')
---
>         OPEN (99999,FILE='BTE/META/sigmai_mode',FORM='unformatted',ACCESS='direct',RECL=4*DP,STATUS='replace')
301a358,359
>            IF (alloy_pot) &
>            OPEN (77777,FILE='BTE/META/sigmai_alel_mode',FORM='unformatted',ACCESS='direct',RECL=DP,STATUS='replace')
308c366,367
<                              sigmai_mode_all_abs(itemp,idope,imode,ibnd,ik), sigmai_mode_all_emi(itemp,idope,imode,ibnd,ik)
---
>                              sigmai_mode_all_abs(itemp,idope,imode,ibnd,ik), sigmai_mode_all_emi(itemp,idope,imode,ibnd,ik), &
> sigmai_mode_all_intra(itemp,idope,imode,ibnd,ik), sigmai_mode_all_inter(itemp,idope,imode,ibnd,ik)
315a375,378
>                           IF (alloy_pot) THEN
>                           WRITE (77777,REC=irec_sigmai)   sigmai_mode_all_alloy_intra(itemp,idope,ibnd,ik)
>                           WRITE (77777,REC=irec_sigmai+1) sigmai_mode_all_alloy_inter(itemp,idope,ibnd,ik)
>                           ENDIF
324a388
>         IF (alloy_pot)  close (77777)
330c394
<         OPEN (99999,FILE='BTE/META/electron_irr',FORM='unformatted',ACCESS='direct',RECL=4*DP,STATUS='replace')
---
>         OPEN (99999,FILE='BTE/META/electron_irr_red',FORM='unformatted',ACCESS='direct',RECL=4*DP,STATUS='replace')
340c404
<      IF (bte .EQ. 0 .OR. bte .EQ. 1 .OR. bte .EQ. 3 .OR. bte .EQ. 18) THEN
---
>      IF ((bte .EQ. 0 .OR. bte .EQ. 1 .OR. bte .EQ. 3 .OR. bte .EQ. 18) .AND. (.NOT. phdrag)) THEN
345,346c409,421
<               ! ERROR, not consider temperature and carrier concentration
<               WRITE (99999,REC=(iq-1)*nmodes+imode) wf_ful(imode,1,1,iq), vph_ful(1:3,imode,iq)
---
>               WRITE (99999,REC=(iq-1)*nmodes+imode) wf_ful(imode,iq), vph_ful(1:3,imode,iq)
>            ENDDO
>         ENDDO
>         CLOSE (99999)
>         !
>      ENDIF
>      !
>      IF (phdrag) THEN
>         !
>         OPEN (99999,FILE='BTE/META/phonon_irr_red',FORM='unformatted',ACCESS='direct',RECL=4*DP,STATUS='replace')
>         DO iq = 1, nq_irr_red
>            DO imode = 1, nmodes
>               WRITE (99999,REC=(iq-1)*nmodes+imode) wf_all(imode,iq), vph_all(1:3,imode,iq)
367a443,444
>   IF ( ALLOCATED (sigmai_mode_all_inter) ) DEALLOCATE (sigmai_mode_all_inter) 
>   IF ( ALLOCATED (sigmai_mode_all_intra) ) DEALLOCATE (sigmai_mode_all_intra) 
370a448,449
>      IF ( ALLOCATED (sigmai_mode_all_alloy_inter) ) DEALLOCATE (sigmai_mode_all_alloy_inter)
>      IF ( ALLOCATED (sigmai_mode_all_alloy_intra) ) DEALLOCATE (sigmai_mode_all_alloy_intra)
375c454,458
<   IF ( ALLOCATED (vph_ful) )             DEALLOCATE (vph_ful)  
---
>   IF ( ALLOCATED (vph_ful) )             DEALLOCATE (vph_ful) 
>   IF ( ALLOCATED (wf_all) )              DEALLOCATE (wf_all)  
>   IF ( ALLOCATED (vph_all) )             DEALLOCATE (vph_all) 
>   IF ( ALLOCATED (wf_irr) )              DEALLOCATE (wf_irr)  
>   IF ( ALLOCATED (vph_irr) )             DEALLOCATE (vph_irr) 
401c484
<                             efermi_read, fermi_energy, eimp_mode
---
>                             efermi_read, fermi_energy, phdrag, eimp_mode, alloy_pot
404,405c487,490
<                             n_hole, n_elec, n_intr, cbnd_emin, vbnd_emax, cfsthick, vfsthick, &
<                             sigmai_mode_all_ela_intra, sigmai_mode_all_ela_inter
---
>                             n_hole, n_elec, n_intr, cbnd_emin, vbnd_emax, cfsthick, vfsthick, wf_irr, &
>                             vph_irr, wf_all, vph_all, sigmai_mode_all_ela_intra, sigmai_mode_all_ela_inter, &
>                             sigmai_mode_all_alloy_inter, sigmai_mode_all_alloy_intra, &
>                             sigmai_mode_all_inter, sigmai_mode_all_intra
458,461c543,550
<      ALLOCATE (sigmai_mode_all_abs(neptemp,nepdope,nmodes,nbnd_red,nk_irr_red)) 
<      ALLOCATE (sigmai_mode_all_emi(neptemp,nepdope,nmodes,nbnd_red,nk_irr_red)) 
<      sigmai_mode_all_abs = 0.0d0
<      sigmai_mode_all_emi = 0.0d0
---
>   ALLOCATE (sigmai_mode_all_abs(neptemp,nepdope,nmodes,nbnd_red,nk_irr_red))
>   ALLOCATE (sigmai_mode_all_emi(neptemp,nepdope,nmodes,nbnd_red,nk_irr_red))
>   ALLOCATE (sigmai_mode_all_inter(neptemp,nepdope,nmodes,nbnd_red,nk_irr_red))
>   ALLOCATE (sigmai_mode_all_intra(neptemp,nepdope,nmodes,nbnd_red,nk_irr_red))
>   sigmai_mode_all_abs = 0.0d0
>   sigmai_mode_all_emi = 0.0d0
>   sigmai_mode_all_inter = 0.0d0
>   sigmai_mode_all_intra = 0.0d0
463,468c552,563
<      if (eimp_mode > 0) then
<         ALLOCATE (sigmai_mode_all_ela_intra(neptemp,nepdope,nbnd_red,nk_irr_red))
<         ALLOCATE (sigmai_mode_all_ela_inter(neptemp,nepdope,nbnd_red,nk_irr_red))
<         sigmai_mode_all_ela_intra = 0.0d0
<         sigmai_mode_all_ela_inter = 0.0d0
<      endif
---
>   if (eimp_mode > 0) then
>      ALLOCATE (sigmai_mode_all_ela_intra(neptemp,nepdope,nbnd_red,nk_irr_red))
>      ALLOCATE (sigmai_mode_all_ela_inter(neptemp,nepdope,nbnd_red,nk_irr_red))
>      sigmai_mode_all_ela_intra = 0.0d0
>      sigmai_mode_all_ela_inter = 0.0d0
>      IF (alloy_pot) THEN
>       ALLOCATE (sigmai_mode_all_alloy_intra(neptemp,nepdope,nbnd_red,nk_irr_red))
>       ALLOCATE (sigmai_mode_all_alloy_inter(neptemp,nepdope,nbnd_red,nk_irr_red))
>       sigmai_mode_all_alloy_inter = 0.0d0
>       sigmai_mode_all_alloy_intra = 0.0d0
>      ENDIF
>   endif
472c567
<         OPEN (99999,FILE='BTE/META/sigmai_mode',FORM='unformatted',ACCESS='direct',RECL=2*DP,STATUS='old')
---
>         OPEN (99999,FILE='BTE/META/sigmai_mode',FORM='unformatted',ACCESS='direct',RECL=4*DP,STATUS='old')
475a571,572
>            IF (alloy_pot) &
>             OPEN (77777,FILE='BTE/META/sigmai_alel_mode',FORM='unformatted',ACCESS='direct',RECL=DP,STATUS='old')
484c581,582
<                             sigmai_mode_all_abs(itemp,idope,imode,ibnd,ik), sigmai_mode_all_emi(itemp,idope,imode,ibnd,ik)
---
>                             sigmai_mode_all_abs(itemp,idope,imode,ibnd,ik), sigmai_mode_all_emi(itemp,idope,imode,ibnd,ik), &
> sigmai_mode_all_intra(itemp,idope,imode,ibnd,ik), sigmai_mode_all_inter(itemp,idope,imode,ibnd,ik)
493a592,597
>                        !
>                        IF (alloy_pot) THEN
>                          READ (77777,REC=irec_sigmai)   sigmai_mode_all_alloy_intra(itemp,idope,ibnd,ik)
>                          READ (77777,REC=irec_sigmai+1) sigmai_mode_all_alloy_inter(itemp,idope,ibnd,ik)
>                        ENDIF
>                        !
500a605
>         IF (alloy_pot) CLOSE(77777)
506a612,613
>      CALL mp_bcast (sigmai_mode_all_inter,ionode_id,inter_pool_comm)
>      CALL mp_bcast (sigmai_mode_all_intra,ionode_id,inter_pool_comm)
509a617,618
>         IF (alloy_pot)  CALL mp_bcast (sigmai_mode_all_alloy_intra,ionode_id,inter_pool_comm)
>         IF (alloy_pot)  CALL mp_bcast (sigmai_mode_all_alloy_inter,ionode_id,inter_pool_comm)
527c636
<         OPEN (99999,FILE='BTE/META/electron_irr',FORM='unformatted',ACCESS='direct',RECL=4*DP,STATUS='old')
---
>         OPEN (99999,FILE='BTE/META/electron_irr_red',FORM='unformatted',ACCESS='direct',RECL=4*DP,STATUS='old')
569c678
<   IF (bte .EQ. 0 .OR. bte .EQ. 1 .OR. bte .EQ. 10 .OR. bte .EQ. 3 .OR. bte .EQ. 30) THEN
---
>   IF ((bte .EQ. 0 .OR. bte .EQ. 1 .OR. bte .EQ. 10 .OR. bte .EQ. 3 .OR. bte .EQ. 30) .AND. (.NOT. phdrag)) THEN
571c680
<      ALLOCATE (wf_ful(nmodes,1,1,nq_ful))  
---
>      ALLOCATE (wf_ful(nmodes,nq_ful))  
581,582c690
<               ! ERROR, not consider temperature and carrier concentration
<               READ (99999,REC=(iq-1)*nmodes+imode) wf_ful(imode,1,1,iq), vph_ful(1:3,imode,iq)
---
>               READ (99999,REC=(iq-1)*nmodes+imode) wf_ful(imode,iq), vph_ful(1:3,imode,iq)
596a705,732
>   ! phonon properties
>   IF (phdrag) THEN
>      !
>      ALLOCATE (wf_all(nmodes,nq_irr_red))  
>      ALLOCATE (vph_all(3,nmodes,nq_irr_red))  
>      wf_all  = 0.0d0
>      vph_all = 0.0d0
>      !
>      IF (my_pool_id .EQ. ionode_id) THEN
>         !
>         OPEN (99999,FILE='BTE/META/phonon_irr_red',FORM='unformatted',ACCESS='direct',RECL=4*DP,STATUS='old')
>         DO iq = 1, nq_irr_red
>            DO imode = 1, nmodes
>               READ (99999,REC=(iq-1)*nmodes+imode) wf_all(imode,iq), vph_all(1:3,imode,iq)
>            ENDDO
>         ENDDO
>         CLOSE (99999)
>         !
>      ENDIF 
>      !
> #ifdef __PARA
>      CALL mp_bcast (wf_all,ionode_id,inter_pool_comm)
>      CALL mp_bcast (vph_all,ionode_id,inter_pool_comm)
> #ENDIF
>      !
>   ENDIF
>   !
>   !
642c778
<         OPEN (99999,FILE='BTE/EPCHECK/electron_irr.dat',STATUS='replace')
---
>         OPEN (99999,FILE='BTE/EPCHECK/electron_irr_red.dat',STATUS='replace')
655,656c791,801
<               ! ERROR, not consider temperature and carrier concentration
<               WRITE (99999,'(i12,i5,f15.4,3f17.4)') iq, imode, wf_ful(imode,1,1,iq)*rydcm1, vph_ful(1:3,imode,iq)*(au2m/au2s)
---
>               WRITE (99999,'(i12,i5,f15.4,3f17.4)') iq, imode, wf_ful(imode,iq)*rydcm1, vph_ful(1:3,imode,iq)*(au2m/au2s)
>            ENDDO
>         ENDDO
>         CLOSE (99999)
>      ENDIF
>      !
>      IF (ALLOCATED(wf_all) .EQ. .TRUE. .AND. ALLOCATED(vph_all) .EQ. .TRUE.) THEN
>         OPEN (99999,FILE='BTE/EPCHECK/phonon_irr_red.dat',STATUS='replace')
>         DO iq = 1, nq_irr_red
>            DO imode = 1, nmodes  
>               WRITE (99999,'(i12,i5,f15.4,3f17.4)') iq, imode, wf_all(imode,iq)*rydcm1, vph_all(1:3,imode,iq)*(au2m/au2s)
711,713c856,858
<   OPEN (99999,FILE=file_ufmt,FORM='unformatted',ACCESS='direct',RECL=4+nq_ful*(4+DP),STATUS='old')
<   READ (99999,REC=1) nscat, iq_ind(1:nscat), sigmai(1:nscat)
<   CLOSE (99999)
---
>   OPEN (74639,FILE=file_ufmt,FORM='unformatted',ACCESS='direct',RECL=4+nq_ful*(4+DP),STATUS='old')
>   READ (74639,REC=1) nscat, iq_ind(1:nscat), sigmai(1:nscat)
>   CLOSE (74639)
718a864,902
> !-------------------------------------------------------------------------------
> SUBROUTINE gammai_load (iq_irr, ibnd, jbnd, imode, nscat, ik_ind, gammai, itemp, idope)
> !-------------------------------------------------------------------------------
> !
> #INCLUDE "f_defs.h"
>   USE kinds,        ONLY : DP
>   USE bte_var
>   !
>   IMPLICIT NONE
>   !
>   !
>   INTEGER, INTENT(IN)        :: iq_irr, ibnd, jbnd, imode, itemp, idope
>   INTEGER, INTENT(OUT)       :: nscat, ik_ind(nk_ful)
>   REAL(KIND=DP), INTENT(OUT) :: gammai(nk_ful)
>   !
>   CHARACTER(LEN=256)         :: file_ufmt
>   CHARACTER(LEN=12)          :: tnph
>   CHARACTER(LEN=10)          :: q_num, ibnd_num, jbnd_num, imode_num, itemp_num, idope_num
>   !
>   !
>   WRITE(q_num,'(i10)') iq_irr
>   WRITE(ibnd_num,'(i10)') ibnd
>   WRITE(jbnd_num,'(i10)') jbnd
>   WRITE(imode_num,'(i10)') imode
>   WRITE(itemp_num,'(i10)') itemp
>   WRITE(idope_num,'(i10)') idope
>   !
>   tnph = 'T'//TRIM(ADJUSTL(itemp_num))//'_N'//TRIM(ADJUSTL(idope_num))//'_ph'//TRIM(ADJUSTL(imode_num))
>   !
>   file_ufmt = 'BTE/GAMMAI/'//TRIM(ADJUSTL(tnph))//'/gammai_'//TRIM(ADJUSTL(q_num))//'_'//TRIM(ADJUSTL(ibnd_num))//'_'//TRIM(ADJUSTL(jbnd_num))
>   !
>   OPEN (73092,FILE=file_ufmt,FORM='unformatted',ACCESS='direct',RECL=4+nk_ful*(4+DP),STATUS='old')
>   READ (73092,REC=1) nscat, ik_ind(1:nscat), gammai(1:nscat)
>   CLOSE (73092)
>   !
>   !
> END SUBROUTINE gammai_load
> 
> 
Only in ./: bte_io.o
diff ./bte_iteration.f90 ../../epw-qian/src/bte_iteration.f90
2c2
< SUBROUTINE iter_tdbte_el (ik0, ik_pol, nk_pol, f_t_pol)
---
> SUBROUTINE iter_bte_el (ik0, ik_pol, nk_pol, F_k_pol, itemp, idope, iter)
8,10c8,9
<   USE epwcom,       ONLY : nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, eptemp, dt, efield, gradt
<   USE elph2,        ONLY : ibndmin, ibndmax, nbnd_red, &
<                            f_t_ful, f_0_ful, vel_ful, wf_ful
---
>   USE epwcom,       ONLY : nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, fermi_energy, efermi_read, phdrag
>   USE elph2,        ONLY : ibndmin, ibndmax, nbnd_red, tau0_k_ful, F_k_ful, vel_ful, etf_all, ef_epw, wf_all
21,22c20,21
<   INTEGER, INTENT(IN)        :: ik0, ik_pol, nk_pol
<   REAL(KIND=DP), INTENT(OUT) :: f_t_pol(nbnd_red,nk_pol)
---
>   INTEGER, INTENT(IN)        :: ik0, ik_pol, nk_pol, itemp, idope, iter
>   REAL(KIND=DP), INTENT(OUT) :: F_k_pol(3,nbnd_red,nk_pol)
25,26c24,25
<   REAL(KIND=DP)              :: weight_abs(nq_ful), weight_emi(nq_ful)
<   REAL(KIND=DP)              :: Delta(nbnd_red,nk_pol)
---
>   REAL(KIND=DP)              :: sigmai(nq_ful)
>   REAL(KIND=DP)              :: Delta(3,nbnd_red), ef0
28c27,28
<   INTEGER                    :: ik, ik_irr_red, ik_ful, ikq_ful_red, iq, ikq, ibnd, imode, jbnd, nscat, ns, isym
---
>   INTEGER                    :: ik, ik_irr_red, ik_ful, ikq_ful_red, iq_ful_red, iq_irr_red, ikq_irr_red, iq, iq_irr, ikq, &
>                                 ibnd, imode, jbnd, ibnd0, jbnd0, nscat, ns, isym
30c30
<   REAL(KIND=DP)              :: xq(3), xq_rot(3)
---
>   REAL(KIND=DP)              :: xq(3), xq_rot(3), F_tmp_kq, e_tmp_kq
32,33d31
<   REAL(KIND=DP)              :: f_k, f_kq, n_q, f_abs, f_emi, inv_eptemp0
<   REAL(KIND=DP), EXTERNAL    :: wgauss
35c33,38
<   inv_eptemp0 = 1.0d0/eptemp(1)
---
>   IF (efermi_read) THEN
>      ef0 = fermi_energy
>   ELSE
>      ef0 = ef_epw(itemp,idope)
>   ENDIF
>   !
38c41
<   ! ik_pol = 1 ~ nk_pol, used in f_t_pol
---
>   ! ik_pol = 1 ~ nk_pol, used in F_k_pol
41a45,48
>   ik_irr_red = rful2rirr(ik)
>   !
>   ijk_k= id2ijk(ik_ful)
>   !
47,53d53
<   ! ik_irr_red is the kpoint in red-irr-BZ
<   ik_irr_red = rful2rirr(ik)
<   !
<   f_t_pol(:,ik_pol) = 0.0d0 
<   !
<   ! ijk index of ik in ful-BZ
<   ijk_k= id2ijk(ik_ful)
55c55,56
<   ! time evolution
---
>   ! iteration
>   F_k_pol(:,:,ik_pol) = 0.0d0 
56a58,59
>   IF (iter .EQ. 0) GOTO 17120
>   !
58a62,64
>         !
>         jbnd0 = jbnd + ibndmin - 1
>         !
61,62c67
<            weight_abs = 0.0d0
<            weight_emi = 0.0d0
---
>            sigmai = 0.0d0
65c70
<            CALL weight_load (ik_irr_red, ibnd, jbnd, imode, nscat, iq_id, weight_abs, weight_emi)
---
>            CALL sigmai_load (ik_irr_red, ibnd, jbnd, imode, nscat, iq_id, sigmai, itemp, idope)
87d91
<               ! k and q-mesh should be the same
90a95,231
>               ikq = ijk2id(ijk_kq) ! ijk2id
>               !
>               ikq_ful_red = ful2rful(ikq) ! ful-BZ to red-ful-BZ
>               !
>               IF (ikq_ful_red .NE. 0) THEN
>                  !
>                  ikq_irr_red = rful2rirr(ikq_ful_red)
>                  Delta(:,ibnd) = Delta(:,ibnd) + ( sigmai(ns) * (etf_all(jbnd0,ikq_irr_red)-ef0) * F_k_ful(:,jbnd,ikq_ful_red) )
>                  !
>               ENDIF
>               !
>            ENDDO ! ns
>            !
>         ENDDO ! mode
>      ENDDO !jbnd
>   ENDDO ! ibnd
>   !
>   !
> 17120 CONTINUE ! if iter=0
>   !
>   DO ibnd = 1, nbnd_red
>      !
>      ibnd0 = ibnd+ibndmin-1
>      !
>      ! F_k_pol is in units of v*tau
>      F_k_pol(:,ibnd,ik_pol) = tau0_k_ful(ibnd,ik) * ( vel_ful(:,ibnd,ik) + ( 2.0d0*Delta(:,ibnd) / (etf_all(ibnd0,ik_irr_red)-ef0) )  )
>      !
>      ! impose symmetry on every kpoint to prevent from drift
>      CALL symmetrizer (F_k_pol(:,ibnd,ik_pol),ik_ful,'k')
>      !
>   ENDDO 
>   !
>   !
> END SUBROUTINE iter_bte_el
> 
> 
> !----------------------------------------------------------------------------
> SUBROUTINE iter_bte_ph (iq0, itemp, idope, iter)
> !----------------------------------------------------------------------------
> #INCLUDE "f_defs.h"
>   USE kinds,        ONLY : DP
>   USE cell_base,    ONLY : at
>   USE phcom,        ONLY : nmodes
>   USE epwcom,       ONLY : nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, fermi_energy, efermi_read, phdrag
>   USE elph2,        ONLY : ibndmin, ibndmax, nbnd_red, F_k_ful, vel_ful, etf_all, ef_epw, wf_all, vph_ful
>   USE bte_var
>   USE bte_func
> #ifdef __PARA
>   USE io_global,    ONLY : ionode_id, stdout
>   USE mp,           ONLY : mp_barrier
>   USE mp_world,     ONLY : world_comm
>   USE mp_global,    ONLY : my_pool_id
> #ENDIF
>   !
>   IMPLICIT NONE
>   !
>   INTEGER, INTENT(IN)        :: iq0, itemp, idope, iter
>   !
>   INTEGER                    :: ik_id(nk_ful)
>   REAL(KIND=DP)              :: gammai(nk_ful)
>   REAL(KIND=DP)              :: Delta(3,nmodes), ef0
>   ! id and index
>   INTEGER                    :: ik, iq_irr_red, iq_ful, ik_ful, ikq_ful_red, ikq_irr_red, iq_ful_red, ik_irr_red, ik_ful_red, iq_irr, &
>                                 iq, ikq, ibnd, imode, jbnd, ibnd0, jbnd0, nscat, ns, isym, isym_q
>   INTEGER                    :: ijk_k(3), ijk_q(3), ijk_kq(3), ijk_k_rot(3), ijk_q_rot(3), ijk_k_fbz(3)
>   REAL(KIND=DP)              :: xk(3), xq(3), xk_rot(3), xq_rot(3), F_tmp_k(3), F_tmp_kq(3), e_tmp_k, e_tmp_kq, &
>                                 phdrag_k_term(3,1), vqq(3,1), phdrag_k_mat(3,3), phdrag_k_mat_tmp(3,3)
>   !
>   CHARACTER(LEN=256)         :: file_ufmt
>   CHARACTER(LEN=12)          :: tnpe
>   CHARACTER(LEN=10)          :: ibnd_num, jbnd_num, itemp_num, idope_num
>   LOGICAL                    :: exst
>   INTEGER                    :: io
>   !
>   IF (efermi_read) THEN
>      ef0 = fermi_energy
>   ELSE
>      ef0 = ef_epw(itemp,idope)
>   ENDIF
>   !
>   !
>   ! iq0 belongs to nq_ful_red
>   iq_ful_red = iq0
>   iq_ful     = rful2ful_q(iq_ful_red)
>   iq_irr_red = rful2rirr_q(iq_ful_red)
>   iq_irr     = rirr2irr_q(iq_irr_red)
>   !
>   ijk_q= id2ijk_q(iq_ful)
>   !
>   OPEN (1111,FILE='BTE/META/irr2ful_sym_q',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='old')
>   READ (1111,REC=iq_ful) isym_q
>   CLOSE (1111)
>   !
>   ! iteration
>   Delta = 0.0d0
> !  IF (iter .EQ. 0) GOTO 17126
>   !
>   DO imode = 1, nmodes
>      !
>      vqq(:,1) = vph_ful(:,imode,iq_ful_red)
>      !
>      DO ibnd = 1, nbnd_red
>         !
>         ibnd0 = ibnd + ibndmin - 1
>         !
>         WRITE(ibnd_num,'(i10)') ibnd0
>         WRITE(itemp_num,'(i10)') itemp
>         WRITE(idope_num,'(i10)') idope
>         tnpe = 'T'//TRIM(ADJUSTL(itemp_num))//'_N'//TRIM(ADJUSTL(idope_num))//'_i'//TRIM(ADJUSTL(ibnd_num))
>         !
>         file_ufmt = 'BTE/META/phdragsumk_'//TRIM(ADJUSTL(tnpe))
>         !
>         DO jbnd = 1, nbnd_red 
>            !
>            jbnd0 = jbnd + ibndmin - 1
>            !
>            gammai = 0.0d0
>            ik_id  = 0
>            !
>            CALL gammai_load (iq_irr_red, ibnd, jbnd, imode, nscat, ik_id, gammai, itemp, idope)
>            !
>            !
>            DO ns = 1, nscat 
>               !
>               ! ik belongs to nk_ful
>               ik = ik_id(ns) 
>               !
>               xk(:) = xkf_ful(:,ik)
>               !
>               xk_rot(:) = xk(1)*symmat_lat(:,1,isym_q) + xk(2)*symmat_lat(:,2,isym_q) + xk(3)*symmat_lat(:,3,isym_q)
>               !
>               ijk_k_rot(1) = NINT(xk_rot(1)*DBLE(nkf1))
>               ijk_k_rot(2) = NINT(xk_rot(2)*DBLE(nkf2))
>               ijk_k_rot(3) = NINT(xk_rot(3)*DBLE(nkf3))
>               !
>               ijk_kq = ijk_fbz(ijk_q,ijk_k_rot)
>               !
93d233
<               f_k  = f_0_ful(ibnd,ik)
95c235,249
<               f_kq = 0.0d0
---
>               ik_ful_red  = ful2rful(ik)
>               IF (ik_ful_red .NE. 0) THEN
>                  !
>                  !ik_irr_red  = rful2rirr(ik_ful_red)
>                  !e_tmp_k = etf_all(ibnd0,ik_irr_red) - ef0
>                  F_tmp_k(:) = F_k_ful(:,ibnd,ik_ful_red)
>                  !
>               ELSE
>                  !
>                  F_tmp_k(:) = 0.0d0
>                  !e_tmp_k = 0.0d0
>                  !
>               ENDIF
>               !
>               !
97c251,262
<               IF (ikq_ful_red .NE. 0) f_kq = f_0_ful(jbnd,ikq_ful_red)
---
>               IF (ikq_ful_red .NE. 0) THEN
>                  !
>                  !ikq_irr_red = rful2rirr(ikq_ful_red)
>                  !e_tmp_kq = etf_all(jbnd0,ikq_irr_red)-ef0
>                  F_tmp_kq(:) = F_k_ful(:,jbnd,ikq_ful_red)
>                  !
>               ELSE
>                  !
>                  F_tmp_kq(:) = 0.0d0
>                  !e_tmp_kq = 0.0d0
>                  !
>               ENDIF
99,101c264,265
<               ! ERROR, not consider temperature and carrier concentration
<               n_q = wgauss(-wf_ful(imode,1,1,iq)*inv_eptemp0,-99)
<               n_q = n_q/(1.0d0-2.0d0*n_q)    
---
>               !Delta(:,imode) = Delta(:,imode) + ( gammai(ns) * (e_tmp_k*F_tmp_k(:) - e_tmp_kq*F_tmp_kq(:)) )
>               Delta(:,imode) = Delta(:,imode) + ( gammai(ns) * (F_tmp_k(:) - F_tmp_kq(:)) )
103,104c267,268
<               f_abs = (1.0d0+n_q)*f_kq - (n_q+f_kq)*f_k ! (1.0d0-f_k)*(1.0d0+n_q)*f_kq - f_k*n_q*(1.0d0-f_kq)
<               f_emi = (f_k+n_q)*f_kq - (1.0d0+n_q)*f_k  ! (1.0d0-f_k)*n_q*f_kq - f_k*(1.0d0+n_q)*(1.0d0-f_kq)
---
>               phdrag_k_term(:,1) = tau0_q_ful(itemp,imode,iq_ful_red)*( gammai(ns) * (F_tmp_k(:) - F_tmp_kq(:)) )
>               phdrag_k_mat(1:3,1:3) = 2.0d0*MATMUL(vqq,TRANSPOSE(phdrag_k_term)) * wf_all(imode,iq_irr_red) 
106,109c270,285
<               Delta(ibnd,ik_pol) = Delta(ibnd,ik_pol) + ( f_abs*weight_abs(ns) + f_emi*weight_emi(ns) )
< 
< 
<              ! write (6,'(i6,7es15.6)') ns, f_k, f_kq, n_q, f_abs, f_emi, f_abs*weight_abs(ns), f_emi*weight_emi(ns)
---
>               INQUIRE (FILE=file_ufmt,EXIST=exst)
>               phdrag_k_mat_tmp = 0.0d0
>               !
>               IF (exst) THEN
>                 OPEN (18888,FILE=file_ufmt,FORM='unformatted',ACCESS='direct',RECL=9*DP,STATUS='old')
>                 READ (18888,REC=ik,IOSTAT=io) phdrag_k_mat_tmp(1,:),phdrag_k_mat_tmp(2,:),phdrag_k_mat_tmp(3,:)
>                 IF ( io .NE. 0) phdrag_k_mat_tmp = 0.0d0
>                 phdrag_k_mat(:,:) = phdrag_k_mat(:,:) + phdrag_k_mat_tmp(:,:)
>                 WRITE (18888,REC=ik) phdrag_k_mat(1,:),phdrag_k_mat(2,:),phdrag_k_mat(3,:)
>               !
>               ELSE
>                 OPEN (18888,FILE=file_ufmt,FORM='unformatted',ACCESS='direct',RECL=9*DP,STATUS='replace')
>                 WRITE (18888,REC=ik) phdrag_k_mat(1,:),phdrag_k_mat(2,:),phdrag_k_mat(3,:)
>               ENDIF
>               !
>               CLOSE (18888)
114,116c290,294
<         ENDDO ! mode
<      ENDDO !jbnd
<   ENDDO ! ibnd
---
>         ENDDO ! jmode
>         !
>      ENDDO ! ibnd
>      !
>   ENDDO ! imode
118,119c296,313
<   DO ibnd = 1, nbnd_red
<      f_t_pol(ibnd,ik_pol) = f_0_ful(ibnd,ik) + dt*2.0d0*Delta(ibnd,ik_pol)
---
>   !
> !17126 CONTINUE ! if iter=0
>   !
>   DO imode = 1, nmodes
>      !
>      N_q_ful(:,itemp,imode,iq_ful_red) = tau0_q_ful(itemp,imode,iq_ful_red) * vph_ful(:,imode,iq_ful_red)
>      !dN_q_ful(:,imode,iq_ful_red) = tau0_q_ful(imode,iq_ful_red) * ( 2.0d0*Delta(:,imode)/wf_all(imode,iq_irr_red) )
>      dN_q_ful(:,itemp,imode,iq_ful_red) = tau0_q_ful(itemp,imode,iq_ful_red) * ( 2.0d0*Delta(:,imode) )
>      !
>      IF (ph_rate_ful(itemp,imode,iq_ful) .NE. 0.0d0) THEN
>      int_N_q_ful(:,itemp,imode,iq_ful_red) = 1.0d0 * vph_ful(:,imode,iq_ful_red) / ph_rate_ful(itemp,imode,iq_ful)
>      ELSE
>      int_N_q_ful(:,itemp,imode,iq_ful_red) = 0.0d0
>      ENDIF  
>      !
>      CALL symmetrizer (N_q_ful(:,itemp,imode,iq_ful_red),iq_ful,'q')
>      CALL symmetrizer (dN_q_ful(:,itemp,imode,iq_ful_red),iq_ful,'q')
>      !
123c317,319
< END SUBROUTINE iter_tdbte_el
---
> END SUBROUTINE iter_bte_ph
> 
> 
128c324
< SUBROUTINE iter_bte_el (ik0, ik_pol, nk_pol, F_k_pol, itemp, idope, iter)
---
> SUBROUTINE iter_tdbte_el (ik0, ik_pol, nk_pol, f_t_pol)
134,135c330,332
<   USE epwcom,       ONLY : nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, fermi_energy, efermi_read
<   USE elph2,        ONLY : ibndmin, ibndmax, nbnd_red, tau0_k_ful, F_k_ful, vel_ful, etf_all, ef_epw
---
>   USE epwcom,       ONLY : nkf1, nkf2, nkf3, nqf1, nqf2, nqf3, eptemp, dt, efield, gradt, phdrag
>   USE elph2,        ONLY : ibndmin, ibndmax, nbnd_red, &
>                            f_t_ful, f_0_ful, vel_ful, wf_ful, wf_irr
146,147c343,344
<   INTEGER, INTENT(IN)        :: ik0, ik_pol, nk_pol, itemp, idope, iter
<   REAL(KIND=DP), INTENT(OUT) :: F_k_pol(3,nbnd_red,nk_pol)
---
>   INTEGER, INTENT(IN)        :: ik0, ik_pol, nk_pol
>   REAL(KIND=DP), INTENT(OUT) :: f_t_pol(nbnd_red,nk_pol)
150,151c347,348
<   REAL(KIND=DP)              :: sigmai(nq_ful)
<   REAL(KIND=DP)              :: Delta(3,nbnd_red,nk_pol), ef0
---
>   REAL(KIND=DP)              :: weight_abs(nq_ful), weight_emi(nq_ful)
>   REAL(KIND=DP)              :: Delta(nbnd_red,nk_pol)
153c350
<   INTEGER                    :: ik, ik_irr_red, ik_ful, ikq_ful_red, ikq_irr_red, iq, ikq, ibnd, imode, jbnd, ibnd0, jbnd0, nscat, ns, isym
---
>   INTEGER                    :: ik, ik_irr_red, ik_ful, ikq_ful_red, iq, ikq, ibnd, imode, jbnd, nscat, ns, isym
156a354,357
>   REAL(KIND=DP)              :: f_k, f_kq, n_q, f_abs, f_emi, inv_eptemp0
>   REAL(KIND=DP), EXTERNAL    :: wgauss
>   !
>   inv_eptemp0 = 1.0d0/eptemp(1)
159c360
<   ! ik_pol = 1 ~ nk_pol, used in F_k_pol
---
>   ! ik_pol = 1 ~ nk_pol, used in f_t_pol
171c372
<   F_k_pol(:,:,ik_pol) = 0.0d0 
---
>   f_t_pol(:,ik_pol) = 0.0d0 
176,182c377
<   IF (efermi_read) THEN
<      ef0 = fermi_energy
<   ELSE
<      ef0 = ef_epw(itemp,idope)
<   ENDIF
<   !
<   ! iteration
---
>   ! time evolution
184,185d378
<   IF (iter .EQ. 0) GOTO 17120
<   !
188,190d380
<         !
<         jbnd0 = jbnd + ibndmin - 1
<         !
193c383,384
<            sigmai = 0.0d0
---
>            weight_abs = 0.0d0
>            weight_emi = 0.0d0
196c387
<            CALL sigmai_load (ik_irr_red, ibnd, jbnd, imode, nscat, iq_id, sigmai, itemp, idope)
---
>            CALL weight_load (ik_irr_red, ibnd, jbnd, imode, nscat, iq_id, weight_abs, weight_emi)
222c413
<               ikq = ijk2id(ijk_kq) ! ijk2id
---
>               ikq = ijk2id(ijk_kq)
224,230c415,430
<               ikq_ful_red = ful2rful(ikq) ! ful-BZ to red-ful-BZ
<               IF (ikq_ful_red .NE. 0) THEN
<                  !
<                  ikq_irr_red = rful2rirr(ikq_ful_red)
<                  Delta(:,ibnd,ik_pol) = Delta(:,ibnd,ik_pol) + ( sigmai(ns) * (etf_all(jbnd0,ikq_irr_red)-ef0) * F_k_ful(:,jbnd,ikq_ful_red) )
<                  !
<               ENDIF
---
>               f_k  = f_0_ful(ibnd,ik)
>               !
>               f_kq = 0.0d0
>               ikq_ful_red = ful2rful(ikq)
>               IF (ikq_ful_red .NE. 0) f_kq = f_0_ful(jbnd,ikq_ful_red)
>               !
>               n_q = n_q/(1.0d0-2.0d0*n_q)    
>               !
>               f_abs = (1.0d0+n_q)*f_kq - (n_q+f_kq)*f_k ! (1.0d0-f_k)*(1.0d0+n_q)*f_kq - f_k*n_q*(1.0d0-f_kq)
>               f_emi = (f_k+n_q)*f_kq - (1.0d0+n_q)*f_k  ! (1.0d0-f_k)*n_q*f_kq - f_k*(1.0d0+n_q)*(1.0d0-f_kq)
>               !
>               Delta(ibnd,ik_pol) = Delta(ibnd,ik_pol) + ( f_abs*weight_abs(ns) + f_emi*weight_emi(ns) )
> 
> 
>              ! write (6,'(i6,7es15.6)') ns, f_k, f_kq, n_q, f_abs, f_emi, f_abs*weight_abs(ns), f_emi*weight_emi(ns)
> 
238,240d437
<   !
< 17120 CONTINUE ! if iter=0
<   !
242,248c439
<      !
<      ibnd0 = ibnd+ibndmin-1
<      !
<      ! F_k_pol is in units of v*tau
<      F_k_pol(:,ibnd,ik_pol) = tau0_k_ful(ibnd,ik) * ( vel_ful(:,ibnd,ik) + ( Delta(:,ibnd,ik_pol) / (etf_all(ibnd0,ik_irr_red)-ef0) )  )
<      ! impose symmetry on every kpoint to prevent from drift
<      CALL symmetrizer (F_k_pol(:,ibnd,ik_pol),ik_ful,'k')
---
>      f_t_pol(ibnd,ik_pol) = f_0_ful(ibnd,ik) + dt*2.0d0*Delta(ibnd,ik_pol)
252c443
< END SUBROUTINE iter_bte_el
---
> END SUBROUTINE iter_tdbte_el
Only in ./: bte_iteration.o
Only in ./: bte.o
Only in ../../epw-qian/src/: bte_phcheck.f90
diff ./bte_symm.f90 ../../epw-qian/src/bte_symm.f90
283a284,302
>   ! export for checking
>   IF (my_pool_id .EQ. ionode_id) THEN
>      !
>      IF (flag .EQ. 'k') OPEN (1217,FILE='BTE/EPCHECK/equiv_k.dat',STATUS='replace')
>      IF (flag .EQ. 'q') OPEN (1217,FILE='BTE/EPCHECK/equiv_q.dat',STATUS='replace')
>      !
>      DO nk = 1, nk_ful
>         WRITE (1217,'(3i12)') nk, equiv(nk), ful2irr(nk)
>      ENDDO
>      CLOSE (1217)
>      !
>   ENDIF
>   !
>   !
> #ifdef __PARA
>   CALL mp_barrier (inter_pool_comm)
> #ENDIF
>   !
>   !
295a315,316
>      IF (flag .EQ. 'k') OPEN (8888,FILE='BTE/META/equiv',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='replace')
>      IF (flag .EQ. 'q') OPEN (8888,FILE='BTE/META/equiv_q',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='replace')
298a320
>         WRITE (8888,REC=ik) equiv(ik)
740a763,924
> 
> !---------------------------------------------------------------------------------
> SUBROUTINE reduce_index_ph (wf)
> !---------------------------------------------------------------------------------
> #INCLUDE "f_defs.h"
>   USE kinds,     ONLY : DP
>   USE cell_base, ONLY : at, bg
>   USE epwcom,    ONLY : phwmax, phkmax
>   USE ions_base,     ONLY : nat
>   USE phcom,         ONLY : nmodes
>   USE constants_epw, ONLY : ryd2thz
>   USE bte_var
> #ifdef __PARA
>   USE mp,        ONLY : mp_barrier, mp_sum, mp_min, mp_bcast
>   USE io_global, ONLY : ionode_id, stdout
>   USE mp_global, ONLY : my_pool_id, inter_pool_comm
> #ENDIF
>   !
>   IMPLICIT NONE
>   !
>   REAL(KIND=DP), INTENT(IN) :: wf(nmodes,nq_irr)
>   REAL(KIND=DP)             :: xq(3), qleng, t0, t1, qleng_max=-9.9d30, wf_max=-9.9d30
>   INTEGER                   :: iq, iq0, iq_red, imode
>   LOGICAL                   :: within_range
>   INTEGER, ALLOCATABLE      :: rirr2irr_tmp(:), rful2ful_tmp(:)
>   !
>   !
>   CALL CPU_TIME (t0)
>   !
>   ALLOCATE (rirr2irr_tmp(nq_irr))
>   rirr2irr_tmp = 0
>   !
>   nq_irr_red = 0
>   DO iq = 1, nq_irr
>      !
>      within_range = .FALSE.
>      !
>      xq(:) = xqf_irr(:,iq)
>      CALL cryst_to_cart (1,xq,bg,1)
>      qleng = SQRT(DOT_PRODUCT(xq,xq))
>      !
>      IF (qleng .GT. qleng_max) qleng_max = qleng
>      !
>      DO imode = 1, nmodes
>         IF (wf(imode,iq) .GT. wf_max) wf_max = wf(imode,iq)
>         IF (wf(imode,iq) .LE. phwmax .AND. qleng .LE. phkmax) within_range = .TRUE.
>      ENDDO
>      !
>      IF (within_range) THEN
>         !
>         nq_irr_red = nq_irr_red + 1
>         rirr2irr_tmp(nq_irr_red) = iq
>         !
>      ENDIF
>      !
>   ENDDO
>   !
>   ALLOCATE (rirr2irr_q(nq_irr_red))
>   rirr2irr_q(1:nq_irr_red) = rirr2irr_tmp(1:nq_irr_red)
>   !
>   !
>   ! mapping to ful-BZ
>   ALLOCATE(rful2ful_tmp(nq_ful))
>   rful2ful_tmp = 0
>   !
>   nq_ful_red = 0
>   DO iq_red = 1, nq_irr_red
>      !
>      DO iq = 1, nq_ful
>         !
>         IF (ful2irr_q(iq) .EQ. rirr2irr_q(iq_red)) THEN
>            !
>            nq_ful_red = nq_ful_red + 1
>            rful2ful_tmp(nq_ful_red) = iq
>            !
>         ENDIF
>         !
>      ENDDO
>      !
>   ENDDO
>   !
>   ALLOCATE (rful2ful_q(nq_ful_red))
>   ALLOCATE (ful2rful_q(nq_ful))
>   rful2ful_q = 0
>   ful2rful_q = 0
>   !
>   rful2ful_q(1:nq_ful_red) = rful2ful_tmp(1:nq_ful_red)
>   DO iq = 1, nq_ful_red
>      ful2rful_q(rful2ful_q(iq)) = iq
>   ENDDO
>   !
>   ! 
>   ! red-ful to red-irr
>   ALLOCATE(rful2rirr_q(nq_ful))
>   rful2rirr_q = 0
>   DO iq = 1, nq_ful_red
>      DO iq0 = 1, nq_irr_red
>         IF (ful2irr_q(rful2ful_q(iq)) .EQ. rirr2irr_q(iq0)) rful2rirr_q(iq) = iq0
>      ENDDO
>   ENDDO
>   !
>   !
>   ! output file
>   IF (my_pool_id .EQ. ionode_id) THEN
>      !
>      ! binary
>      OPEN (99999,FILE='BTE/META/nq_irr_red',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='replace')
>         WRITE (99999,REC=1) nq_irr_red
>      CLOSE (99999)
>      !
>      OPEN (99999,FILE='BTE/META/nq_ful_red',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='replace')
>         WRITE (99999,REC=1) nq_ful_red
>      CLOSE (99999)
>      !
>      OPEN (99999,FILE='BTE/META/rirr2irr_q',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='replace')
>      DO iq = 1, nq_irr_red
>         WRITE (99999,REC=iq) rirr2irr_q(iq)
>      ENDDO
>      CLOSE (99999)
>      !
>      OPEN (99999,FILE='BTE/META/rful2ful_q',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='replace')
>      DO iq = 1, nq_ful_red
>         WRITE (99999,REC=iq) rful2ful_q(iq)
>      ENDDO
>      CLOSE (99999)
>      !
>      OPEN (99999,FILE='BTE/META/ful2rful_q',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='replace')
>      DO iq = 1, nq_ful
>         WRITE (99999,REC=iq) ful2rful_q(iq)
>      ENDDO
>      CLOSE (99999)  
>      !
>      OPEN (99999,FILE='BTE/META/rful2rirr_q',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='replace')
>      DO iq = 1, nq_ful_red
>         WRITE (99999,REC=iq) rful2rirr_q(iq)
>      ENDDO
>      CLOSE (99999)
>      !
>   ENDIF
>   !
>   CALL CPU_TIME (t1)
>   !
>   !
>   WRITE (stdout,'(/5x,a,f8.2,a)') 'Time for regular selective scheme:', t1-t0, ' s'
>   WRITE (stdout,'(/5x,a,es13.4,a,es13.4,a)') 'Max. phonon frequency  : ', wf_max*ryd2thz,    ' [THz]   ; Cutoff frequency  :', phwmax*ryd2thz, ' [THz]'
>   WRITE (stdout,'(5x,a,es13.4,a,es13.4,a)') 'Max. phonon wavevector : ', qleng_max, ' [2pi/a] ; Cutoff wavevector :', phkmax, ' [2pi/a]'
>   WRITE (stdout,'(/5x,a/)') 'q point will be selected if frequency < phwmax and wavevector < phkmax'  
>   WRITE (stdout,'(5x,a,i12,a,i10)')  'q points in ful-BZ: ', nq_ful, ' -> ', nq_ful_red
>   WRITE (stdout,'(5x,a,i12,a,i10/)') '            irr-BZ: ', nq_irr, ' -> ', nq_irr_red
>   !
>   !
>   DEALLOCATE (rirr2irr_tmp)
>   DEALLOCATE (rful2ful_tmp)
>   ! not to deallocate in this case
>   !DEALLOCATE (rirr2irr_q)
>   !DEALLOCATE (rful2ful_q)
>   !DEALLOCATE (ful2rful_q)
>   !DEALLOCATE (rful2rirr_q)
>   !
>   !
> END SUBROUTINE reduce_index_ph
> 
898d1081
<   USE symm_base,     ONLY : set_sym_bl
916a1100,1101
>   ! Form here, vel_ful belongs to nk_ful_red
>   !
919c1104
<   WRITE (stdout,'(/5x,a)') 'Rotate electron velocity according to crystal symmetry'
---
>   WRITE (stdout,'(/5x,a)') 'Rotate electron velocity from red-irr-BZ to red-ful-BZ according to crystal symmetry'
967,968c1152
<      OPEN (99999,FILE='BTE/EPCHECK/electron_ful.dat')
<      OPEN (1111,FILE='BTE/META/ful2irr',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='old')  
---
>      OPEN (99999,FILE='BTE/EPCHECK/electron_ful_red.dat')
979d1162
<      CLOSE (1111)
984,985d1166
<   IF (ALLOCATED(vel_all)) DEALLOCATE (vel_all)
<   !
993a1175,1273
> SUBROUTINE rotate_vph
> !---------------------------------------------------------------------------------
> #INCLUDE "f_defs.h"
>   USE kinds,         ONLY : DP
>   USE cell_base,     ONLY : at, bg
>   USE phcom,         ONLY : nmodes
>   USE epwcom,        ONLY : nbndsub, bte, nqf1, nqf2, nqf3
>   USE elph2,         ONLY : vph_ful, wf_all, vph_all
>   USE bte_var
>   USE constants_epw, ONLY : ryd2ev, rydcm1, au2m, au2s, au2ps
> #ifdef __PARA
>   USE mp,            ONLY : mp_barrier, mp_sum
>   USE io_global,     ONLY : ionode_id, stdout
>   USE mp_global,     ONLY : my_pool_id, inter_pool_comm
> #endif
>   !
>   IMPLICIT NONE
>   !
>   INTEGER :: iq_ful_red, iq_irr_red, imode, ir, iq_ful, iq_irr, isym_q
>   REAL(KIND=DP) :: t0, t1
>   ! para
>   INTEGER :: nq_pol, iq_star, iq_stop
>   !
>   !
>   ! From here, vph_ful belongs to nq_ful_red
>   !
>   CALL CPU_TIME (t0)
>   !
>   WRITE (stdout,'(/5x,a)') 'Rotate phonon velocity from red-irr-BZ to red-ful-BZ according to crystal symmetry'
>   !
>   ALLOCATE (vph_ful(3,nmodes,nq_ful_red))
>   vph_ful = 0.0d0
>   !
>   CALL para_bounds (iq_star,iq_stop,nq_ful_red)
>   !
>   !
>   OPEN (2222,FILE='BTE/META/irr2ful_sym_q',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='old')  
>   DO iq_ful_red = iq_star, iq_stop
>      !
>      iq_ful = rful2ful_q(iq_ful_red)
>      iq_irr_red = rful2rirr_q(iq_ful_red)
>      !
>      READ (2222,REC=iq_ful) isym_q
>      !
>      DO imode = 1, nmodes
>         !
>         CALL cryst_to_cart (1,vph_all(:,imode,iq_irr_red),at,-1)
>         !
>         DO ir = 1, 3
>            ! now the vph_ful is in crystal coordinate
>            vph_ful(ir,imode,iq_ful_red) = vph_all(1,imode,iq_irr_red)*symmat_lat(ir,1,isym_q) + &
>                                           vph_all(2,imode,iq_irr_red)*symmat_lat(ir,2,isym_q) + &
>                                           vph_all(3,imode,iq_irr_red)*symmat_lat(ir,3,isym_q)
>            !
>         ENDDO
>         !
>         CALL cryst_to_cart (1,vph_all(:,imode,iq_irr_red),bg,1)
>         CALL cryst_to_cart (1,vph_ful(:,imode,iq_ful_red),bg,1)
>         !
>         ! apply symmetrizer to velocity 
>         CALL symmetrizer (vph_ful(:,imode,iq_ful_red),iq_ful,'q')
>         !
>      ENDDO
>      !
>   ENDDO
>   CLOSE (2222)
>   !  
> #ifdef __PARA
>   CALL mp_barrier (inter_pool_comm)
>   CALL mp_sum (vph_ful,inter_pool_comm)
> #ENDIF
>   !
>   ! output and check
>   IF (my_pool_id .EQ. ionode_id) THEN
>      !
>      OPEN (99999,FILE='BTE/EPCHECK/phonon_ful_red.dat')
>      DO iq_ful_red = 1, nq_ful_red
>         !
>         iq_ful = rful2ful_q(iq_ful_red)
>         iq_irr_red = rful2rirr_q(iq_ful_red)
>         !
>         DO imode = 1, nmodes
>            WRITE (99999,'(i12,i5,f15.4,3f17.4)') iq_ful, imode, wf_all(imode,iq_irr_red)*rydcm1, vph_ful(1:3,imode,iq_ful_red)*(au2m/au2s)
>         ENDDO
>      ENDDO
>      CLOSE (99999)
>      !
>   ENDIF
>   !
>   !
>   CALL CPU_TIME (t1)
>   WRITE (stdout,'(/13x,a,f8.2,a)') 'Time : ', (t1-t0), ' s'
>   !
> END SUBROUTINE rotate_vph
> 
> 
> 
> 
> !---------------------------------------------------------------------------------
Only in ./: bte_symm.o
diff ./bte_transpt.f90 ../../epw-qian/src/bte_transpt.f90
11,13c11,13
<   USE epwcom,        ONLY : bte, nbndsub, eptemp, efermi_read, fermi_energy, nptype, epdope, epdim, neptemp
<   USE elph2,         ONLY : ibndmin, ibndmax, nbnd_red, n_elec, n_hole, etf_all, vel_ful, ef_epw,  &
<                             F_k_ful, mfp_k_ful, cbnd_emin, vbnd_emax
---
>   USE epwcom,        ONLY : bte, nbndsub, eptemp, efermi_read, fermi_energy, nptype, epdope, epdim, neptemp, phdrag
>   USE elph2,         ONLY : ibndmin, ibndmax, nbnd_red, n_elec, n_hole, etf_all, vel_ful, ef_epw, vph_ful, wf_all,  &
>                             F_k_ful, mfp_k_ful, mfp_q_ful, cbnd_emin, vbnd_emax, vbnd_num, cbnd_num
16c16
<   USE constants_epw, ONLY : kB, au2Ohm, au2Amp, au2j, au2m, au2cm, au2s
---
>   USE constants_epw, ONLY : kB, au2Ohm, au2Amp, au2j, au2m, au2cm, au2s, twopi
24c24
<   REAL(KIND=DP), INTENT(OUT) :: transpt(3,3,7)
---
>   REAL(KIND=DP), INTENT(OUT) :: transpt(3,3,24)
26,29c26,30
<   INTEGER                    :: ik_ful_red, ik_irr_red, ibnd, ibnd0, imode, ir, i, j, uorl
<   REAL(KIND=DP)              :: temp, ef0, ndoping, f0, df0, ekk, vkk(3,1), vtau(3,1), wsp, &
<                                 ncarrier
<   REAL(KIND=DP)              :: factor(4)  
---
>   INTEGER                    :: ik_ful_red, ik_ful, ik_irr_red, ibnd, ibnd0, imode, ir, i, j, uorl, &
>                                 io, iq_ful_red, iq_irr_red
>   REAL(KIND=DP)              :: wsp, temp, ef0, h_carr, e_carr, f0, df0, ekk, vkk(3,1), n0, dn0, wqq, vqq(3,1), &
>                                 vtau(3,1), vtau_q(3,1), int_vtau_q(3,1),vtau_q_phd(3,1)
>   REAL(KIND=DP)              :: factor(15)  
31,33c32,40
<   REAL(KIND=DP)              :: L11(3,3), L12(3,3), L21(3,3), L22(3,3), inv_L11(3,3), &
<                                 L11_k(3,3), L12_k(3,3), L21_k(3,3), L22_k(3,3)
<   REAL(KIND=DP)              :: mob(3,3), cod(3,3), inv_cod(3,3), etc(3,3), seb(3,3), pel(3,3), pof(3,3), loz(3,3)
---
>   REAL(KIND=DP)              :: L11(3,3), L11_e(3,3), L11_h(3,3), L12(3,3), L12_e(3,3), L12_h(3,3), &
>                                 L21(3,3), L21_e(3,3), L21_h(3,3), L22(3,3), L33(3,3), L3i(3,3), L44(3,3), inv_L11(3,3), &
>                                 inv_L11_h(3,3), inv_L11_e(3,3), L11_k(3,3),L11_e_k(3,3), L11_h_k(3,3), L12_k(3,3), &
>                                 L12_e_k(3,3), L12_h_k(3,3), L21_k(3,3), L21_e_k(3,3), L21_h_k(3,3), L22_k(3,3), &
>                                 L44_k(3,3), L33_q(3,3), L44_q(3,3), &
>                                 L44_e(3,3), L44_x(3,3), L44_l(3,3), L44_g(3,3), xful_cry(3), L3i_q(3,3)
>   REAL(KIND=DP)              :: mob(3,3), cod(3,3), etc(3,3), seb(3,3), pel(3,3), pof(3,3), loz(3,3), ltc(3,3), sltc(3,3), &
>                                 btc(3,3),spd(3,3), spd_k(3,3), spd_x(3,3), spd_l(3,3), spd_g(3,3), phdrag_k_mat(3,3), &
>                                 mob_e(3,3), mob_h(3,3), cod_e(3,3), cod_h(3,3), seb_e(3,3), seb_h(3,3)
35,36c42,43
<   CHARACTER(LEN=256)         :: onsager_ufmt
<   CHARACTER(LEN=3)           :: itemp_num, idope_num
---
>   CHARACTER(LEN=256)         :: onsager_ufmt, phdrag_ufmt, phdrag_k_ufmt, tnpe, phdragsumk_ufmt
>   CHARACTER(LEN=10)           :: itemp_num, idope_num, ibnd_num
49,54c56,59
<   IF (epdope(idope) .GE. 0.0d0) THEN
<      ndoping = ABS(n_hole(itemp,idope)) ! in units of cm^3
<   ELSE
<      ndoping = ABS(n_elec(itemp,idope)) ! in units of cm^3
<   ENDIF
<   ncarrier = abs(n_hole(itemp,idope)) + abs(n_elec(itemp,idope))
---
>   h_carr = ABS(n_hole(itemp,idope)) ! in units of cm^3
>   IF (h_carr .LT. 1.0d-50) h_carr = 1.0d-50
>   e_carr = ABS(n_elec(itemp,idope)) ! in units of cm^3
>   IF (e_carr .LT. 1.0d-50) e_carr = 1.0d-50
64a70,71
>   L11_e     = 0.0d0
>   L11_h     = 0.0d0
65a73,74
>   L12_e     = 0.0d0
>   L12_h     = 0.0d0
66a76,77
>   L21_e     = 0.0d0
>   L21_h     = 0.0d0
68c79,88
<   L11_k     = 0.0d0
---
>   L33       = 0.0d0
>   L3i       = 0.0d0
>   L44       = 0.0d0
>   L44_e     = 0.0d0
>   L44_x     = 0.0d0
>   L44_l     = 0.0d0
>   L44_g     = 0.0d0
>  L11_k     = 0.0d0
>   L11_e_k   = 0.0d0
>   L11_h_k   = 0.0d0
69a90,91
>   L12_e_k   = 0.0d0
>   L12_h_k   = 0.0d0
70a93,94
>   L21_e_k   = 0.0d0
>   L21_h_k   = 0.0d0
71a96,99
>   L33_q     = 0.0d0
>   L3i_q     = 0.0d0
>   L44_q     = 0.0d0
>   L44_k     = 0.0d0
72a101,102
>   mob_e     = 0.0d0
>   mob_h     = 0.0d0
73a104,105
>   cod_e     = 0.0d0
>   cod_h     = 0.0d0
77a110,113
>   btc       = 0.0d0
>   ltc       = 0.0d0
>   sltc       = 0.0d0
>   spd       = 0.0d0
79a116
>   mfp_q_ful = 0.0d0
84a122,123
>   factor(5) = 1.0/omega/DBLE(nq_ful) * kB * au2j / au2s / au2m
>   factor(6) = (2.0d0/DBLE(nq_ful))*(SQRT(2.0d0)/omega/temp/temp) * kB * au2Amp / au2m ! wsp and nk_ful have been considered in gammai_phd 
92a132,135
>       phdrag_ufmt = 'BTE/META/phdrag_q_T'//TRIM(ADJUSTL(itemp_num))//'_N'//TRIM(ADJUSTL(idope_num))
>       OPEN (22222,FILE=phdrag_ufmt,FORM='unformatted',ACCESS='direct',RECL=(1+2*9)*DP,STATUS='replace')
>       phdrag_k_ufmt = 'BTE/META/phdrag_k_T'//TRIM(ADJUSTL(itemp_num))//'_N'//TRIM(ADJUSTL(idope_num))
>       OPEN (33333,FILE=phdrag_k_ufmt,FORM='unformatted',ACCESS='direct',RECL=(1+9)*DP,STATUS='replace')
108a152
>         !
116a161,184
>         IF (ibnd0 .LE. vbnd_num) THEN  !  to include semi-metal
>            !
>            L11_h_k(1:3,1:3) = factor(1) * df0 * MATMUL(vkk,TRANSPOSE(vtau)) ! f0_h = 1-f0_e, and df0_h = -df0_e
>            L11_h = L11_h + L11_h_k
>            !
>            L12_h_k(1:3,1:3) = factor(2) * df0 * MATMUL(vkk,TRANSPOSE(vtau)) * ekk
>            L12_h = L12_h + L12_h_k
>            !
>            L21_h_k(1:3,1:3) = factor(3) * df0 * MATMUL(vkk,TRANSPOSE(vtau)) * ekk
>            L21_h = L21_h + L21_h_k
>            !
>          ELSE
>            !
>            L11_e_k(1:3,1:3) = factor(1) * df0 * MATMUL(vkk,TRANSPOSE(vtau))
>            L11_e = L11_e + L11_e_k
>            !
>            L12_e_k(1:3,1:3) = factor(2) * df0 * MATMUL(vkk,TRANSPOSE(vtau)) * ekk
>            L12_e = L12_e + L12_e_k
>            !
>            L21_e_k(1:3,1:3) = factor(3) * df0 * MATMUL(vkk,TRANSPOSE(vtau)) * ekk
>            L21_e = L21_e + L21_e_k
>            !
>         ENDIF
>            !
149a218,327
>   !
>   IF (phdrag) THEN
>      !
>      WRITE(itemp_num,'(i10)') itemp
>      !
>      WRITE(idope_num,'(i10)') idope
>      !
>      OPEN (9999,FILE='BTE/META/xkf_ful_cryst',FORM='unformatted',ACCESS='direct',RECL=3*DP,STATUS='old')
>      !
>      DO ik_ful_red = 1, nk_ful_red
>         !
>         ik_ful = rful2ful(ik_ful_red)
>         ik_irr_red = rful2rirr(ik_ful_red)
>         READ (9999,REC=ik_ful) xful_cry(1:3)
>         !
>        DO ibnd = 1, nbnd_red
>         !
>         ibnd0 = ibnd+ibndmin-1
>         WRITE(ibnd_num,'(i10)') ibnd0
>         !
>         tnpe = 'T'//TRIM(ADJUSTL(itemp_num))//'_N'//TRIM(ADJUSTL(idope_num))//'_i'//TRIM(ADJUSTL(ibnd_num))
>         !
>         phdragsumk_ufmt = 'BTE/META/phdragsumk_'//TRIM(ADJUSTL(tnpe))
>         !
>         OPEN (18888,FILE=phdragsumk_ufmt,FORM='unformatted',ACCESS='direct',RECL=9*DP,STATUS='old')
>         !
>         READ (18888,REC=ik_ful,IOSTAT=io) phdrag_k_mat(1,:),phdrag_k_mat(2,:),phdrag_k_mat(3,:)
>         !
>         IF (io .NE. 0) phdrag_k_mat = 0.0d0 ! some ik_ful might not have corresponding nscat written
>         CLOSE (18888)
>         !
>         L44_k(1:3,1:3) = factor(6) * phdrag_k_mat(1:3,1:3)
>         !
>         L44_e =  L44_e + L44_k
>         !
>         IF ((SQRT((xful_cry(1)-0.5d0)**2 + (xful_cry(2)-0.5d0)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.5d0)**2 + xful_cry(2)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT(xful_cry(1)**2 + (xful_cry(2)-0.5d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT(xful_cry(1)**2 + xful_cry(2)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.5d0)**2 + (xful_cry(2)-1.0d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2 + (xful_cry(2)-0.5d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2 + (xful_cry(2)-1.0d0)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.5d0)**2 + (xful_cry(2)-1.0d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2 + (xful_cry(2)-0.5d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2 + xful_cry(2)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.5d0)**2 + xful_cry(2)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT(xful_cry(1)**2 + (xful_cry(2)-0.5d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT(xful_cry(1)**2 + (xful_cry(2)-1.0d0)**2+ (xful_cry(3)-0.5d0)**2) .LT. 0.0625)) THEN  ! crystal: L 0.5 0.5 0.5, 0/1 0/1 0.5, 0/1 0.5 0/1, 0.5 0/1 0/1
>         !
>         L44_l =  L44_l + L44_k
>         !
>         ELSEIF ((SQRT((xful_cry(1)-0.425d0)**2 + (xful_cry(2)-0.425d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.425d0)**2 + (xful_cry(3)-0.425d0)**2+ xful_cry(2)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(3)-0.425d0)**2 + (xful_cry(2)-0.425d0)**2+ xful_cry(1)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.425d0)**2 + (xful_cry(2)-0.425d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.425d0)**2 + (xful_cry(3)-0.425d0)**2+ (xful_cry(2)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(3)-0.425d0)**2 + (xful_cry(2)-0.425d0)**2+ (xful_cry(1)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.575d0)**2 + (xful_cry(2)-0.575d0)**2+ xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.575d0)**2 + (xful_cry(3)-0.575d0)**2+ xful_cry(2)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(3)-0.575d0)**2 + (xful_cry(2)-0.575d0)**2+ xful_cry(1)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.575d0)**2 + (xful_cry(2)-0.575d0)**2+ (xful_cry(3)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-0.575d0)**2 + (xful_cry(3)-0.575d0)**2+ (xful_cry(2)-1.0d0)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(3)-0.575d0)**2 + (xful_cry(2)-0.575d0)**2+ (xful_cry(1)-1.0d0)**2) .LT. 0.0625)) THEN   ! Si crystal: near X 0/1 0.425 0.425 or 0/1 0.575 0.575
>         !
>         L44_x =  L44_x + L44_k
>         !
>         ELSEIF ((SQRT(xful_cry(1)**2+ xful_cry(2)**2 + xful_cry(3)**2) .LT. 0.0625) .OR. (SQRT((xful_cry(1)-1.0d0)**2+ (xful_cry(2)-1.0d0)**2 + (xful_cry(3)-1.0d0)**2) .LT. 0.0625)) THEN  !gamma
>         !
>         L44_g =  L44_g + L44_k
>         !
>         ENDIF
>         !
>         ! save phdrag components of each k
>         IF (my_pool_id .EQ. ionode_id) THEN 
>            !
>            WRITE (33333,REC=(ik_ful_red-1)*nbnd_red+ibnd)  etf_all(ibnd0,ik_irr_red), L44_k(1:3,1:3)
>         !
>         ENDIF
>         !
>        ENDDO
>      ENDDO
>      CLOSE (9999)
>      !
>      DO iq_ful_red = 1, nq_ful_red
>         !
>         iq_irr_red = rful2rirr_q(iq_ful_red)
>         !
>         DO imode = 1, nmodes
>            !
>            wqq             = wf_all(imode,iq_irr_red)
>            vqq(:,1)        = vph_ful(:,imode,iq_ful_red)
>            int_vtau_q(:,1) = int_N_q_ful(:,itemp,imode,iq_ful_red)
>            vtau_q(:,1)     = N_q_ful(:,itemp,imode,iq_ful_red)
>            vtau_q_phd(:,1) = dN_q_ful(:,itemp,imode,iq_ful_red)
>            !
>            IF (wqq .NE. 0.0d0) THEN
>              n0 = wgauss(-wqq/temp,-99)
>              n0 = n0/(1.0d0-2.0d0*n0)
>              dn0 = (wqq/temp/temp)*n0*(n0+1.0d0) 
>            ELSE
>              n0  = 0.0d0
>              dn0 = 0.0d0
>            ENDIF
>            !   
>            L33_q(1:3,1:3) = factor(5) * dn0 * MATMUL(vqq,TRANSPOSE(vtau_q)) * wqq
>            L3i_q(1:3,1:3) = factor(5) * dn0 * MATMUL(vqq,TRANSPOSE(int_vtau_q)) * wqq
>            L44_q(1:3,1:3) = factor(6) * MATMUL(vqq,TRANSPOSE(vtau_q_phd)) * wqq
>            !
>            L33 = L33 + L33_q
>            L3i = L3i + L3i_q
>            L44 = L44 + L44_q
>            !
>            ! mean free path of each q
>         IF (MAXVAL(ABS(vqq(:,1))) .NE. 0.0d0) THEN
>            mfp_q_ful(imode,iq_ful_red) = DOT_PRODUCT(vtau_q(:,1),vqq(:,1)) / SQRT(DOT_PRODUCT(vqq(:,1),vqq(:,1)))
>         ELSE
>            mfp_q_ful(imode,iq_ful_red) = 0.0d0
>         ENDIF
>         !
>         ! save phdrag components of each q
>         IF (my_pool_id .EQ. ionode_id) THEN 
>            !
>            !
>            WRITE (22222,REC=(iq_ful_red-1)*nmodes+imode)  wf_all(imode,iq_irr_red), L44_q(1:3,1:3), L33_q(1:3,1:3)
>         !
>         ENDIF
>         !
>        ENDDO ! imodes
>     ENDDO ! iq_ful_red
>      !
>   ENDIF
>   !
>   !
152,154c330,338
<      L11(3,3) = 1.0d0
<      L12(3,3) = 1.0d0
<      L21(3,3) = 1.0d0
---
>      L11(3,3)   = 1.0d0
>      L11_h(3,3) = 1.0d0
>      L11_e(3,3) = 1.0d0
>      L12(3,3)   = 1.0d0
>      L12_h(3,3) = 1.0d0
>      L12_e(3,3) = 1.0d0
>      L21(3,3)   = 1.0d0
>      L21_h(3,3) = 1.0d0
>      L21_e(3,3) = 1.0d0
155a340,342
>      L33(3,3) = 1.0d0
>      L3i(3,3) = 1.0d0
>      L44(3,3) = 1.0d0
162,164c349,392
<   mob = (L11/ncarrier/1.602176565d-19) / 100.0d0 ! [cm^2/V/s]   ! -1.0 -> 1.0 05252017
<   cod = L11                                     ! [1/Ohm/m]    ! -1.0 -> 1.0 05252017
<   inv_cod = imat(cod)
---
>   IF (nptype .NE. 'p' .AND. nptype .NE. 'n') THEN
>      !
>     IF ((L11_h(1,1)*L11_h(2,2)*L11_h(3,3) + L11_h(1,2)*L11_h(2,3)*L11_h(3,1) + L11_h(1,3)*L11_h(3,2)*L11_h(2,1) - L11_h(1,3)*L11_h(2,2)*L11_h(3,1) - L11_h(2,3)*L11_h(3,2)*L11_h(1,1) - L11_h(3,3)*L11_h(1,2)*L11_h(2,1)) .NE. 0.0d0) THEN
>      inv_L11_h = imat(L11_h)
>     ELSE
>      inv_L11_h = 0.0d0
>     ENDIF
>     IF ((L11_e(1,1)*L11_e(2,2)*L11_e(3,3) + L11_e(1,2)*L11_e(2,3)*L11_e(3,1) + L11_e(1,3)*L11_e(3,2)*L11_e(2,1) - L11_e(1,3)*L11_e(2,2)*L11_e(3,1) - L11_e(2,3)*L11_e(3,2)*L11_e(1,1) - L11_e(3,3)*L11_e(1,2)*L11_e(2,1)) .NE. 0.0d0) THEN
>      inv_L11_e = imat(L11_e)
>     ELSE
>      inv_L11_e = 0.0d0
>     ENDIF
>      !
>   ELSEIF (nptype .EQ. 'p') THEN
>      !L33
>      inv_L11_h = imat(L11_h)
>      inv_L11_e = 0.0d0
>      !
>   ELSEIF (nptype .EQ. 'n') THEN
>      !
>      inv_L11_h = 0.0d0
>      inv_L11_e = imat(L11_e)
>      !
>   ENDIF
>   !
>   cod_h = L11_h                                      ! [1/Ohm/m]
>   cod_e = L11_e 
>   cod = L11    
>   !
>   IF (h_carr .NE. 0.0d0) THEN
>      mob_h = L11_h/(h_carr) / 1.60217662089d-19 / 100.0d0      ! [cm^2/V/s]
>   ELSE
>      mob_h = 0.0d0
>   ENDIF
>   !
>   IF (e_carr .NE. 0.0d0) THEN
>      mob_e = L11_e/(e_carr) / 1.60217662089d-19 / 100.0d0
>   ELSE
>      mob_e = 0.0d0
>   ENDIF
>   !
>   mob   = (h_carr*mob_h+e_carr*mob_e)/(h_carr+e_carr) !
>  ! mob = (L11/ndoping/1.602176565d-19) / 100.0d0 ! [cm^2/V/s]   ! -1.0 -> 1.0 05252017
>  ! cod = L11                                     ! [1/Ohm/m]    ! -1.0 -> 1.0 05252017
166a395,396
>   seb_e = MATMUL(inv_L11_e,L12_e) * 1.0d+6                ! [uV/K]
>   seb_h = MATMUL(inv_L11_h,L12_h) * 1.0d+6                ! [uV/K]
169c399,408
<   loz = MATMUL(etc,inv_cod)/temp * kB           ! [W*Ohm/K^2]
---
>   loz = MATMUL(etc,inv_L11)/temp * kB           ! [W*Ohm/K^2]
>   sltc = L3i                                     ! [W/m/K]
>   ltc = L33
>   btc = MATMUL(MATMUL(MATMUL(MATMUL(L21_e,inv_L11_e),L11_h)-L21_h,inv_L11),L12_e) + &
>         MATMUL(MATMUL(MATMUL(MATMUL(L21_h,inv_L11_h),L11_e)-L21_e,inv_L11),L12_h) ! [W/m/K]
>   spd = MATMUL(inv_L11,L44) * 1.0d+6            ! [uV/K]
>   spd_k = MATMUL(inv_L11,L44_e) * 1.0d+6            ! [uV/K]
>   spd_x = MATMUL(inv_L11,L44_x) * 1.0d+6            ! [uV/K]
>   spd_l = MATMUL(inv_L11,L44_l) * 1.0d+6            ! [uV/K]
>   spd_g = MATMUL(inv_L11,L44_g) * 1.0d+6            ! [uV/K]
171a411,412
>   transpt(:,:,16)  = mob_e(:,:)
>   transpt(:,:,17)  = mob_h(:,:)
172a414,415
>   transpt(:,:,18)  = cod_e(:,:)
>   transpt(:,:,19)  = cod_h(:,:)
174a418,419
>   transpt(:,:,20) = seb_e(:,:)
>   transpt(:,:,21) = seb_h(:,:)
177a423,430
>   transpt(:,:,8) = ltc(:,:)
>   transpt(:,:,9) = sltc(:,:)
>   transpt(:,:,10) = btc(:,:)
>   transpt(:,:,11) = spd(:,:)
>   transpt(:,:,12) = spd_k(:,:)
>   transpt(:,:,13) = spd_x(:,:)
>   transpt(:,:,14) = spd_l(:,:)
>   transpt(:,:,15) = spd_g(:,:)
181a435,436
>   IF (my_pool_id .EQ. ionode_id) CLOSE (22222)
>   IF (my_pool_id .EQ. ionode_id) CLOSE (33333)
Only in ./: bte_transpt.o
Only in ./: bte_var.mod
Only in ./: change.sh
Only in ./: check_deps.sh
Only in ./: close_epw.o
diff ./constants_epw.f90 ../../epw-qian/src/constants_epw.f90
53a54
>   REAL(KIND=DP), PARAMETER :: au2ps   = 4.8377687d-5    ! AU to picosecond
Only in ./: constants_epw.mod
Only in ./: constants_epw.o
Only in ./: control_epw.mod
Only in ./: createkmap.o
Only in ./: create_mesh.o
Only in ./: dasmio.o
Only in ./: deallocate_eliashberg.o
Only in ./: deallocate_epw.o
Only in ./: dif
Only in ./: distribution.o
Only in ./: dmebloch2wan.o
Only in ./: dmewan2bloch.o
Only in ./: dvanqq2.o
Only in ./: dvqpsi_us3.o
Only in ./: dvqpsi_us_only3.o
diff ./dynbloch2wan.f90 ../../epw-qian/src/dynbloch2wan.f90
76,77d75
<   COMPLEX(KIND=DP)         :: ddyn_l(3,3*nat,3*nat)
< 
83,84c81
<         !  NOTE: is this wrong using czero?
<         CALL rgd_blk (nq1,nq2,nq3,nat,dynq(1,1,ik),1,1,ddyn_l,xk(:,ik), &  !xk has to be in cart. coord.
---
>         CALL rgd_blk (nq1,nq2,nq3,nat,dynq(1,1,ik),czero,xk(:,ik), &  !xk has to be in cart. coord.
Only in ./: dynbloch2wan.o
diff ./dynwan2bloch.f90 ../../epw-qian/src/dynwan2bloch.f90
172c172
<      CALL rgd_blk (nq1,nq2,nq3,nat,chf,1,1,ddyn_l,xq, &  !xq has to be in 2pi/a
---
>      CALL rgd_blk (nq1,nq2,nq3,nat,chf,ddyn_l,xq, &  !xq has to be in 2pi/a
245,470d244
<   !--------------------------------------------------------------------------
<   SUBROUTINE dynwan2bloch_s ( nbnd, nrr, irvec, ndegen, xq, cuf, eig, vph, ntemp, ndope)
<   !--------------------------------------------------------------------------
<   !
<   ! note: this copied version of dynwan2bloch takes into account the
<   !       screening effect
<   !
<   ! ERROR: only cuf, eig are updated, ddyn_l, vph not updated
<   !
<   !--------------------------------------------------------------------------
<   !
< #include "f_defs.h"
<   USE kinds,     ONLY : DP
<   USE pwcom,     ONLY : at, bg, omega
<   USE phcom,     ONLY : nq1, nq2, nq3
<   USE cell_base, ONLY : alat
<   USE ions_base, ONLY : amass, tau, nat, ityp
<   USE elph2,     ONLY : epsi, zstar, ifc
<   USE epwcom,    ONLY : lpolar, vg_ph
<   USE constants_epw, ONLY : pi, twopi, ci, czero
<   implicit none
<   !
<   !  input variables
<   !
<   integer :: nbnd, nrr, irvec (3, nrr), ndegen (nrr), ntemp, ndope
<   ! number of bands (possibly of the optimal subspace)
<   ! kpoint number for the interpolation
<   ! record length and unit for direct write of rotation matrix
<   ! number of WS points, crystal coordinates, degeneracy
<   !
<   ! Hamiltonian in wannier basis
<   !
<   real(kind=DP) :: xq (3)
<   ! kpoint coordinates for the interpolation
<   !
<   ! output variables
<   !
<   real(kind=DP) :: eig (nbnd, ntemp, ndope)
<   ! interpolated hamiltonian eigenvalues for this kpoint
<   complex(kind=DP) :: cuf(nbnd, nbnd, ntemp, ndope)
<   ! Rotation matrix, fine mesh
<   !
<   ! variables for lapack ZHPEVX
<   !
<   integer :: neig, info, ifail( nbnd ), iwork( 5*nbnd )
<   real(kind=DP) :: w( nbnd ), rwork( 7*nbnd )
<   complex(kind=DP) :: champ( nbnd*(nbnd+1)/2, ntemp, ndope ), &
<     cwork( 2*nbnd ), cz( nbnd, nbnd)
<   !
<   ! work variables
<   !
<   complex(kind=DP) :: chf(nbnd, nbnd, ntemp, ndope)
<   ! Hamiltonian in Bloch basis, fine mesh
<   integer :: ibnd, jbnd, ir, na, nb, itemp, idope
<   real(kind=DP) :: rdotk, massfac
<   complex(kind=DP) :: cfac
<   !
<   !
<   ! THL
<   REAL(KIND=DP), PARAMETER :: eps = 1.0d-6
<   INTEGER, PARAMETER       :: nrwsx = 200
<   ! the maximun number of nearest neighbor
<   INTEGER                  :: nrws             
<   ! number of nearest neighbor
<   REAL(KIND=DP)            :: atws(3,3), rws(0:3,nrwsx), r(3), r_ws(3), weight
<   ! lattice vector for WS initialization
<   ! nearest neighbor list, rws(0,*) = norm^2
<   COMPLEX(KIND=DP)         :: ddyn_s(3,nbnd,nbnd), ddyn_l(3,nbnd,nbnd), ddyn(3,nbnd,nbnd)
<   ! short-range part of derivative of DM
<   ! long-range (non-analytical) part of derivative of DM
<   REAL(KIND=DP)            :: vph(3,nbnd,ntemp,ndope)
<   INTEGER                  :: i, j, k, n1, n2, n3, m1, m2, m3, mu, nu
<   REAL(KIND=DP), EXTERNAL  :: wsweight
<   !
<   !
<   CALL start_clock ( 'DynW2B' )
<   !
<   !
<   !------------------------------------------------------------------------------------------------
<   ! THL: Compute chf (dynamical matrix) through ifc. The obtained phonon frequency now is 
<   !      identical with that from matdyn.x
<   !------------------------------------------------------------------------------------------------
<   !
<   !
<   atws(:,1) = at(:,1)*DBLE(nq1)
<   atws(:,2) = at(:,2)*DBLE(nq2)
<   atws(:,3) = at(:,3)*DBLE(nq3)
<   CALL wsinit(rws,nrwsx,nrws,atws)
<   !
<   ! Fourier interpolation 
<   chf = czero
<   ddyn_s = czero
<   ddyn_l = czero
<   !
<   DO na = 1,nat
<      DO nb = 1,nat
<         !
<         DO n1 = -2*nq1,2*nq1
<            DO n2 = -2*nq2,2*nq2
<               DO n3 = -2*nq3,2*nq3
<                  !
<                  DO k = 1,3
<                     r(k) = n1*at(k,1)+n2*at(k,2)+n3*at(k,3)
<                     r_ws(k) = r(k) + tau(k,na) - tau(k,nb)
<                  ENDDO
<                  weight = wsweight(r_ws,rws,nrws)
<                  !
<                  IF (weight .GT. 0.0d0) THEN
<                     !
<                     m1 = MOD(n1+1,nq1)
<                     IF(m1.LE.0) m1=m1+nq1
<                     m2 = MOD(n2+1,nq2)
<                     IF(m2.LE.0) m2=m2+nq2
<                     m3 = MOD(n3+1,nq3)
<                     IF(m3.LE.0) m3=m3+nq3
<                     !
<                     DO i = 1,3
<                        DO j = 1,3
<                           !
<                           mu = (na-1)*3+i
<                           nu = (nb-1)*3+j
<                           !
<                           rdotk = twopi * (  xq(1)*DBLE(n1) + xq(2)*DBLE(n2) + xq(3)*DBLE(n3) )
<                           cfac = EXP(-ci*rdotk)*weight
<                           !
<                           chf(mu,nu,:,:) = chf(mu,nu,:,:) + cfac * REAL(ifc(m1,m2,m3,mu,nu))
<                           !
<                           IF (vg_ph .EQ. 'matrix') ddyn_s(:,mu,nu) = ddyn_s(:,mu,nu) - ci * alat * r(:) * cfac * REAL(ifc(m1,m2,m3,mu,nu))
<                           !
<                        ENDDO
<                     ENDDO
<                     !
<                  ENDIF
<                  !
<               ENDDO
<            ENDDO
<         ENDDO  
<         !
<      ENDDO 
<   ENDDO 
<   !
<   !
<   ! bring xq in cart. coordinates (needed for rgd_blk call)
<   CALL cryst_to_cart (1, xq, bg, 1)
<   !
<   !  add the long-range term to D(q)
<   IF (lpolar) THEN
<      CALL rgd_blk (nq1,nq2,nq3,nat,chf,ntemp,ndope,ddyn_l,xq, &  !xq has to be in 2pi/a
<                   tau,epsi,zstar,bg,omega,+1.d0)
<    !WRITE (6,'(a)') "Done rigid"
<   ENDIF
<   !
<   !  divide by the square root of masses 
<   !
<   DO na = 1, nat
<    DO nb = 1, nat
<       massfac = 1.d0 / sqrt ( amass(ityp(na)) * amass(ityp(nb)) )
<       !
<       chf(3*(na-1)+1:3*na, 3*(nb-1)+1:3*nb, :,:) = &
<          chf(3*(na-1)+1:3*na, 3*(nb-1)+1:3*nb, :,:) * massfac
<       ! 
<    ENDDO
<   ENDDO
<   !
<   ! bring xq back to crystal coordinates
<   CALL cryst_to_cart (1, xq, at, -1)
<   !
<   !---------------------------------------------------------------------
<   !  STEP 4: diagonalize smooth Hamiltonian on k points of the fine grid
<   !---------------------------------------------------------------------
<   !
<   ! champ: complex hamiltonian packed (upper triangular part for zhpevx)
<   ! after hermitian-ization
<   !
<   DO jbnd = 1, nbnd
<    DO ibnd = 1, jbnd
<       champ (ibnd + (jbnd - 1) * jbnd/2, :, : ) = &
<       ( chf ( ibnd, jbnd, :, :) + conjg ( chf ( jbnd, ibnd, :, :) ) ) / 2.d0
<    ENDDO
<   ENDDO
<   !
<   !
<   do itemp = 1, ntemp
<      do idope = 1, ndope
<         CALL zhpevx ('V', 'A', 'U', nbnd, champ(:,itemp,idope) , 0.0, 0.0, &
<                      0, 0,-1.0, neig, w, cz, nbnd, cwork, &
<                      rwork, iwork, ifail, info)
<         !
<         ! rotation matrix and Ham eigenvalues
<         ! [in Ry, mind when comparing with wannier code]
<         !
<         cuf(:,:,itemp,idope) = cz
<         eig(:,itemp,idope) = w
<      enddo
<   enddo
<   !
<   !
<   ! THL : Compute the phonon group velocity from dynamical matrix
<   !
<   IF (vg_ph .EQ. 'matrix') THEN
<      !
<      ddyn = ddyn_s + ddyn_l
<      !  
<      DO na = 1, nat
<         DO nb = 1, nat
<            massfac = 1.d0 / SQRT (amass(ityp(na))*amass(ityp(nb)))
<            ddyn(:,3*(na-1)+1:3*na,3*(nb-1)+1:3*nb) = ddyn(:,3*(na-1)+1:3*na,3*(nb-1)+1:3*nb) * massfac
<         ENDDO
<      ENDDO
<      !
<      DO ibnd = 1, nbnd
<         DO i = 1, 3
<            do itemp = 1, ntemp
<               do idope = 1, ndope
<                  vph(i,ibnd,itemp,idope) = REAL( DOT_PRODUCT( cuf(:,ibnd,itemp,idope) , MATMUL(ddyn(i,:,:),cuf(:,ibnd,itemp,idope)) ) ) / (2.0d0*SQRT(ABS(eig(ibnd,itemp,idope))))
<               enddo
<            enddo
<         ENDDO
<      ENDDO
<      !
<   ENDIF
<   !
<   CALL stop_clock ( 'DynW2B' )
<   !   
<   END SUBROUTINE dynwan2bloch_s
<   !
Only in ./: dynwan2bloch.o
diff ./edos.f90 ../../epw-qian/src/edos.f90
45,46c45
<   USE elph2,         ONLY : vbnd_emax, cbnd_emin, ef_m, delta_egap, nrr_k, irvec, &
<                             vbnd_num, ndegen_k, chw
---
>   USE elph2,         ONLY : vbnd_emax, cbnd_emin, ef_m, delta_egap, nrr_k, irvec, ndegen_k, chw, vbnd_num
57c56
<   REAL(KIND=DP), PARAMETER      :: E_extent = 3.5d0/ryd2ev, deltaE = 1.0d-3/ryd2ev
---
>   REAL(KIND=DP), PARAMETER      :: E_extent = 0.8d0/ryd2ev, deltaE = 1.0d-4/ryd2ev
102,104d100
<      !DO ibnd = 1, nbndsub
<      !   IF (et(ibnd,ik) .GT. ef_m) et(ibnd,ik) = et(ibnd,ik) + delta_egap
<      !ENDDO
108d103
<      ! 
126,127c121,122
<   E_min  = E_cen - (0.5d0 * (cbnd_emin - vbnd_emax) + E_extent) 
<   E_max  = E_cen + (0.5d0 * (cbnd_emin - vbnd_emax) + E_extent) 
---
>   E_min  = E_cen - (0.5d0 * ABS(cbnd_emin - vbnd_emax) + E_extent) 
>   E_max  = E_cen + (0.5d0 * ABS(cbnd_emin - vbnd_emax) + E_extent) 
Only in ./: edos.mod
Only in ./: edos.o
Only in ./: eimpbloch2wane.o
diff ./eimpbloch2wanp.f90 ../../epw-qian/src/eimpbloch2wanp.f90
26c26
<   USE io_global,     ONLY : ionode_id
---
>   USE io_global,     ONLY : ionode_id, stdout, ionode
61c61
<   IF (save_m_matw) THEN
---
>   !IF (save_m_matw) THEN
63,64c63,64
<      matwe_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwe_q'
<      OPEN (10011,FILE=matwe_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*nrk*DP,STATUS='old')
---
>    !  matwe_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwe_q'
>    !  OPEN (10011,FILE=matwe_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*nrk*DP,STATUS='old')
66,67c66,67
<      matwp_k_tmp_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_k_tmp'
<      OPEN (20022,FILE=matwp_k_tmp_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*DP,STATUS='replace')
---
>    !  matwp_k_tmp_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_k_tmp'
>    !  OPEN (20022,FILE=matwp_k_tmp_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*DP,STATUS='replace')
69,70c69,70
<      matwp_q_tmp_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_q_tmp'
<      OPEN (30033,FILE=matwp_q_tmp_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*nrk*DP,STATUS='replace')
---
>    !  matwp_q_tmp_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_q_tmp'
>    !  OPEN (30033,FILE=matwp_q_tmp_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*nrk*DP,STATUS='replace')
72c72
<   ENDIF
---
>   !ENDIF
79a80,84
>  ! WRITE (stdout,'(/5x,a,es17.10)') 'eimpmatwe(1,1,1,1) =', ABS(eimpmatwe(1,1,1,1))
>  ! WRITE (stdout,'(/5x,a,es17.10)') 'eimpmatwe(1,1,1,2) =', ABS(eimpmatwe(1,1,1,2))
>  ! WRITE (stdout,'(/5x,a,es17.10)') 'eimpmatwe(1,1,1,3) =', ABS(eimpmatwe(1,1,1,3))
>  ! WRITE (stdout,'(/5x,a,es17.10)') 'eimpmatwe(1,1,2,1) =', ABS(eimpmatwe(1,1,2,1))
>   !
82c87
<     eimpmatwp_q = (0.0d0,0.0d0)
---
>     !eimpmatwp_q = (0.0d0,0.0d0)
89,92c94,97
<        IF (save_m_matw) THEN
<           READ (10011,REC=iqc) eimpmatwe_q(1:nbnd,1:nbnd,1:nrk)
<           eimpmatwp_q(:,:,:) = eimpmatwp_q(:,:,:) + cfac * eimpmatwe_q(:,:,:)
<        ELSE
---
>        !IF (save_m_matw) THEN
>          ! READ (10011,REC=iqc) eimpmatwe_q(1:nbnd,1:nbnd,1:nrk)
>         !  eimpmatwp_q(:,:,:) = eimpmatwp_q(:,:,:) + cfac * eimpmatwe_q(:,:,:)
>        !ELSE
94c99,103
<        ENDIF
---
>     !
>    ! if (MOD(iqc,100) .EQ. 1) WRITE (stdout,'(/5x,a,es17.10)') 'Check: rdotk = ', ABS(rdotk)
>    ! if (MOD(iqc,100) .EQ. 1) WRITE (stdout,'(/5x,a,es17.10)') 'Check: cfac = ', ABS(cfac)
>    ! if (MOD(iqc,100) .EQ. 1) WRITE (stdout,'(/5x,a,es17.10)') 'eimpmatwe(1,1,1,iqc) =',ABS(eimpmatwe(1,1,1,iqc))
>       ! ENDIF
98c107,109
<     IF (save_m_matw) THEN
---
>    ! if (MOD(ir,100) .EQ. 1) WRITE (stdout,'(/5x,a,es17.10)') 'Check: eimpmatwp(1,1,1,ir) =', ABS(eimpmatwp(1,1,1,ir))
>     !
>     !IF (save_m_matw) THEN
100,102c111,113
<        DO irk = 1, nrk
<           WRITE (20022,REC=(irk-1)*nrr+ir) eimpmatwp_q(1:nbnd,1:nbnd,irk)
<        ENDDO
---
>      !  DO irk = 1, nrk
>       !    WRITE (20022,REC=(irk-1)*nrr+ir) eimpmatwp_q(1:nbnd,1:nbnd,irk)
>       ! ENDDO
104c115
<        WRITE (30033,REC=ir) eimpmatwp_q(1:nbnd,1:nbnd,1:nrk)
---
>       ! WRITE (30033,REC=ir) eimpmatwp_q(1:nbnd,1:nbnd,1:nrk)
106c117
<     ENDIF
---
>     !ENDIF
129,131c140,142
<         IF (save_m_matw) THEN
<            tmp = MAXVAL(ABS(eimpmatwp_q(:,:,ire)))
<         ELSE
---
>         !IF (save_m_matw) THEN
>         !   tmp = MAXVAL(ABS(eimpmatwp_q(:,:,ire)))
>         !ELSE
133c144
<         ENDIF
---
>         !ENDIF
155,156c166,167
<      matwp_k_tmp_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_k_tmp'
<      OPEN (40044,FILE=matwp_k_tmp_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*DP,STATUS='old')
---
>      !matwp_k_tmp_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_k_tmp'
>      !OPEN (40044,FILE=matwp_k_tmp_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*DP,STATUS='old')
158,159c169,170
<      matwp_k_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_k'
<      OPEN (50055,FILE=matwp_k_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*nrr*DP,STATUS='replace')
---
>      !matwp_k_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_k'
>      !OPEN (50055,FILE=matwp_k_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*nrr*DP,STATUS='replace')
161c172
<      DO irk = 1, nrk
---
>      !DO irk = 1, nrk
163,165c174,176
<         DO irq = 1, nrr
<            READ (40044,REC=irq+(irk-1)*nrr) eimpmatwp_k(1:nbnd,1:nbnd,irq)
<         ENDDO
---
>       !  DO irq = 1, nrr
>        !    READ (40044,REC=irq+(irk-1)*nrr) eimpmatwp_k(1:nbnd,1:nbnd,irq)
>         !ENDDO
167c178
<         WRITE(50055,REC=irk) eimpmatwp_k(1:nbnd,1:nbnd,1:nrr)
---
>         !WRITE(50055,REC=irk) eimpmatwp_k(1:nbnd,1:nbnd,1:nrr)
169c180
<      ENDDO
---
>      !ENDDO
171c182
<      CALL SYSTEM ('rm '//TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_k_tmp')
---
>      !CALL SYSTEM ('rm '//TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_k_tmp')
174,175c185,186
<      matwp_q_tmp_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_q_tmp'
<      OPEN (40044,FILE=matwp_q_tmp_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*nrk*DP,STATUS='old')
---
>      !matwp_q_tmp_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_q_tmp'
>      !OPEN (40044,FILE=matwp_q_tmp_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*nrk*DP,STATUS='old')
177,178c188,189
<      matwp_q_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_q'
<      OPEN (90099,FILE=matwp_q_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*nrk*DP,STATUS='replace')
---
>      !matwp_q_ufmt = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_q'
>      !OPEN (90099,FILE=matwp_q_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nbnd*nbnd*nrk*DP,STATUS='replace')
180c191
<      DO irq = 1, nrr
---
>      !DO irq = 1, nrr
182c193
<         READ (40044,REC=irq) eimpmatwp_q(1:nbnd,1:nbnd,1:nrk)
---
>       !  READ (40044,REC=irq) eimpmatwp_q(1:nbnd,1:nbnd,1:nrk)
184c195
<         WRITE (90099,REC=irq) eimpmatwp_q(1:nbnd,1:nbnd,1:nrk)
---
>        ! WRITE (90099,REC=irq) eimpmatwp_q(1:nbnd,1:nbnd,1:nrk)
186c197
<      ENDDO
---
>      !ENDDO
188c199
<      CALL SYSTEM ('rm '//TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_q_tmp')
---
>      !CALL SYSTEM ('rm '//TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_q_tmp')
190,193c201,204
<      CLOSE (10011)
<      CLOSE (20022)
<      CLOSE (40044)
<      CLOSE (90099)
---
>      !CLOSE (10011)
>      !CLOSE (20022)
>      !CLOSE (40044)
>      !CLOSE (90099)
195c206
<   ELSE
---
>   !ELSE
Only in ./: eimpbloch2wanp.o
diff ./eimpmat_shuffle.f90 ../../epw-qian/src/eimpmat_shuffle.f90
31c31
<   USE elph2,     ONLY : dvimp, eimpmatq, el_imp_mat, bg_max
---
>   USE elph2,     ONLY : dvimp, eimpmatq, el_imp_mat
99c99
<   CALL elimp_shuffle (dvimp, gmapsym, eigv, isym, invs0, xq0, iq, timerev)
---
>   CALL elimp_shuffle (dvimp, gmapsym, eigv, isym, invs0, xq0, timerev)
128c128
<   SUBROUTINE elimp_shuffle (dvimp, gmapsym, eigv, isym, invs, xq0, iq, timerev)
---
>   SUBROUTINE elimp_shuffle (dvimp, gmapsym, eigv, isym, invs, xq0, timerev)
164,166c164
<                             nfftmesh, scell_vol, rp, imp_meshmap, &
<                             bg_max, dvGr, map_l2g, map_g2l, dvimp_q, &
<                             ng_max
---
>                             nfftmesh, scell_vol, rp, imp_meshmap
185c183
<        ipooltmp, nkq_abs, ipol, imesh, iq
---
>        ipooltmp, nkq_abs, ipol, imesh
188,190c186
<                                    dvimpevc(:,:), evq_rmesh(:,:), &
<                                    dvevc(:,:), eemat(:,:,:), eemat_check(:,:,:), &
<                                    eemat_r(:,:,:), eimpmat_r(:,:)
---
>                                    dvimpevc(:,:), evq_rmesh(:,:)
222,225c218
<   integer  :: ir, ir_evc, ind_g, igx, igy, igz, &
<               index_igk(dffts%nnr), ig_shift, &
<               integration_method
<   integer, allocatable :: map_kq2k(:,:)
---
>   integer  :: ir, ir_evc
227,230c220,222
<               xk_gamma(3), xk_x(3), xk_l(3), norm_
<   complex(DP) :: evc_check(npwx*npol,nbnd), &
<                  evc_remap(npwx*npol)
<   logical :: xk_find, x_find, gamma_find, l_find
---
>               xk_gamma(3), xk_x(3), norm_
>   complex(DP) :: evc_check(npwx*npol,nbnd)
>   logical :: xk_find, x_find, gamma_find
233,234c225
<   real(kind=DP) :: t1, t2, t3, t4, t5, tt1, tt2, tt3, tt4, &
<                    t4_1, t4_2, t4_3, t4_4
---
>   real(kind=DP) :: t1, t2, t3, t4, t5, tt1, tt2, tt3, tt4
241,246d231
<   IF ( .not. ALLOCATED (eemat) ) ALLOCATE ( eemat( nbnd, nbnd, ng_max) )
<   IF ( .not. ALLOCATED (eemat_check) ) ALLOCATE ( eemat_check( nbnd, nbnd, ng_max) )
<   IF ( .not. ALLOCATED (eemat_r) ) ALLOCATE ( eemat_r( nbnd, nbnd, ng_max) )
<   IF ( .not. ALLOCATED (dvevc) )    ALLOCATE ( dvevc(dffts%nnr, npol) )
<   IF ( .not. ALLOCATED (eimpmat_r) ) ALLOCATE ( eimpmat_r( nbnd, nbnd) )
<   allocate (map_kq2k (npwx*npol,(2*bg_max+1)**3))
251,252d235
<   dvevc(:,:) = (0.d0,0.d0)
<   eimpmat_r(:,:) = (0.d0,0.d0)
293d275
<   xk_l     = (/-0.5d0,0.5d0,-0.5d0/)
439c421
<      ! identify band edge k-point
---
>      ! wave-function check (JZ)
442a425,433
>         ! evc( npwx*npol, nbnd )
>         evc_check = evc
>         !
>         ibnd = 10
>         CALL cft_wave (evc_check(:, ibnd), aux1, +1)
>         !
> !        write(stdout,*) ' inside elimp:, dffts%nnr, npol =',dffts%nnr, npol
> !        write(stdout,*) ' xk =', xk(:,ik)
> 
447c438
<            write(*,*) ' find gamma =', xk(:,ik), ' @ pool#', my_pool_id
---
> !           write(*,*) ' find gamma =', xk(:,ik), ' @ pool#', my_pool_id
454c445
<            write(*,*) ' find X =', xk(:,ik), ' @ pool#', my_pool_id
---
> !           write(*,*) ' find X =', xk(:,ik), ' @ pool#', my_pool_id
457,479d447
<         l_find = .false.
<         if ((abs(xk(1,ik)-xk_l(1))<1d-5) .and. (abs(xk(2,ik)-xk_l(2))<1d-5) .and. &
<             (abs(xk(3,ik)-xk_l(3))<1d-5)) then
<            l_find = .true.
<            write(*,*) ' find L =', xk(:,ik), ' @ pool#', my_pool_id
<         endif 
<         !
<      endif
<      !
<      ! wave-function check (JZ)
<      !
<      if (.false.) then
<         !
<         ! evc( npwx*npol, nbnd )
<         evc_check = evc
<         !
<         ibnd = 9
<         CALL cft_wave (evc_check(:, ibnd), aux1, +1)
<         !
< !        write(stdout,*) ' inside elimp:, dffts%nnr, npol =',dffts%nnr, npol
< !        write(stdout,*) ' xk =', xk(:,ik)
< 
<         !
488c456
<         if (l_find .and. (.true.)) then
---
>         if (x_find .and. (.false.)) then
509a478,480
>      ! --------------------------------------------------
>      !   Calculation of the matrix element
>      ! --------------------------------------------------
516,528c487,489
<      !   Calculation of the matrix element
<      ! =================================================================================
< 
<      integration_method = 1   ! 1: real space, 2: reciprocal space (faster)
< 
<      if (integration_method == 1) then
< 
<         ! ===================================================
<         ! real-space method - matrix element calculation
<         ! ===================================================
<         !
<         ! IMPORTANT NOTE: this brings xq to first-BZ, but it is only centered
<         ! around Gamma, not yet fully symmetric
---
>      !
>      ! !IMPORTANT NOTE! this brings xq to first-BZ, but it is only centered
>      ! around Gamma, not yet fully symmetric
530,534c491
<         ! NOTE: the q-point below should use xq, xq0 is only the first q in the star
<         xq_cart(1) = xq(1) !- NINT(xq(1))
<         xq_cart(2) = xq(2) !- NINT(xq(2))
<         xq_cart(3) = xq(3) !- NINT(xq(3))
<         !
---
>      ! NOTE: the q-point below should use xq, xq0 is only the first q in the star
536,538c493,497
<         CALL cryst_to_cart ( 1, xq_cart, bg, 1 )   ! xq_cart in [2*pi/alat]
< 
<         ! supercell / unit_cell volume multiple
---
>      xq_cart(1) = xq(1) !- NINT(xq(1))
>      xq_cart(2) = xq(2) !- NINT(xq(2))
>      xq_cart(3) = xq(3) !- NINT(xq(3))
>      !
>      CALL cryst_to_cart ( 1, xq_cart, bg, 1 )   ! xq_cart in [2*pi/alat]
540,544c499,506
<         sc_un_ratio = nint(scell_vol/omega)
<         if ((ik == 1) .and. (xq(1)*xq(2)*xq(3) < 1e-5)) &
<            write(stdout,*) '  sc_un_ratio =', sc_un_ratio
<         !
<         !  calculate dvscf_q*psi_k
---
>      ! supercell / unit_cell volume multiple
>      sc_un_ratio = nint(scell_vol/omega)
>      if ((ik == 1) .and. (xq(1)*xq(2)*xq(3) < 1e-5)) &
>         write(stdout,*) '  sc_un_ratio =', sc_un_ratio
>      !
>      !  calculate dvscf_q*psi_k
>      !
>      DO ibnd = 1, nbnd !, incr
546,551c508,511
<         DO ibnd = 1, nbnd !, incr
<            !
<            ! this transforms evc/evq(k) into evc_r/evq_r(r) with mesh given by nffts%nr1..3
<            ! NOTE: evc(k) seems to represent only the periodic part u(r), JW
<            CALL cft_wave (evc(:, ibnd), aux1, +1)
<            evc_r(:,:,ibnd) = aux1(:,:)
---
>         ! this transforms evc/evq(k) into evc_r/evq_r(r) with mesh given by nffts%nr1..3
>         ! NOTE: evc(k) seems to represent only the periodic part u(r), JW
>         CALL cft_wave (evc(:, ibnd), aux1, +1)
>         evc_r(:,:,ibnd) = aux1(:,:)
553,556c513,516
<            CALL cft_wave_2 (evq(:, ibnd), aux1, +1)
<            evq_r(:,:,ibnd) = aux1(:,:)
<            !
<            ! rotate aux1 based on aux1(r=0) to zero phase
---
>         CALL cft_wave_2 (evq(:, ibnd), aux1, +1)
>         evq_r(:,:,ibnd) = aux1(:,:)
>         !
>         ! rotate aux1 based on aux1(r=0) to zero phase
565,598d524
<            !
<            ! normalize for later integration on discrete mesh
<            ! 1) we find out |phi|^2 integration in a unit cell
<            ! 2) we properly normalize phi to require |phi|^2 integration in a unit cell gives one
<            !
<            norm_evc = 0.d0
<            norm_evq = 0.d0
<            do imesh = 1, nfftmesh
<               norm_evc = norm_evc + abs(evc_r(imp_meshmap(imesh,4),1,ibnd))**2.d0
<               norm_evq = norm_evq + abs(evq_r(imp_meshmap(imesh,4),1,ibnd))**2.d0
<            enddo
< 
<            evc_r(:,:,ibnd) = evc_r(:,:,ibnd) / sqrt(norm_evc/sc_un_ratio)
<            evq_r(:,:,ibnd) = evq_r(:,:,ibnd) / sqrt(norm_evq/sc_un_ratio)
<            !
<         ENDDO
<    
<         call cpu_time(t3)
< 
<         if (x_find .and. .false.) then
<            !
<            ibnd = 10
<            ir_evc = imp_meshmap(14522,4)
<            write(*,*) ' check meshmap(14522):', imp_meshmap(14522,1:4)
< 
<            write(*,'(a,3(1x,f15.7))') ' check_evc_r at xk =', xk(:,ik)
<            write(*,*) evc_r(ir_evc,1,ibnd)
< 
<            write(*,'(a,3(1x,f15.7))') ' check_evc_r at (xq, xq0) =', xq, xq0
<            write(*,*) evq_r(ir_evc,1,ibnd)
<            write(*,*) ' module: ',conjg(evq_r(ir_evc,1,ibnd))*evc_r(ir_evc,1,ibnd)
<  
<            write(*,*) ' check dvimp(14522):', dvimp(14522)
<         endif
600,606c526,528
<         ! calculate eimpmat(j,i)=<psi_{k+q,j}|dV_imp*psi_{k,i}> for this perturbation
<         ! should check normalization: if evc/evq_r goes to 1, this reduces to plane
<         ! wave form
<         !
<         eimpmat = (0.d0, 0.d0)
<         dvimpevc = (0.d0, 0.d0)
<         evq_rmesh = (0.d0, 0.d0)
---
>         ! normalize for later integration on discrete mesh
>         ! 1) we find out |phi|^2 integration in a unit cell
>         ! 2) we properly normalize phi to require |phi|^2 integration in a unit cell gives one
607a530,531
>         norm_evc = 0.d0
>         norm_evq = 0.d0
609,626c533,534
<            !
<            ! NOTE: exp(-i*q*r) term is included
<            dvimpevc(imesh,1:nbnd)  = evc_r(imp_meshmap(imesh,4),1,1:nbnd) * dvimp(imesh) * &
<                                      exp(-ci*twopi*dot_product(xq_cart,rp(:,imesh)))
< 
<            ! TEST
< !           dvimpevc(imesh,1:nbnd)  = evc_r(imp_meshmap(imesh,4),1,1:nbnd)
< !                                     exp(-ci*twopi*dot_product(xq_cart,rp(:,imesh)))
< 
<            evq_rmesh(imesh,1:nbnd) = evq_r(imp_meshmap(imesh,4),1,1:nbnd)
<         enddo
<         !
< 
<         do jbnd = 1, nbnd
<            do ibnd = 1, nbnd
<                eimpmat (jbnd, ibnd) = eimpmat (jbnd, ibnd) + &
<                         ZDOTC (nfftmesh, evq_rmesh(1:nfftmesh, jbnd), 1, dvimpevc(1:nfftmesh, ibnd), 1)
<            enddo
---
>            norm_evc = norm_evc + abs(evc_r(imp_meshmap(imesh,4),1,ibnd))**2.d0
>            norm_evq = norm_evq + abs(evq_r(imp_meshmap(imesh,4),1,ibnd))**2.d0
628,629d535
<         !
<      else
631,633c537,538
<         ! ===================================================
<         ! reciprocal-space method - matrix element calculation
<         ! ===================================================
---
> !        evc_r(:,:,ibnd) = evc_r(:,:,ibnd) / sqrt(norm_evc/sc_un_ratio)
> !        evq_r(:,:,ibnd) = evq_r(:,:,ibnd) / sqrt(norm_evq/sc_un_ratio)
635c540,541
<         call cpu_time(t4_1)
---
>         evc_r(:,:,ibnd) = evc_r(:,:,ibnd) / sqrt(norm_evc)
>         evq_r(:,:,ibnd) = evq_r(:,:,ibnd) / sqrt(norm_evq)
637,659c543,546
<         ! normalize wavefunctions
< 
<         do ibnd = 1, nbnd
<            CALL cft_wave (evc(:, ibnd), aux1, +1)
<            evc_r(:,:,ibnd) = aux1(:,:)
< 
<            CALL cft_wave_2 (evq(:, ibnd), aux1, +1)
<            evq_r(:,:,ibnd) = aux1(:,:)
<            norm_evq = 0.d0
<            do imesh = 1, dffts%nnr
<               norm_evq = norm_evq + abs(evq_r(imesh,1,ibnd))**2.d0
<            enddo
<            evq_r(:,:,ibnd) = evq_r(:,:,ibnd)/sqrt(norm_evq)
<         enddo
< 
<         call cpu_time(t4_2)
< 
<         ! set up mapping between local and global G vector indices
< 
<         index_igk = 0
<         do ig = 1, npw
<            index_igk(igk(ig)) = ig
<         enddo
---
> !NOTE, for testing, ignore normalization
> !        norm_ = dffts%nnr
> !        evc_r(:,:,ibnd) = evc_r(:,:,ibnd) / sqrt(norm_) / sqrt(8.d0)
> !        evq_r(:,:,ibnd) = evq_r(:,:,ibnd) / sqrt(norm_) / sqrt(8.d0)
661,678c548,552
<         ind_g = 0
<         map_kq2k = 0
<         do igz = -bg_max, bg_max
<            do igy = -bg_max, bg_max
<               do igx = -bg_max, bg_max
<                  ind_g = ind_g + 1
<                  ig_shift = igz*dffts%nr2*dffts%nr1 + igy*dffts%nr1 + igx
< 
<                  do ig = 1, npwq
<                     if (((map_l2g(igkq(ig))-ig_shift) > 0) .and. ((map_l2g(igkq(ig))-ig_shift) < dffts%nnr)) then
<                        if (map_g2l(map_l2g(igkq(ig))-ig_shift) /= 0) then
<                           map_kq2k(ig,ind_g) = index_igk(map_g2l(map_l2g(igkq(ig))-ig_shift))
<                        endif
<                     endif
<                  enddo
<               enddo
<            enddo
<         enddo
---
>      ENDDO
>    
>      call cpu_time(t3)
> 
>      if (x_find .and. .false.) then
680c554,556
<         call cpu_time(t4_3)
---
>         ibnd = 10
>         ir_evc = imp_meshmap(14522,4)
>         write(*,*) ' check meshmap(14522):', imp_meshmap(14522,1:4)
682c558,559
<         ! calculate products of electron wave functions in reciprocal space
---
>         write(*,'(a,3(1x,f15.7))') ' check_evc_r at xk =', xk(:,ik)
>         write(*,*) evc_r(ir_evc,1,ibnd)
684,738c561,565
<         eemat_r = 0
<         do ibnd = 1, nbnd
<            !
<            ind_g = 0
<            do igz = -bg_max, bg_max
<               do igy = -bg_max, bg_max
<                  do igx = -bg_max, bg_max
<                     !
<                     ind_g = ind_g + 1
<                     ig_shift = igz*dffts%nr2*dffts%nr1 + igy*dffts%nr1 + igx
<                     !
<                     evc_remap = 0.d0
<                     do ig = 1, npwq
<                        if (map_kq2k(ig,ind_g) /= 0) &
<                           evc_remap(ig) = evc(map_kq2k(ig,ind_g),ibnd)
<                     enddo
<                     !
<                     do jbnd = 1, nbnd
<                        eemat_r(jbnd,ibnd,ind_g) = &
<                               ZDOTC (npwq, evq(1,jbnd), 1, evc_remap(1), 1)
<                     enddo
<                        ! test
< !                       if ((ibnd==1) .and. (jbnd==1) .and. (ig==1)) then
< !                          write(stdout,*) ' --- G test ------'
< !                          write(stdout,*) ' G:', igx*bg(:,1)+igy*bg(:,2)+igz*bg(:,3)
< !                          write(stdout,*) ' G for k+q:', g(:,igkq(ig))
< !                          write(stdout,*) ' G for k:', g(:,map_g2l(map_l2g(igkq(ig))-ig_shift))
< !                       endif
<                     !
<                  enddo
<               enddo
<            enddo
<         enddo
< 
<         ! test impurity matrix element calculation
<         !
<         eimpmat_r = (0.d0, 0.d0)
<         do jbnd = 1, nbnd
<            do ibnd = 1, nbnd
<               ind_g = 0
<               do igz = -bg_max, bg_max
<                  do igy = -bg_max, bg_max
<                     do igx = -bg_max, bg_max
<                        ind_g = ind_g + 1
<                        eimpmat_r (jbnd,ibnd) = eimpmat_r (jbnd,ibnd) + &
<                                dvimp_q(iq,igx+bg_max+1,igy+bg_max+1,igz+bg_max+1) * eemat_r(jbnd,ibnd,ind_g)
<                     enddo
<                  enddo
<               enddo
<            enddo
<         enddo
<         eimpmat = eimpmat_r
<         !
<         call cpu_time(t4_4)
<         !
---
>         write(*,'(a,3(1x,f15.7))') ' check_evc_r at (xq, xq0) =', xq, xq0
>         write(*,*) evq_r(ir_evc,1,ibnd)
>         write(*,*) ' module: ',conjg(evq_r(ir_evc,1,ibnd))*evc_r(ir_evc,1,ibnd)
>  
>         write(*,*) ' check dvimp(14522):', dvimp(14522)
740d566
< 
742,746c568,596
<      ! the following uses traditional integration over r-space, which has been
<      ! checked to give same result as the reciprocal space integration above
<      !
<      if (.false.) then
<         !
---
>      ! calculate eimpmat(j,i)=<psi_{k+q,j}|dV_imp*psi_{k,i}> for this perturbation
>      ! should check normalization: if evc/evq_r goes to 1, this reduces to plane
>      ! wave form
>      !
>      eimpmat = (0.d0, 0.d0)
>      dvimpevc = (0.d0, 0.d0)
>      evq_rmesh = (0.d0, 0.d0)
>      !
>      do imesh = 1, nfftmesh
>         !
>         ! NOTE: exp(-i*q*r) term is included
>         dvimpevc(imesh,1:nbnd)  = evc_r(imp_meshmap(imesh,4),1,1:nbnd) * dvimp(imesh) * &
>                                   exp(-ci*twopi*dot_product(xq_cart,rp(:,imesh)))
> 
>         ! TEST
> !        dvimpevc(imesh,1:nbnd)  = evc_r(imp_meshmap(imesh,4),1,1:nbnd)
> !                                  exp(-ci*twopi*dot_product(xq_cart,rp(:,imesh)))
> 
>         evq_rmesh(imesh,1:nbnd) = evq_r(imp_meshmap(imesh,4),1,1:nbnd)
>      enddo
>      !
> !     do jbnd = 1, nbnd
> !        do imesh = 1, nfftmesh
> !           eimpmat(jbnd,1:nbnd) = eimpmat(jbnd,1:nbnd) + &
> !                     conjg(evq_r(imp_meshmap(imesh,4),1,jbnd)) * dvimpevc(imesh,1:nbnd)
> !        enddo
> !     enddo
> 
>      do jbnd = 1, nbnd
748,777c598,599
<    
<            norm_evc = 0.d0
<            do imesh = 1, dffts%nnr
<               norm_evc = norm_evc + abs(evc_r(imesh,1,ibnd))**2.d0
<            enddo
<    
<            ind_g = 0
<            do igz = 1, 2*bg_max+1
<               do igy = 1, 2*bg_max+1
<                  do igx = 1, 2*bg_max+1
<                 
<                     ind_g = ind_g + 1
<    !                 write(stdout,*) ind_g
<    
<                     aux2 = 0.d0
<                     aux1(:,:) = evc_r(:,:,ibnd)
<                     CALL apply_dpot(dffts%nnr, aux1, dvGr(:,igx,igy,igz), current_spin)
<                     dvevc = aux1/sqrt(norm_evc)
<                     CALL cft_wave (aux2(:, ibnd), aux1, -1)
<    
<                     do jbnd = 1, nbnd
<                        eemat (jbnd, ibnd, ind_g) = &
<                           ZDOTC (npwq, evq(1, jbnd), 1, aux2(1, ibnd), 1)
< !                       eemat_check (jbnd, ibnd, ind_g) = &
< !                          ZDOTC (dffts%nnr, evq_r(:,1,jbnd), 1, dvevc(:,1), 1)
<                     enddo
<               
<                  enddo
<               enddo
<            enddo
---
>             eimpmat (jbnd, ibnd) = eimpmat (jbnd, ibnd) + &
>                      ZDOTC (nfftmesh, evq_rmesh(1:nfftmesh, jbnd), 1, dvimpevc(1:nfftmesh, ibnd), 1)
779,780c601
<         !
<      endif
---
>      enddo
781a603,618
> !     DO ibnd = 1, nbnd
> !        DO jbnd = 1, nbnd
> !           do imesh = 1, nfftmesh
> !              !
> !              ! dvimp no longer carries normalization factor, as normalization
> !              ! is properly taken into account in evc/evq
> !              !
> !              eimpmat(jbnd,ibnd) = eimpmat(jbnd,ibnd) + &
> !                     exp(-ci*twopi*dot_product(xq_cart,rp(:,imesh))) * &
> !                     conjg(evq_r(imp_meshmap(imesh,4),1,jbnd)) * &
> !                     evc_r(imp_meshmap(imesh,4),1,ibnd) * &
> !                     dvimp(imesh)
> !              !
> !           enddo
> !        ENDDO
> !     ENDDO
796,799d632
<      CALL mp_sum(eimpmat_r, intra_pool_comm)
<      CALL mp_sum(eemat, intra_pool_comm)
<      CALL mp_sum(eemat_check, intra_pool_comm)
<      CALL mp_sum(eemat_r, intra_pool_comm)
807,812c640
<         write(*,*) '    eimpmat = ',eimpmat(9:10,9:10)
<         write(*,*) '    eimpmat_r = ',eimpmat_r(9:10,9:10)
< 
< !        write(*,*) '    eemat =', eemat(ibnd,ibnd,12:16)
< !        write(*,*) '    eemat_check =', eemat_check(ibnd,ibnd,12:16)
< !        write(*,*) '    eemat_r =', eemat_r(ibnd,ibnd,12:16)
---
>         write(*,*) '     eimpmat = ',eimpmat(ibnd,ibnd)
850,855d677
<      write(stdout,*) ' t4_1 -> t4_2     :', t4_2-t4_1, 's'
<      write(stdout,*) ' t4_2 -> t4_3     :', t4_3-t4_2, 's'
<      write(stdout,*) ' t4_3 -> t4_4     :', t4_4-t4_3, 's'
<      write(stdout,*) ' t4_4 -> t4     :', t4-t4_4, 's'
< 
<      !
Only in ./: eimpmat_shuffle.o
Only in ./: eimpwan2bloch2.o
diff ./eimpwan2bloche.f90 ../../epw-qian/src/eimpwan2bloche.f90
35,38c35,38
<   IF (save_m_matw) THEN
<      filename = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_k'
<      OPEN (91915,FILE=filename,FORM='unformatted',ACCESS='direct',RECL=2*nbndsub*nbndsub*nrr_q*DP,STATUS='old')
<   ENDIF
---
>   !IF (save_m_matw) THEN
>   !   filename = TRIM(tmp_dir)//TRIM(prefix)//'.eimpmatwp_k'
>   !   OPEN (91915,FILE=filename,FORM='unformatted',ACCESS='direct',RECL=2*nbndsub*nbndsub*nrr_q*DP,STATUS='old')
>   !ENDIF
42,44c42,44
<      IF (save_m_matw) THEN
<         READ (91915,REC=irk) eimpmatwp0(1:nbndsub,1:nbndsub,1:nrr_q)
<      ELSE
---
>      !IF (save_m_matw) THEN
>      !   READ (91915,REC=irk) eimpmatwp0(1:nbndsub,1:nbndsub,1:nrr_q)
>      !ELSE
46c46
<      ENDIF
---
>      !ENDIF
61c61
<   IF (save_m_matw) CLOSE (91915)
---
>   !IF (save_m_matw) CLOSE (91915)
Only in ./: eimpwan2bloche.o
Only in ./: eliashberg_aniso_cont_raxis.o
Only in ./: eliashberg_aniso_iaxis.o
Only in ./: eliashbergcom.mod
Only in ./: eliashberg_common_aniso.mod
Only in ./: eliashberg_common_iso.mod
Only in ./: eliashberg_common.mod
Only in ./: eliashbergcom.o
Only in ./: eliashberg_iso_cont_raxis.o
Only in ./: eliashberg_iso_iaxis.o
Only in ./: eliashberg_iso_raxis.o
Only in ./: eliashberg.o
Only in ./: eliashberg_pp.o
Only in ./: eliashberg_readfiles.o
Only in ./: eliashberg_setup.o
Only in ./: eliashberg_write.o
diff ./elph2.f90 ../../epw-qian/src/elph2.f90
23c23
<        vkq(:,:,:),                 &
---
>        vkq(:,:,:),                 &! jw
25c25,26
<        wf_ful(:,:,:,:),                &
---
>        wf_all(:,:),                &       
>        wf_ful(:,:),                &
26a28
>        vph_all(:,:,:),             &!  
29a32,33
>        sigmai_mode_all_inter(:,:,:,:,:), & ! electron-phonon intervalley
>        sigmai_mode_all_intra(:,:,:,:,:), & !
31a36,37
>        sigmai_mode_all_alloy_intra(:,:,:,:), & ! alloy-electron intervalley scattering rate
>        sigmai_mode_all_alloy_inter(:,:,:,:), &
37a44
>        mfp_q_ful(:,:),             &
58c65,66
<        uf_ful(:,:,:,:,:)
---
>        uf_all(:,:,:),              &
>        uf_ful(:,:,:)
62a71
>        nelec_red,                  &
66d74
< 
70,74c78
<        cbnd_emin_nxk,              &
<        bg_max, ng_max,             &
<        bg_max_red, ng_max_red,     &
<        ig_max
< 
---
>        cbnd_emin_nxk
85,88c89
<        imp_meshmap(:,:),           &
<        map_l2g(:),                 &
<        map_g2l(:),                 &
<        map_kq2k(:,:)
---
>        imp_meshmap(:,:)
95,98c96
<        eimpf_full(:,:,:,:,:),      & ! nbnd_red, nbnd_red, neptemp, nepdope, nq_ful
<        dvGr(:,:,:,:),              &
<        dvimp_q(:,:,:,:),           &
<        dvimp_qc(:,:,:,:)             ! mesh q centered in [0..1]
---
>        alelpp(:,:,:)                 ! nq_ful, nbnd_red, nbnd_red
122,123c120
<        epf17 (:, :, :, :, :, :),  &!  full ep matrix in bloch rep stored in mem (nkqtotf, nbnd, nbnd, nmodes)-nbnd inside wndw 
<        eemat_f (:,:,:),      &!  e-imp matrix on fine mesh
---
>        epf17 (:, :, :, :),  &!  full ep matrix in bloch rep stored in mem (nkqtotf, nbnd, nbnd, nmodes)-nbnd inside wndw 
128c125
<        eph_vogl(:,:,:,:),          &
---
>        eph_vogl(:,:),          &
130,134c127
<        eimpmatwp (:,:,:,:),    & !  e-imp matrix in wannier basis - phonons
<        evc_k(:,:,:),           & ! collected Bloch wavefunctions
<        evwan(:,:,:),           & ! electronic Wannier functions
<        evc_fmesh(:,:,:)            ! wavefunctions at fine mesh
< 
---
>        eimpmatwp (:,:,:,:)       !  e-imp matrix in wannier basis - phonons
Only in ./: elph2.mod
Only in ./: elph2.o
diff ./elphel2_shuffle.f90 ../../epw-qian/src/elphel2_shuffle.f90
370,374c370,374
<           IF (timerev) THEN
<             CALL apply_dpot(dffts%nnr, aux1, CONJG(dvscfins(:,:,ipert)),current_spin)
<           ELSE
<              CALL apply_dpot(dffts%nnr, aux1, dvscfins(:,:,ipert),current_spin)
<           ENDIF
---
>          IF (timerev) THEN
>            CALL apply_dpot(dffts%nnr, aux1, CONJG(dvscfins(:,:,ipert)),current_spin)
>          ELSE
>             CALL apply_dpot(dffts%nnr, aux1, dvscfins(:,:,ipert),current_spin)
>          ENDIF
378d377
< 
Only in ./: elphel2_shuffle.o
Only in ./: elphon_shuffle.o
diff ./elphon_shuffle_wrap.f90 ../../epw-qian/src/elphon_shuffle_wrap.f90
6d5
<   ! License. See the file `LICENSE' in the root directory of the               
28c27
<   USE mp,            ONLY : mp_barrier, mp_bcast, mp_sum, mp_max
---
>   USE mp,            ONLY : mp_barrier, mp_bcast, mp_sum
33d31
<   USE gvecs,         ONLY : nls
36c34
<   USE io_files,      ONLY : prefix, tmp_dir, iunigk, diropn, seqopn
---
>   USE io_files,      ONLY : prefix, tmp_dir
43,45c41
<   USE pwcom,         ONLY : et, xk, ibrav, igk, nks, nbnd, nkstot, ngm, &
<                             omega, g, npw, igk
<   USE wvfct,         ONLY : npwx
---
>   USE pwcom,         ONLY : et, xk, ibrav, igk, nks, nbnd, nkstot, ngm, omega
50,51c46
<   USE phcom,         ONLY : dpsi, dvpsi, evq, nq1, nq3, nq2, iuwfc
<   USE units_ph,      ONLY : lrwfc
---
>   USE phcom,         ONLY : dpsi, dvpsi, evq, nq1, nq3, nq2 
60c55
<                             band_plot, specfun, dvscf_dir, lpolar, bte, neptemp, nepdope, &
---
>                             band_plot, specfun, dvscf_dir, lpolar, bte, neptemp, nepdope, phdrag, &
62c57
<                             dvimpsr, epbjump, epbrestore, dvimpq
---
>                             dvimpsr, epbjump, epbrestore
67,71c62,63
<                             scell_vol, def_pos, bg_max, dvGr, dvimp_q, &
<                             map_l2g, map_g2l, ng_max, evc_k, umat, umat_all, &
<                             ig_max, dvimp_qc, bg_max_red, ng_max_red, &
<                             map_kq2k
<   USE constants_epw, ONLY : ryd2ev, ci, twopi, cone, czero
---
>                             scell_vol, def_pos
>   USE constants_epw, ONLY : ryd2ev 
74c66
<   USE noncollin_module, ONLY : m_loc, npol
---
>   USE noncollin_module, ONLY : m_loc
131,135c123
<              ifft_stop, finished_iq_irr, center_index, ind_r, &
<              ind_g, irx, iry, irz, igx, igy, igz, imesh, ig, &
<              i1, j1, k1, ig_global, ipooltmp, ig_nrmax, &
<              nkk, nkk_abs, ipool, ind_gx, ind_gy, ind_gz, &
<              iG1, iG2, iG3, iq1, iq2, iq3, nnq, ig_shift, jbnd
---
>              ifft_stop, finished_iq_irr, center_index
139,141c127
<                    dvimp_, r0(3), G0(3), dotGr, xq_cart(3), &
<                    sc_un_ratio, xqG(3), norm0, zero_vect(3), &
<                    dvimp_r, dvimp_i, xq1, xq2, xq3, xk_l(3)
---
>                    dvimp_
144c130
<   real(kind=DP), allocatable :: vcoul_model(:), rp_red(:,:), rp_c(:,:)
---
>   real(kind=DP), allocatable :: vcoul_model(:), rp_red(:,:)
146,149c132
<   complex(kind=DP) :: evctmp(nbnd)
<   complex(kind=DP), allocatable :: eemat_check(:,:,:), evck_remap(:), evck(:,:)
<   logical :: gamma_find, x_find, l_find
<   COMPLEX(DP),EXTERNAL :: ZDOTC
---
>   logical :: gamma_find, x_find
169a153
>         IF (phdrag) CALL SYSTEM ('mkdir BTE/GAMMAI')
181a166
>                  IF (phdrag) CALL SYSTEM ( 'mkdir BTE/GAMMAI/T'//TRIM(ADJUSTL(itemp_num))//'_N'//TRIM(ADJUSTL(idope_num))//'_ph'//TRIM(ADJUSTL(imode_num)) )
393,395d377
<   ! NOTE: checked, sum of [nks] over pools gives nk1*nk2*nk3
< !  write(*,*) ' nks =', nks
<   !
438c420
<   ! Read impurity potential
---
>   ! Read impurity potential or alloy perturbed potential
440,441c422
<   if ((.not. eimpbread .and. (eimp_mode == 5 .or. eimp_mode == 6)) .or. &
<       (eimp_mode == 7 .or. eimp_mode == 8) ) then
---
>   if (.not. eimpbread .and. (eimp_mode == 5 .or. eimp_mode == 6)) then
448c429
<         tempfile = 'dv_tot.' // trim(adjustl(defectname)) // '.dat'
---
>         tempfile = 'dv_tot' // trim(adjustl(defectname)) // '.dat'
460c441
<         read(1000,*) nfftmesh      ! here nfftmesh should be equal to nfft_sc
---
>         read(1000,*) nfftmesh
463,464d443
<         if (nfftmesh /= nfft_sc) &
<            CALL errore('elphon_shuffle_wrap', 'nfftmesh not equal to nfft_sc',1)
505,506d483
<      ! supercell / unit cell volume ratio
<      sc_un_ratio = nint(scell_vol/omega)
595d571
<      !
650,652c626,628
<         if ((abs(rp_redm(1)-nint(rp_redm(1)))>1d-3) .or. &
<             (abs(rp_redm(2)-nint(rp_redm(2)))>1d-3) .or. &
<             (abs(rp_redm(3)-nint(rp_redm(3)))>1d-3)) then
---
>         if ((abs(rp_redm(1)-nint(rp_redm(1)))>1d-4) .or. &
>             (abs(rp_redm(2)-nint(rp_redm(2)))>1d-4) .or. &
>             (abs(rp_redm(3)-nint(rp_redm(3)))>1d-4)) then
655,659c631
<            write(stdout,*) '      @', i
<            write(stdout,*) '  rp_ =', rp_
<            write(stdout,*) ' rp_red =', rp_red(i,1:3)
<            write(stdout,*) ' rp_redm=', rp_redm(1:3)
<            if (mpime == ionode_id) CALL errore('imp_meshmap', 'Inconsistency',1)
---
>            write(stdout,*) '      @', i, rp_redm(1:3)
688,759d659
<      ! we correct the space vector by adding back the vector pointing to the
<      ! defect
<      !
<      allocate (rp_c(3,nfftmesh))
<      do imesh = 1, nfftmesh
<         rp_c(:,imesh) = rp(:,imesh) + def_pos(:)
<      enddo
<      !
<   endif
<   !
<   write(*,*) ' pool#', my_pool_id, ' get here1'
<   ! ========================================================
<   ! set up exp(i*G*r) for interpolating wave function matrix
<   ! ========================================================
<   !
<   if (eimp_mode == 5 .or. eimp_mode == 6 .or. eimp_mode == 7 .or. eimp_mode == 8) then
<      !
<      write(*,*) ' pool#', my_pool_id, ' get here1.0'
<      bg_max = 5
<      ng_max = (2*bg_max+1)**3
<      bg_max_red = bg_max - 1
<      ng_max_red = (2*bg_max_red + 1)**3
< 
<      write(*,*) ' pool#', my_pool_id, ' get here1.1'
<      allocate (dvimp_q (nq1*nq2*nq3,2*bg_max+1,2*bg_max+1,2*bg_max+1))
<      write(*,*) ' pool#', my_pool_id, ' get here1.2'
< 
<      ! for real space integration
< !     allocate (dvGr (dffts%nr1*dffts%nr2*dffts%nr3,2*bg_max+1,2*bg_max+1,2*bg_max+1))        
< !     write(*,*) ' pool#', my_pool_id, ' get here1.3'
< !     ind_r = 0
< !     do irz = 1, dffts%nr3
< !        do iry = 1, dffts%nr2
< !           do irx = 1, dffts%nr1
< !              !
< !              ind_r = ind_r + 1
< !              r0 = (dble(irx-1)/dffts%nr1)*at(1:3,1) + (dble(iry-1)/dffts%nr2)*at(1:3,2) + &
< !                   (dble(irz-1)/dffts%nr3)*at(1:3,3)
< !
< !              ind_g = 0
< !              do igz = -bg_max, bg_max
< !                 do igy = -bg_max, bg_max
< !                    do igx = -bg_max, bg_max
< !                     
< !                       ind_g = ind_g + 1  
< !                       G0 = igx*bg(1:3,1) + igy*bg(1:3,2) + igz*bg(1:3,3)
< !                       dotGr = dot_product(G0,r0)
< !                       dvGr(ind_r,igx+bg_max+1,igy+bg_max+1,igz+bg_max+1) = exp(ci*twopi*dotGr)
< !
< !                    enddo
< !                 enddo
< !              enddo
< !              !
< !           enddo
< !        enddo
< !     enddo
<      !
<      ! set up mapping between local G vectors and global index
<      ! for G vectors, check [Modules/recvec_subs.f90]
< 
<      write(stdout,*) ' ngm = ', ngm
<      allocate( map_l2g(ngm), map_g2l(dffts%nnr) )
< 
<      do ig = 1, ngm
<         i1 = nint(dot_product(g(:,ig),at(:,1))) + dffts%nr1/2
<         j1 = nint(dot_product(g(:,ig),at(:,2))) + dffts%nr2/2
<         k1 = nint(dot_product(g(:,ig),at(:,3))) + dffts%nr3/2
<         ig_global = k1*dffts%nr2*dffts%nr1 + j1*dffts%nr1 + i1
<         map_l2g(ig) = ig_global
<         map_g2l(ig_global) = ig
<      enddo
<      !
763,764d662
<   write(*,*) ' pool#', my_pool_id, ' get here2'
<   !
766,767c664,667
<       (.not. eimpbread .and. (eimp_mode == 5 .or. eimp_mode == 6)) .or. &
<       (.not. dvimpq .and. (eimp_mode == 7 .or. eimp_mode  == 8)) ) THEN
---
>       (.not. eimpbread .and. (eimp_mode == 5 .or. eimp_mode == 6)))  THEN
>     ! 
>     ! In the loop over irr q-point, we need to read the pattern that
>     ! correspond to the dvscf file computed with QE 5.
802,804d701
<     ! In the loop over irr q-point, we need to read the pattern that
<     ! correspond to the dvscf file computed with QE 5.
<     !
880,882d776
< !      if (iq_irr == 3) exit
< 
<       !
950c844
<         xqc(:,nqc) = xq    ! this is on cartesian coordinate
---
>         xqc(:,nqc) = xq
1082d975
< 
1120,1153d1012
<         !
<         ! Fourier component of short range defect potential
< 
<         if (.not. dvimpq .and. (eimp_mode == 7 .or. eimp_mode == 8)) then
< 
<            xq_cart(1) = xq(1) !- NINT(xq(1))
<            xq_cart(2) = xq(2) !- NINT(xq(2))
<            xq_cart(3) = xq(3) !- NINT(xq(3))
<            ! xq is already in cartesian coordinate
< !           CALL cryst_to_cart ( 1, xq_cart, bg, 1 )   ! xq_cart in [2*pi/alat]
< 
<            do igz = -bg_max, bg_max
<               ind_gz = igz+bg_max+1
<               do igy = -bg_max, bg_max
<                  ind_gy = igy+bg_max+1
<                  do igx = -bg_max, bg_max
<                     ind_gx = igx+bg_max+1
< 
<                     G0 = igx*bg(1:3,1) + igy*bg(1:3,2) + igz*bg(1:3,3)
<                     xqG = xq_cart + G0
< 
<                     do imesh = 1, nfftmesh
<                        dvimp_q(nqc,ind_gx,ind_gy,ind_gz) = dvimp_q(nqc,ind_gx,ind_gy,ind_gz) + &
<                                             dvimp(imesh) * exp(-ci*twopi*dot_product(xqG,rp_c(:,imesh)))
<                     enddo
<                  enddo
<               enddo
<            enddo
<            !
<            ! normalization: dvimp(q+G) = 1/Omega_uc * integral dr^3 dvimp(r)*exp(-i*(q+G)*r)
<            ! for discrete sum, dr^3/Omega_uc becomes sc_un_ratio / nfftmesh
<            dvimp_q(nqc,:,:,:) = dvimp_q(nqc,:,:,:) * (sc_un_ratio/nfft_sc)
< 
<         endif
1159a1019,1023
>         ! CALL elphon_shuffle ( iq_irr, nqc_irr, nqc, gmapsym, eigv, isym, invs, xq0, .false. )
>         !
>         !  bring epmatq in the mode representation of iq_first, 
>         !  and then in the cartesian representation of iq
>         !
1168d1031
< 
1197a1061,1062
>           !CALL elphon_shuffle ( iq_irr, nqc_irr, nqc, gmapsym, eigv, isym, invs, xq0, .true. )
>           !
1208,1241d1072
<           ! Fourier component of short range defect potential
< 
<           if (.not. dvimpq .and. (eimp_mode == 7 .or. eimp_mode == 8)) then
< 
<              xq_cart(1) = xq(1) !- NINT(xq(1))
<              xq_cart(2) = xq(2) !- NINT(xq(2))
<              xq_cart(3) = xq(3) !- NINT(xq(3))
<              ! NOTE: xq is already in cartesian coordinate
< !             CALL cryst_to_cart ( 1, xq_cart, bg, 1 )   ! xq_cart in [2*pi/alat]
< 
<              do igz = -bg_max, bg_max
<                 ind_gz = igz+bg_max+1
<                 do igy = -bg_max, bg_max
<                    ind_gy = igy+bg_max+1
<                    do igx = -bg_max, bg_max
<                       ind_gx = igx+bg_max+1
< 
<                       G0 = igx*bg(1:3,1) + igy*bg(1:3,2) + igz*bg(1:3,3)
<                       xqG = xq_cart + G0
< 
<                       do imesh = 1, nfftmesh
<                          dvimp_q(nqc,ind_gx,ind_gy,ind_gz) = dvimp_q(nqc,ind_gx,ind_gy,ind_gz) + &
<                                               dvimp(imesh) * exp(-ci*twopi*dot_product(xqG,rp_c(:,imesh)))
<                       enddo
<                    enddo
<                 enddo
<              enddo
<              !
<              ! normalization: dvimp(q+G) = 1/Omega_uc * integral dr^3 dvimp(r)*exp(-i*(q+G)*r)
<              ! for discrete sum, dr^3/Omega_uc becomes sc_un_ratio / nfftmesh
<              dvimp_q(nqc,:,:,:) = dvimp_q(nqc,:,:,:) * (sc_un_ratio/nfft_sc)
< 
<           endif
<           !
1257a1089
>         !
1285a1118
>   !
1317c1150
<       !
---
>          !
1320,1339d1152
<     ! write dvimp_q
<     !
<     if (.not.dvimpq .and. (eimp_mode == 7) .or. (eimp_mode == 8)) then
<        !
<        ! output short-range potential
<        !
<        tempfile = 'dvimp_q.' // trim(adjustl(defectname)) // '.dat'
<        open(unit = 1003, file = tempfile)
<        do iq = 1, nqc
<           do igz = 1, 2*bg_max+1
<              do igy = 1, 2*bg_max+1
<                 do igx = 1, 2*bg_max+1
<                    write(1003,'(2(es20.12,1x))') dble(dvimp_q(iq,igx,igy,igz)), dimag(dvimp_q(iq,igx,igy,igz))
<                 enddo
<              enddo
<           enddo
<        enddo
<        close(1003)
<        !
<     endif
1347d1159
<   !
1377d1188
<   !
1406,1690d1216
< 
<   !
<   if (eimp_mode == 7 .or. eimp_mode == 8) then
<      !
<      ! read dvimp_q (not centered)
<      !
<      if (dvimpq) then
< #ifdef __PARA
<      IF (mpime .EQ. ionode_id) THEN
< #ENDIF
<         tempfile = 'dvimp_q.' // trim(adjustl(defectname)) // '.dat'
<         open(unit = 1003, file = tempfile)
<         do iq = 1, nq1*nq2*nq3
<            do igz = 1, 2*bg_max+1
<               do igy = 1, 2*bg_max+1
<                  do igx = 1, 2*bg_max+1
<                     read(1003,*) dvimp_r, dvimp_i
<                     dvimp_q(iq,igx,igy,igz) = dcmplx(dvimp_r,dvimp_i)
<                  enddo
<               enddo
<            enddo
<         enddo
<         close(1003)
< #ifdef __PARA
<      ENDIF
<      CALL mp_bcast (dvimp_q, ionode_id, inter_pool_comm)
<      CALL mp_bcast (dvimp_q, root_pool, intra_pool_comm)
< #ENDIF
<      endif
< 
<      ! generate centered dvimp_qc
<      !
<      allocate (dvimp_qc (nq1*nq2*nq3,2*bg_max+1,2*bg_max+1,2*bg_max+1))
<      dvimp_qc = 0.d0
< 
<      do iq = 1, nq1*nq2*nq3
<         xq = xqc(:,iq)   ! xqc is in cartesian coordinate
< 
<         ! bring xq into crystal coordinate
<         CALL cryst_to_cart (1, xq, at, -1)
< 
<         xq1 = xq(1)
<         iG1 = 0
<         do while (xq1 < 0)
<            xq1 = xq1 + 1
<            iG1 = iG1 - 1
<         enddo
<         do while (xq1 >= 1)
<            xq1 = xq1 - 1
<            iG1 = iG1 + 1
<         enddo
< 
<         xq2 = xq(2)
<         iG2 = 0
<         do while (xq2 < 0)
<            xq2 = xq2 + 1
<            iG2 = iG2 - 1
<         enddo
<         do while (xq2 >= 1)
<            xq2 = xq2 - 1
<            iG2 = iG2 + 1
<         enddo
< 
<         xq3 = xq(3)
<         iG3 = 0
<         do while (xq3 < 0)
<            xq3 = xq3 + 1
<            iG3 = iG3 - 1
<         enddo
<         do while (xq3 >= 1)
<            xq3 = xq3 - 1
<            iG3 = iG3 + 1
<         enddo
< 
<         iq1 = nint(xq1*nq1)
<         iq2 = nint(xq2*nq2)
<         iq3 = nint(xq3*nq3)
<         nnq = iq1*nq2*nq3 + iq2*nq3 + iq3 + 1
< 
<         do igz = -bg_max, bg_max
<            ind_gz = igz+bg_max+1
<            do igy = -bg_max, bg_max
<               ind_gy = igy+bg_max+1
<               do igx = -bg_max, bg_max
<                  ind_gx = igx+bg_max+1
< 
<                  if ((ind_gx+iG1>0) .and. (ind_gy+iG2>0) .and. (ind_gz+iG3>0) .and. &
<                      (ind_gx+iG1<=2*bg_max+1) .and. (ind_gy+iG2<=2*bg_max+1) .and. (ind_gz+iG3<=2*bg_max+1)) then
<                     dvimp_qc(nnq,ind_gx+iG1,ind_gy+iG2,ind_gz+iG3) = dvimp_q(iq,ind_gx,ind_gy,ind_gz)
< 
<                     if (.false. .and. (igx==0) .and. (igy==0) .and. (igz==0)) then
<                        write(stdout,*)
<                        write(stdout,*) ' dvimp_qc test, iq#: ', iq
<                        write(stdout,*) ' xq =', xq
<                        write(stdout,*) ' iq1..3, nnq', iq1, iq2, iq3, nnq
<                        write(stdout,*) ' ind_g', ind_gx, ind_gy, ind_gz
<                        write(stdout,*) ' dvimp_qc:', dvimp_qc(nnq,ind_gx+iG1,ind_gy+iG2,ind_gz+iG3)
<                        write(stdout,*) ' dvimp_q:', dvimp_q(iq,ind_gx,ind_gy,ind_gz)
<                     endif
<                  endif
<               enddo
<            enddo
<         enddo
<         !
<      enddo
< 
<      do iq = 1, nq1*nq2*nq3
<         if (dvimp_qc(iq,bg_max+1,bg_max+1,bg_max+1) == 0.d0) then
<            write(stdout,*) ' zero at iq =', iq
<            stop
<         endif
<      enddo
< 
<      !
<      ! follow procedure in [elphel_shuffle2] to prepare the wavefunctions
<      !
<      ! close all sequential files in order to re-open them as direct access
<      ! close all .wfc files in order to prepare shuffled read
< 
<      CLOSE (unit = iunigk, status = 'keep')
<      CLOSE (unit = iuwfc,  status = 'keep')
<      ipooltmp = my_pool_id+1
<      !
<      ! find largest global index of G across pools
<      ig_max = 0
<      DO ik = 1, nks
<         CALL readigk (ipooltmp, ik, npw, igk)
<         DO ig = 1, npw
<            if (igk(ig)>ig_max) ig_max = igk(ig)
<         ENDDO
<         write(stdout,*) ' npw =', npw
<      ENDDO
<      write(*,*) ' before mp_max, pool# ',my_pool_id, 'ig_max =',ig_max
<      CALL mp_max(ig_max,inter_pool_comm)
<      write(*,*) ' after mp_max, pool# ',my_pool_id, 'ig_max =',ig_max
<      !
<      ! the first index (G) of evc_k is the global index of G
<      if (.not.(allocated(evc_k))) allocate (evc_k(nbnd,nks,ig_max))
<      evc_k = (0.d0, 0.d0)
<      !
<      DO ik = 1, nks
<         norm0 = 0
<         CALL readwfc (ipooltmp, ik, evc)
<         CALL readigk (ipooltmp, ik, npw, igk)
< 
<         CALL ktokpmq ( xk(:,ik),  zero_vect, +1, ipool, nkk, nkk_abs )
<         IF ( .not. ALLOCATED (umat) )  ALLOCATE ( umat(nbnd,nbnd,nks) )
<         umat(:,:,ik)  = umat_all(:,:, nkk_abs)
<         !
<         DO ig = 1, npw
<            !
<            DO ibnd = 1, nbnd
<               evc_k (ibnd, ik, igk(ig)) = evc (ig, ibnd)
<               norm0 = norm0 + (abs(evc(ig,ibnd)))**2
<            ENDDO
<            if (nls(igk(ig))>ig_nrmax) ig_nrmax = nls(igk(ig))
<            ! 
<            ! gauge settings on wavefunctions
<            CALL zgemm ('n', 'n', 1, nbnd, nbnd, cone, evc_k(:,ik,igk(ig)), & 
<                        1, umat(:,:,ik), nbnd, czero, evctmp, 1)
<            evc_k(:,ik,igk(ig)) = evctmp(:)
<         ENDDO
< 
< !        write(stdout,*) ' normalization check for ik =',ik
< !        write(stdout,*) '     xk    = ',xk(1:3,ik)
< !        write(stdout,*) ' ----nbnd = ',nbnd
< !        write(stdout,*) ' ----norm0 = ',norm0
<      ENDDO
< 
<      CALL mp_max(ig_nrmax,inter_pool_comm)
<      write(stdout,*) '   ig_max =',ig_max
<      write(stdout,*) ' ig_nrmax =',ig_nrmax
<      !
<      !  restore original configuration of files
<      !
<      CALL seqopn (iunigk, 'igk', 'unformatted', exst)
<      CALL diropn (iuwfc, 'wfc', lrwfc, exst)
<      !
<      ! set up mapping between local and global G points
<      ind_g = 0
<      allocate (map_kq2k (ig_max,ng_max_red))
<      map_kq2k = 0
<      do igz = -bg_max_red, bg_max_red
<         do igy = -bg_max_red, bg_max_red
<            do igx = -bg_max_red, bg_max_red
<               ind_g = ind_g + 1
<               ig_shift = igz*dffts%nr2*dffts%nr1 + igy*dffts%nr1 + igx
< 
<               do ig = 1, ig_max
<                  if (((map_l2g(ig)-ig_shift) > 0) .and. ((map_l2g(ig)-ig_shift) < dffts%nnr)) then
<                     if (map_g2l(map_l2g(ig)-ig_shift) <= ig_max) then
<                        map_kq2k(ig,ind_g) = map_g2l(map_l2g(ig)-ig_shift)
<                     endif
<                  endif
<               enddo
<            enddo
<         enddo
<      enddo
<      !
<      if (.false.) then
<         !
<         ALLOCATE ( eemat_check( nbnd, nbnd, ng_max_red) )
<         ALLOCATE ( evck ( ig_max, nbnd ) )
<         ALLOCATE ( evck_remap ( ig_max ) )
<         !
<         xk_gamma = (/0.d0, 0.d0, 0.d0/)
<         xk_x     = (/0.d0, 1.d0, 0.d0/)
<         xk_l     = (/-0.5d0,0.5d0,-0.5d0/)
< 
<         do ik = 1, nks
< 
<            gamma_find = .false.
<            if ((abs(xk(1,ik)-xk_gamma(1))<1d-5) .and. (abs(xk(2,ik)-xk_gamma(2))<1d-5) .and. &
<                (abs(xk(3,ik)-xk_gamma(3))<1d-5)) then
<               gamma_find = .true.
<            endif
< 
<            l_find = .false.
<            if ((abs(xk(1,ik)-xk_l(1))<1d-5) .and. (abs(xk(2,ik)-xk_l(2))<1d-5) .and. &
<                (abs(xk(3,ik)-xk_l(3))<1d-5)) then
<               l_find = .true.
<               write(*,*) ' find L =', xk(:,ik), ' @ pool#', my_pool_id
<            endif
< 
<            eemat_check = 0
<    
<            do ibnd = 1, nbnd
<               !
<               ind_g = 0
<               do igz = -bg_max_red, bg_max_red
<                  do igy = -bg_max_red, bg_max_red
<                     do igx = -bg_max_red, bg_max_red
<                        !
<                        ind_g = ind_g + 1
<                        ig_shift = igz*dffts%nr2*dffts%nr1 + igy*dffts%nr1 + igx
<                        !
<                        evck_remap = 0.d0
<                        do ig = 1, ig_max
<                           if ((map_kq2k(ig,ind_g) >= 1) .and. (map_kq2k(ig,ind_g) <= ig_max)) &
<                              evck_remap(ig) = evc_k(ibnd,ik,map_kq2k(ig,ind_g))
<                           evck(ig,1:nbnd) = evc_k(1:nbnd,ik,ig)
<                        enddo
<                        !
<                        do jbnd = 1, nbnd
<                           eemat_check(jbnd,ibnd,ind_g) = &   ! use reduced number of G points
<                                  ZDOTC (ig_max, evck(1,jbnd), 1, evck_remap(1), 1)
<                        enddo
<                        !
<                     enddo
<                  enddo
<               enddo
<            enddo
< 
<            CALL mp_sum(eemat_check, intra_pool_comm)
<            if (gamma_find) then
< 
<               ibnd = 10
<               write(*,*) ' check_evc in elphon_shuffle_wrap:'
<               write(*,*) ' xk =', xk(:,ik)
<               write(*,*) ' evc(1..5):'
<               write(*,*) 1, evc_k(ibnd,ik,1)
<               write(*,*) 2, evc_k(ibnd,ik,2)
<               write(*,*) 3, evc_k(ibnd,ik,3)
<               write(*,*) 4, evc_k(ibnd,ik,4)
<               write(*,*) 5, evc_k(ibnd,ik,5)
< 
<               ind_g = 0
<               do igz = -bg_max_red, bg_max_red
<                  do igy = -bg_max_red, bg_max_red
<                     do igx = -bg_max_red, bg_max_red
<                        ind_g = ind_g + 1
<                        if ((igz==0) .and. (igy==0)) then
<                           write(*,*) '    eemat_check =', igz,igy,igx, eemat_check(ibnd,ibnd,ind_g)
<                        endif
<                     enddo 
<                  enddo
<               enddo
<            endif
< 
<         enddo
<  
<      endif
<      !
<   endif
<   !
1697d1222
< 
1731c1256
<   if (.false. .and. (eimp_mode == 5 .or. eimp_mode == 6)) then
---
>   if (.true. .and. (eimp_mode == 5 .or. eimp_mode == 6)) then
1780,1781d1304
< 
< !  stop
1850a1374,1383
>   IF (ionode .AND. phdrag .AND. bte .EQ. 1) THEN
>      CALL SYSTEM ('rm -r BTE/SIGMAI/ BTE/GAMMAI/')
>   ELSE
>      CALL SYSTEM ('rm -r BTE/SIGMAI/')
>   ENDIF
>   !
> #ifdef __PARA
>   CALL mp_barrier (inter_pool_comm)
> #ENDIF
>   !
Only in ./: elphon_shuffle_wrap.o
Only in ./: ephbloch2wane.o
Only in ./: ephbloch2wanp.o
diff ./ephwan2bloch2.f90 ../../epw-qian/src/ephwan2bloch2.f90
2c2
< SUBROUTINE ephwan2bloch2 (nbnd, nrr_q, irvec, ndegen, epmatw, xxq, cuf, cufkk, cufkq, epmatf, nmodes, ntemp, ndope)
---
> SUBROUTINE ephwan2bloch2 (nbnd, nrr_q, irvec, ndegen, epmatw, xxq, cuf, cufkk, cufkq, epmatf, nmodes)
11c11
<   INTEGER, INTENT(IN)           :: nbnd, nrr_q, irvec(3, nrr_q), ndegen(nrr_q), nmodes, ntemp, ndope
---
>   INTEGER, INTENT(IN)           :: nbnd, nrr_q, irvec(3, nrr_q), ndegen(nrr_q), nmodes
13c13
<                                    cuf(nmodes, nmodes, ntemp, ndope)
---
>                                    cuf(nmodes, nmodes)
16c16
<   COMPLEX(KIND=DP), INTENT(OUT) :: epmatf (nbnd, nbnd, nmodes, ntemp, ndope)
---
>   COMPLEX(KIND=DP), INTENT(OUT) :: epmatf (nbnd, nbnd, nmodes)
18c18
<   INTEGER                       :: ir, imode, ibnd, jbnd, itemp, idope
---
>   INTEGER                       :: ir, imode, ibnd, jbnd
31c31
<         epmatf(:, :, imode, 1, 1) = epmatf(:, :, imode, 1, 1) + cfac * epmatw(:, :, ir, imode)
---
>         epmatf(:, :, imode) = epmatf(:, :, imode) + cfac * epmatw(:, :, ir, imode)
40c40
<          nbnd, epmatf (:,:,imode,1,1), nbnd, czero, eptmp(:,:,imode), nbnd)
---
>          nbnd, epmatf (:,:,imode), nbnd, czero, eptmp(:,:,imode), nbnd)
42c42
<          nbnd, cufkk, nbnd, czero, epmatf(:,:,imode,1,1), nbnd)
---
>          nbnd, cufkk, nbnd, czero, epmatf(:,:,imode), nbnd)
46c46
<   eptmp = epmatf(:,:,:,1,1)
---
>   eptmp = epmatf
50,57c50,53
<         do itemp = 1, ntemp
<            do idope = 1, ndope
<               !
<               CALL zgemv ('t', nmodes, nmodes, cone, cuf(:,:,itemp,idope), nmodes, eptmp(ibnd,jbnd,:), &
<                           1, czero, epmatf(ibnd,jbnd,1:nmodes,itemp,idope), 1)
<               !
<            enddo
<         enddo
---
>         !
>         CALL zgemv ('t', nmodes, nmodes, cone, cuf, nmodes, eptmp(ibnd,jbnd,:), &
>                     1, czero, epmatf(ibnd,jbnd,:), 1)
>         !
Only in ./: ephwan2bloch2.o
Only in ./: ephwan2bloche.o
Only in ./: ephwan2bloch.o
Only in ./: ephwan2blochp.o
diff ./ephwann_shuffle.f90 ../../epw-qian/src/ephwann_shuffle.f90
47,48c47,49
<                             save_m_ph, save_t_el, vg_el, vg_ph, eimp_mode, &
<                             dielec, defectname, &
---
>                             save_m_ph, save_t_el, vg_el, vg_ph, epthick, phdrag, &
>                             shengbte_read, alloy_read, alloy_pot, & ! Qian
>                             eimp_mode, dielec, defectname, &
50,51c51
<                             dvimpsr, elop, L_D, imp_charge, eimp_ls_mode, &
<                             screen_polar, eph_interp
---
>                             dvimpsr, elop
53,54c53
<   USE constants_epw, ONLY : ryd2ev, ryd2mev, rydcm1, one, two, twopi, pi, au2cm, &
<                             ci, bohr2ang
---
>   USE constants_epw, ONLY : ryd2ev, ryd2mev, rydcm1, one, two, twopi, pi, au2cm, au2ps, ryd2thz, ci, bohr2ang
57d55
<   USE io_global,     ONLY : stdout, ionode
69c67
<                             sigmai_mode_all_abs, sigmai_mode_all_emi, &
---
>                             sigmai_mode_all_abs, sigmai_mode_all_emi, sigmai_mode_all_alloy_inter, &
70a69,70
>                             sigmai_mode_all_alloy_intra, &
>                             sigmai_mode_all_intra, sigmai_mode_all_inter, &
75c75
<                             nfftmesh, rp, dvimp, eimpf_lr, eimpf_sr, &
---
>                             nfftmesh, rp, dvimp, eimpf_lr, eimpf_sr, alelpp, &
78,83c78,79
<                             eimpmatq, eimpmatwp, eimpmatwe, evc_k, evwan, &
<                             evc_fmesh, map_kq2k, ig_max, bg_max, ng_max, &
<                             map_l2g, map_g2l, dvimp_q, eemat_f, eimpf_full, &
<                             bg_max_red, ng_max_red
<   USE fft_base,      ONLY : dffts
<   USE bte_var
---
>                             eimpmatq, eimpmatwp, eimpmatwe
>   USE bte_var 
86c82
<   USE tetrahedron
---
>   USE tetrahedron     
93c89
<   USE io_global,     ONLY : ionode_id
---
>   USE io_global,     ONLY : ionode_id, stdout, ionode
112c108
<     epmatf( :, :, :, :, :),           &! e-p matrix  in smooth Bloch basis, fine mesh
---
>     epmatf( :, :, :),           &! e-p matrix  in smooth Bloch basis, fine mesh
115c111
<     uf    ( :, :,:,:),              &! Rotation matrix for phonons
---
>     uf    ( :, :),              &! Rotation matrix for phonons
124c120
<              nk_band, ik_band
---
>              nk_band
130,131c126,127
<                    xkk2(3), xxq_int(3)
<   real(kind=DP), allocatable :: vcoul_model(:), eig_k(:), xxq_band(:,:)
---
>                    xkk2(3)
>   real(kind=DP), allocatable :: vcoul_model(:), eig_k(:)
140c136
<                                    ifft_star, ifft_stop, imesh
---
>                                    ifft_star, ifft_stop, imesh, idope
142,143c138,139
<   INTEGER                       :: ik, ik0, ik_red, ik0_red, iq, iq0
<   INTEGER                       :: ibnd, jbnd, ibnd0, jbnd0, mbnd
---
>   INTEGER                       :: ik, ik0, ik_red, ik0_red, iq, iq0, idx1, idx2, idx3
>   INTEGER                       :: ibnd, jbnd, ibnd0, jbnd0
150c146
<   REAL(KIND=DP)                 :: velf(3,nbndsub), vq_(3,nmodes)
---
>   REAL(KIND=DP)                 :: velf(3,nbndsub)
156c152
<   COMPLEX(KIND=DP)              :: uf_cart(nmodes,nmodes), ephl_vogl(nmodes,neptemp,nepdope)
---
>   COMPLEX(KIND=DP)              :: uf_cart(nmodes,nmodes), ephl_vogl(nmodes)
165,166c161,162
<   REAL(KIND=DP), allocatable    :: wf_dyn(:,:,:), vph_dyn(:,:,:,:), eig_q(:,:,:,:)
<   COMPLEX(KIND=DP), allocatable :: uf_dyn(:,:,:,:), uf_(:,:,:,:)
---
>   REAL(KIND=DP)                 :: wf_dyn(nmodes), vph_dyn(3,nmodes)
>   COMPLEX(KIND=DP)              :: uf_dyn(nmodes,nmodes)
178a175,176
>   ! phdrag
>   CHARACTER (LEN=256)           :: filename_phd
194c192
<                                    tc=0.0d0, tci, tcf, t9_1, t9_2, t9_3, t9_4, t9_5, t9_6
---
>                                    tc=0.0d0, tci, tcf
196,203c194
<   integer :: ibnd_c, jbnd_c, ibnd_v, jbnd_v, center_index, ig, ind_g, &
<              igx, igy, igz, ig_shift, &
<              itemp, idope, ig_max_red, ikq_red, ik_red_, ikq_ful
<   integer, allocatable :: map_mesh_ful(:), mapcheck_ful(:), &
<                           map_mesh_rful(:), mapcheck_rful(:)
<   REAL(KIND=DP)                 :: dielec0, rpl, rp_max, dv_tot_far, vcoul_far, &
<                                    xql, xqG(3), G_cart(3), xqGl, norm_evcfk, &
<                                    imp_charge_, xkq_(3), xkk_(3)
---
>   REAL(KIND=DP)                 :: dielec0, rpl, rp_max, dv_tot_far, vcoul_far
205,209c196,199
<                                    eimpmatf(:,:), evc_kw(:,:), dvimpqf_sr(:), &
<                                    dvimpqf_lr(:,:), eimpmat_f(:,:,:,:), &
<                                    evc_ks(:,:), evc_fk(:,:), evc_fkq(:,:)
<   complex(kind=DP) :: eimpf_sr_, evc_remap(ig_max), eimpmat_r(nbnd,nbnd)
<   logical :: gamma_find, x_find, cond_find, vale_find, evcfkq_found, l_find
---
>                                    eimpmatf(:,:)
>   complex(kind=DP) :: eimpf_sr_, alelpp_
>   logical :: gamma_find, x_find, cond_find, vale_find
>   integer :: ibnd_c, jbnd_c, ibnd_v, jbnd_v, center_index
211d200
<   COMPLEX(DP),EXTERNAL :: ZDOTC
268c257
<      !
---
>      ! 
271,282c260,263
<         IF (.NOT. save_m_matw) THEN
<            ALLOCATE (eimpmatwe(nbndsub, nbndsub, nrr_k, nqc)) 
<            ALLOCATE (eimpmatwp(nbndsub, nbndsub, nrr_k, nrr_q))
<            eimpmatwe = (0.0d0,0.0d0)
<            eimpmatwp = (0.0d0,0.0d0)
<         ENDIF
<      endif
<      ! 
<      if (eimp_mode == 7 .or. eimp_mode == 8) then
<         ALLOCATE (evwan (nbndsub, nrr_k , ig_max))
<         ALLOCATE (evc_kw(nks, ig_max))
<         evwan = (0.d0,0.d0)
---
>         ALLOCATE(eimpmatwe(nbndsub, nbndsub, nrr_k, nqc))
>         eimpmatwe = (0.0d0,0.0d0)
>         ALLOCATE (eimpmatwp(nbndsub, nbndsub, nrr_k, nrr_q))
>         eimpmatwp = (0.0d0,0.0d0)
284a266
>      !
320d301
<      !
328,340d308
<      !
<      if (eimp_mode == 7 .or. eimp_mode == 8) then
<         !
<         do ig = 1, ig_max
<            !
<            call evcbloch2wan (nbnd, nbndsub, nks, nkstot, xk, cu, evc_k(:,:,ig), &
<                               nrr_k, irvec, evwan(:,:,ig), wslen, evc_kw(:,ig) )
<            !
<         enddo
<         !
<      endif
<      !
<      !
369,370d336
<           if (eimp_mode == 5 .or. eimp_mode == 6) &
<              eimpmatwe(:,:,:,iq) = eimpmatwe_q(:,:,:)
373c339,357
<      ENDDO
---
>        if (eimp_mode == 5 .or. eimp_mode == 6) then
>          eimpmatwe(:,:,:,iq) = eimpmatwe_q(:,:,:)
>       !  if (MOD(iq,10) .eq. 1) then
>       !     do idx1 = 1, nbndsub
>       !        do idx2 = 1, nbndsub
>       !           do idx3 = 1, nrr_k
>       !   if (MOD(idx3,100) .eq. 1) then
>       !WRITE (stdout,'(/5x,a,i4,a,i4,a,i4,a,i4)') 'iq =', iq, ', nbndsub1 = ', idx1, ',nbndsub2 = ', idx2, ', nrr =', idx3
>       !WRITE (stdout,'(/5x,a,es17.10)') 'eimpmatwe_q(nbndsub1,nbndsub2,nrr) =', ABS(eimpmatwe_q(idx1,idx2,idx3))
>       !WRITE (stdout,'(/5x,a,es17.10)') 'eimpmatwe(nbndsub1,nbndsub2,nrr,iq) =', ABS(eimpmatwe(idx1,idx2,idx3,iq))
>       !   endif
>       !           enddo
>       !        enddo
>       !     enddo
>       !  endif
>        endif
>        !
>    ENDDO !iq
>      !
420c404
<   !
---
>   !  
433a418,419
>   !
>   !
479c465
<   ! find out conduction band edge k-point; ERROR: currently only implements for
---
> ! find out conduction band edge k-point; ERROR: currently only implements for
505d490
<   ! density of states
508d492
<   ! fermi level location
703,705c687,688
<   ALLOCATE (epmatf(nbndsub, nbndsub, nmodes, neptemp, nepdope))
<   ! if (screen_polar) then
<   ALLOCATE (uf(nmodes, nmodes, neptemp, nepdope))
---
>   ALLOCATE (epmatf(nbndsub, nbndsub, nmodes))
>   ALLOCATE (uf(nmodes, nmodes))
708c691
<   IF (.NOT. save_m_mat) ALLOCATE (epf17 (nq_ful, nbnd_red, nbnd_red, nmodes, neptemp, nepdope)) 
---
>   IF (.NOT. save_m_mat) ALLOCATE (epf17 (nq_ful, nbnd_red, nbnd_red, nmodes)) 
713c696
<   if (eimp_mode == 2 .or. eimp_mode == 4 .or. eimp_mode == 6 .or. eimp_mode == 8) &
---
>   if (eimp_mode == 2 .or. eimp_mode == 4 .or. eimp_mode == 6) &
718,723c701,704
<      if (eimp_mode < 7) then
<         ALLOCATE ( eimpf_lr (nq_ful, neptemp, nepdope) )
<         ALLOCATE ( eimpf_sr (nq_ful, nbnd_red, nbnd_red) )
<         eimpf_lr = 0.d0
<         eimpf_sr = 0.d0
<      endif
---
>      allocate ( eimpf_lr (nq_ful, neptemp, nepdope) )
>      allocate ( eimpf_sr (nq_ful, nbnd_red, nbnd_red) )
>      eimpf_lr = 0.d0
>      eimpf_sr = 0.d0
729a711,714
>          IF (alloy_pot) THEN
>           allocate ( alelpp (nq_ful, nbnd_red, nbnd_red) )
>           alelpp = 0.d0
>          ENDIF
732,910d716
<      if (eimp_mode == 7 .or. eimp_mode == 8) then
< 
< !        ALLOCATE (eemat_f (nbnd_red, nbnd_red, ng_max_red, nq_ful)) 
<         ALLOCATE (eemat_f (nbnd_red, nbnd_red, ng_max_red)) 
< 
<         ALLOCATE (dvimpqf_sr (ng_max_red))
<         ALLOCATE (dvimpqf_lr (neptemp, nepdope))
<         ALLOCATE (eimpmat_f (nbnd_red, nbnd_red, neptemp, nepdope))
<         dvimpqf_sr = 0.d0
<         dvimpqf_lr = 0.d0
< 
<         ALLOCATE (eimpf_full (nbnd_red, nbnd_red, neptemp, nepdope, nq_ful))
<         eimpf_full = 0.d0
<      endif
<      !
<      if (eimp_mode == 7 .or. eimp_mode == 8) then
<         !
<         ! collect wavefunctions on fine mesh
<         if (ig_max <= 1000) then
<            ig_max_red = ig_max
<         else
<            ig_max_red = 1000
<         endif
<         ALLOCATE (evc_ks  (ig_max_red, nbnd_red))
< !        allocate (evc_fk  (ig_max, nbndsub))
< !        allocate (evc_fkq (ig_max, nbndsub))
<         ALLOCATE (evc_fk  (ig_max_red, nbnd_red))
<         ALLOCATE (evc_fkq (ig_max_red, nbnd_red))
<         ALLOCATE (map_mesh_rful (nkf1*nkf2*nkf3))   ! NOTE: only works when nkf is integer multiples of nqf
<         ALLOCATE (mapcheck_rful (nkf1*nkf2*nkf3))   ! NOTE: only works when nkf is interger multiples of nqf
<         ALLOCATE (map_mesh_ful (nkf1*nkf2*nkf3))   ! NOTE: only works when nkf is integer multiples of  nqf
<         ALLOCATE (mapcheck_ful (nkf1*nkf2*nkf3))   ! NOTE: only works when nkf is integer multiples nqf
<         map_mesh_rful = 0
<         mapcheck_rful = 0
<         map_mesh_ful = 0
<         mapcheck_ful = 0
<         !
<         if (.not. epcheck) then
<            ALLOCATE (evc_fmesh (ig_max_red, nbnd_red, nk_ful_red))
<         else
<            ALLOCATE (evc_fmesh (ig_max_red, nbnd_red, nk_ful))
<         endif
<         evc_fmesh = (0.d0, 0.d0)
< 
<         ! read ful_red mesh and mapping
<         if (allocated(xkf_ful))   deallocate(xkf_ful)
<         if (allocated(rful2ful))  deallocate(rful2ful)
<         if (allocated(ful2rful))  deallocate(ful2rful)
<         if (allocated(rful2rirr)) deallocate(rful2rirr)
<         ALLOCATE(xkf_ful(3,nk_ful))
<         ALLOCATE(rful2ful(nk_ful_red))
<         ALLOCATE(ful2rful(nk_ful))
<         ALLOCATE(rful2rirr(nk_ful_red))
<         OPEN (1200,FILE='BTE/META/xkf_ful_cryst',FORM='unformatted',ACCESS='direct',RECL=3*DP,STATUS='old')
<         do ik = 1, nk_ful
<            READ (1200,REC=ik) xkf_ful(1:3,ik)
<         enddo
<         close (1200)
<         OPEN (1201,FILE='BTE/META/rful2ful',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='old')
<         DO ik = 1, nk_ful_red
<            READ (1201,REC=ik) rful2ful(ik)
<         ENDDO
<         CLOSE (1201)
<         OPEN (1202,FILE='BTE/META/ful2rful',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='old')
<         DO ik = 1, nk_ful
<            READ (1202,REC=ik) ful2rful(ik)
<         ENDDO
<         CLOSE (1202)
<         !
<         OPEN (1203,FILE='BTE/META/rful2rirr',FORM='unformatted',ACCESS='direct',RECL=4,STATUS='old')
<         DO ik = 1, nk_ful_red
<            READ (1203,REC=ik) rful2rirr(ik)
<         ENDDO
<         CLOSE (1203)
<         !
<         !
<         if (.not. epcheck) then
<            !
<            CALL para_bounds (ik_star, ik_stop, nk_ful_red)
<            DO ik_red = ik_star, ik_stop
<               !
<               ik = rful2ful(ik_red)       ! ik is the original index of k point in full BZ
<               xkk(:) = xkf_ful(:,ik)     ! xkf_ful is assumed to be in crys coord
<    
<               CALL hamwan2bloch (nbndsub, nrr_k, irvec, ndegen_k, xkk, cufkk, etf_ks_tmp, chw)
<               CALL evcwan2bloch (xkk, irvec, ndegen_k, cufkk, nbndsub, nrr_k, evc_ks, ig_max_red)
<               evc_fmesh(:,:,ik_red) = evc_ks(:,:)
<               !
<               do while (xkk(1) < 0)
<                  xkk(1) = xkk(1) + 1
<               enddo
<               do while (xkk(1) >= 1)
<                  xkk(1) = xkk(1) - 1
<               enddo
<               do while (xkk(2) < 0)
<                  xkk(2) = xkk(2) + 1
<               enddo
<               do while (xkk(2) >= 1)
<                  xkk(2) = xkk(2) - 1
<               enddo
<               do while (xkk(3) < 0)
<                  xkk(3) = xkk(3) + 1
<               enddo
<               do while (xkk(3) >= 1)
<                  xkk(3) = xkk(3) - 1
<               enddo
<               ijk_k(1) = nint(xkk(1)*nkf1)
<               ijk_k(2) = nint(xkk(2)*nkf2)
<               ijk_k(3) = nint(xkk(3)*nkf3)
<               map_mesh_rful(ijk_k(1)*nkf2*nkf3+ijk_k(2)*nkf3+ijk_k(3)+1) = ik_red
<               mapcheck_rful(ijk_k(1)*nkf2*nkf3+ijk_k(2)*nkf3+ijk_k(3)+1) = 1
<               !
<            ENDDO
< #ifdef __PARA
<            CALL mp_barrier (inter_pool_comm)
<            CALL mp_sum (evc_fmesh,inter_pool_comm)
<            CALL mp_sum (map_mesh_rful,inter_pool_comm)
<            CALL mp_sum (mapcheck_rful,inter_pool_comm)
< #ENDIF
<            do ik = 1, nkf1*nkf2*nkf3
<               if (mapcheck_rful(ik) > 1) then
<                  write(stdout,*) ' ERROR: mapping to overlapped k point. Stop'
<                  stop
<               endif
<            enddo
<            !
<         endif
< 
<         CALL para_bounds (ik_star, ik_stop, nk_ful)
<         DO ik_red = ik_star, ik_stop
<            !
<            ik = ik_red
<            xkk(:) = xkf_ful(:,ik)     ! xkf_irr is assumed to be in crys coord
< 
<            if (epcheck) then
<               CALL hamwan2bloch (nbndsub, nrr_k, irvec, ndegen_k, xkk, cufkk, etf_ks_tmp, chw)
<               CALL evcwan2bloch (xkk, irvec, ndegen_k, cufkk, nbndsub, nrr_k, evc_ks, ig_max_red)
<               evc_fmesh(:,:,ik_red) = evc_ks(:,:)
<            endif
<            !
<            do while (xkk(1) < 0)
<               xkk(1) = xkk(1) + 1
<            enddo
<            do while (xkk(1) >= 1)
<               xkk(1) = xkk(1) - 1
<            enddo
<            do while (xkk(2) < 0)
<               xkk(2) = xkk(2) + 1
<            enddo
<            do while (xkk(2) >= 1)
<               xkk(2) = xkk(2) - 1
<            enddo
<            do while (xkk(3) < 0)
<               xkk(3) = xkk(3) + 1
<            enddo
<            do while (xkk(3) >= 1)
<               xkk(3) = xkk(3) - 1
<            enddo
<            ijk_k(1) = nint(xkk(1)*nkf1)
<            ijk_k(2) = nint(xkk(2)*nkf2)
<            ijk_k(3) = nint(xkk(3)*nkf3)
<            map_mesh_ful(ijk_k(1)*nkf2*nkf3+ijk_k(2)*nkf3+ijk_k(3)+1) = ik_red
<            mapcheck_ful(ijk_k(1)*nkf2*nkf3+ijk_k(2)*nkf3+ijk_k(3)+1) = 1
<            !
<         ENDDO
< #ifdef __PARA
<         CALL mp_barrier (inter_pool_comm)
<         if (epcheck) CALL mp_sum (evc_fmesh,inter_pool_comm)
<         CALL mp_sum (map_mesh_ful,inter_pool_comm)
<         CALL mp_sum (mapcheck_ful,inter_pool_comm)
< #ENDIF
<         do ik = 1, nkf1*nkf2*nkf3
<            if (mapcheck_ful(ik) > 1) then
<               write(stdout,*) ' ERROR: mapping to overlapped k point. Stop'
<               stop
<            endif
<         enddo
<         !
<      endif
913,914d718
< 
< 
922,926c726
<   if (screen_polar) then
<      ALLOCATE (wf_ful(nmodes,neptemp,nepdope,nq_ful))
<   else
<      ALLOCATE (wf_ful(nmodes,1,1,nq_ful))
<   endif
---
>   ALLOCATE (wf_ful(nmodes,nq_ful))
931,935c731
<      if (screen_polar) then
<         ALLOCATE (uf_ful(nmodes,nmodes,neptemp,nepdope,nq_ful))
<      else
<         ALLOCATE (uf_ful(nmodes,nmodes,1,1,nq_ful))
<      endif
---
>      ALLOCATE (uf_ful(nmodes,nmodes,nq_ful))
964,978c760
<      if (screen_polar) then
<         OPEN (41214,FILE=dyn_ufmt,FORM='unformatted',ACCESS='direct',RECL=(4*nmodes+2*nmodes*nmodes)*neptemp*nepdope*DP,STATUS='replace') 
<      else
<         OPEN (41214,FILE=dyn_ufmt,FORM='unformatted',ACCESS='direct',RECL=(4*nmodes+2*nmodes*nmodes)*DP,STATUS='replace') 
<      endif
<      !
<      if (screen_polar) then
<         ALLOCATE (wf_dyn(nmodes, neptemp, nepdope))
<         ALLOCATE (vph_dyn(3, nmodes, neptemp, nepdope))
<         ALLOCATE (uf_dyn(nmodes, nmodes, neptemp, nepdope))
<      else
<         ALLOCATE (wf_dyn(nmodes, 1, 1))
<         ALLOCATE (vph_dyn(3, nmodes, 1, 1))
<         ALLOCATE (uf_dyn(nmodes, nmodes, 1, 1))
<      endif
---
>      OPEN (41214,FILE=dyn_ufmt,FORM='unformatted',ACCESS='direct',RECL=(4*nmodes+2*nmodes*nmodes)*DP,STATUS='replace') 
988,994c770,771
<         if (screen_polar) then
<            CALL dynwan2bloch_s (nmodes, nrr_q, irvec, ndegen_q, xxq, uf_dyn, wf_dyn, vph_dyn, neptemp, nepdope)
<         else
<            CALL dynwan2bloch (nmodes, nrr_q, irvec, ndegen_q, xxq, uf_dyn, wf_dyn, vph_dyn)
<         endif
<         !
<         IF (epdim .EQ. 2) vph_dyn(3,:,:,:) = 0.0d0
---
>         CALL dynwan2bloch (nmodes, nrr_q, irvec, ndegen_q, xxq, uf_dyn, wf_dyn, vph_dyn)
>         IF (epdim .EQ. 2) vph_dyn(3,:) = 0.0d0
998,1014c775,779
<            if (screen_polar) then
<               do itemp = 1, neptemp
<                  do idope = 1, nepdope
<                     IF (wf_dyn(nu,itemp,idope) .GT. 0.0d0) THEN
<                        wf_dyn(nu,itemp,idope) =  SQRT(ABS(wf_dyn(nu,itemp,idope)))
<                     ELSE
<                        wf_dyn(nu,itemp,idope) = -SQRT(ABS(wf_dyn(nu,itemp,idope)))
<                     ENDIF
<                  enddo
<               enddo
<            else
<               IF (wf_dyn(nu,1,1) .GT. 0.0d0) THEN
<                  wf_dyn(nu,1,1) =  SQRT(ABS(wf_dyn(nu,1,1)))
<               ELSE
<                  wf_dyn(nu,1,1) = -SQRT(ABS(wf_dyn(nu,1,1)))
<               ENDIF
<            endif
---
>            IF (wf_dyn(nu) .GT. 0.0d0) THEN
>               wf_dyn(nu) =  SQRT(ABS(wf_dyn(nu)))
>            ELSE
>               wf_dyn(nu) = -SQRT(ABS(wf_dyn(nu)))
>            ENDIF
1018,1022c783
<               if (screen_polar) then
<                  uf_dyn(mu,nu,:,:) = uf_dyn(mu,nu,:,:) / SQRT(amass(ityp(na)))
<               else
<                  uf_dyn(mu,nu,1,1) = uf_dyn(mu,nu,1,1) / SQRT(amass(ityp(na)))
<               endif
---
>               uf_dyn(mu,nu) = uf_dyn(mu,nu) / SQRT(amass(ityp(na)))
1029,1034c790,791
<            if (screen_polar) then
<               CALL vgwan2bloch_q (0.0d0, xxq, vph_dyn, neptemp, nepdope)
<            else
<               CALL vgwan2bloch_q (0.0d0, xxq, vph_dyn, 1, 1)
<            endif
<            IF (epdim .EQ. 2) vph_dyn(3,:,:,:) = 0.0d0
---
>            CALL vgwan2bloch_q (0.0d0, xxq, vph_dyn)
>            IF (epdim .EQ. 2) vph_dyn(3,:) = 0.0d0
1038,1044c795
<         if (screen_polar) then
<            WRITE (41214,REC=iq-iq_star+1) wf_dyn(1:nmodes,1:neptemp,1:nepdope), vph_dyn(1:3,1:nmodes,1:neptemp,1:nepdope), &
<                                           uf_dyn(1:nmodes,1:nmodes,1:neptemp,1:nepdope)
<         else
<            WRITE (41214,REC=iq-iq_star+1) wf_dyn(1:nmodes,1,1), vph_dyn(1:3,1:nmodes,1,1), &
<                                           uf_dyn(1:nmodes,1:nmodes,1,1)
<         endif
---
>         WRITE (41214,REC=iq-iq_star+1) wf_dyn(1:nmodes), vph_dyn(1:3,1:nmodes), uf_dyn(1:nmodes,1:nmodes)
1059,1068c810,812
< 
<         if (screen_polar) then
<            OPEN (99901,FILE=wf_ufmt,FORM='unformatted',ACCESS='direct',RECL=nmodes*neptemp*nepdope*DP,STATUS='replace')
<            OPEN (99902,FILE=uf_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*nmodes*neptemp*nepdope*DP,STATUS='replace')
<            OPEN (99903,FILE=vph_ufmt,FORM='unformatted',ACCESS='direct',RECL=3*nmodes*neptemp*nepdope*DP,STATUS='replace')
<         else
<            OPEN (99901,FILE=wf_ufmt,FORM='unformatted',ACCESS='direct',RECL=nmodes*DP,STATUS='replace')
<            OPEN (99902,FILE=uf_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*nmodes*DP,STATUS='replace')
<            OPEN (99903,FILE=vph_ufmt,FORM='unformatted',ACCESS='direct',RECL=3*nmodes*DP,STATUS='replace')
<         endif
---
>         OPEN (99901,FILE=wf_ufmt,FORM='unformatted',ACCESS='direct',RECL=nmodes*DP,STATUS='replace')
>         OPEN (99902,FILE=uf_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*nmodes*DP,STATUS='replace')
>         OPEN (99903,FILE=vph_ufmt,FORM='unformatted',ACCESS='direct',RECL=3*nmodes*DP,STATUS='replace')
1076,1080c820
<            if (screen_polar) then
<               OPEN (41214,FILE=dyn_ufmt,FORM='unformatted',ACCESS='direct',RECL=(4*nmodes+2*nmodes*nmodes)*neptemp*nepdope*DP,STATUS='old') 
<            else
<               OPEN (41214,FILE=dyn_ufmt,FORM='unformatted',ACCESS='direct',RECL=(4*nmodes+2*nmodes*nmodes)*DP,STATUS='old') 
<            endif
---
>            OPEN (41214,FILE=dyn_ufmt,FORM='unformatted',ACCESS='direct',RECL=(4*nmodes+2*nmodes*nmodes)*DP,STATUS='old') 
1084,1095c824,827
<               if (screen_polar) then
<                  READ (41214,REC=iq) wf_dyn(1:nmodes,1:neptemp,1:nepdope), vph_dyn(1:3,1:nmodes,1:neptemp,1:nepdope), &
<                                      uf_dyn(1:nmodes,1:nmodes,1:neptemp,1:nepdope)
<                  WRITE (99901,REC=iq_dyn) wf_dyn(1:nmodes,1:neptemp,1:nepdope)
<                  WRITE (99902,REC=iq_dyn) uf_dyn(1:nmodes,1:nmodes,1:neptemp,1:nepdope)
<                  WRITE (99903,REC=iq_dyn) vph_dyn(1:3,1:nmodes,1:neptemp,1:nepdope)
<               else
<                  READ (41214,REC=iq) wf_dyn(1:nmodes,1,1), vph_dyn(1:3,1:nmodes,1,1), uf_dyn(1:nmodes,1:nmodes,1,1)
<                  WRITE (99901,REC=iq_dyn) wf_dyn(1:nmodes,1,1)
<                  WRITE (99902,REC=iq_dyn) uf_dyn(1:nmodes,1:nmodes,1,1)
<                  WRITE (99903,REC=iq_dyn) vph_dyn(1:3,1:nmodes,1,1)
<               endif
---
>               READ (41214,REC=iq) wf_dyn(1:nmodes), vph_dyn(1:3,1:nmodes), uf_dyn(1:nmodes,1:nmodes)
>               WRITE (99901,REC=iq_dyn) wf_dyn(1:nmodes)
>               WRITE (99902,REC=iq_dyn) uf_dyn(1:nmodes,1:nmodes)
>               WRITE (99903,REC=iq_dyn) vph_dyn(1:3,1:nmodes)
1124,1128c856
<   !
<   ! for screen_polar case, we only use one temperature, 
<   ! carrier concentration combination to find maximum frequency
<   !
<   wmax_mode(1:nmodes) = MAXVAL(wf_ful(1:nmodes,1,1,:))
---
>   wmax_mode(1:nmodes) = MAXVAL(wf_ful(1:nmodes,:))
1136c864
<   IF (lpolar .and. elop) THEN
---
>   IF (lpolar) THEN
1138c866
<      ALLOCATE(eph_vogl(nmodes,neptemp,nepdope,nq_ful))
---
>      ALLOCATE(eph_vogl(nmodes,nq_ful))
1167c895
<         OPEN (41914,FILE=vogl_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*neptemp*nepdope*DP,STATUS='replace') 
---
>         OPEN (41914,FILE=vogl_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*DP,STATUS='replace') 
1183c911
<               CALL polar_eph (uf_cart, xxq, ephl_vogl, neptemp, nepdope)
---
>               CALL polar_eph (uf_cart, xxq, ephl_vogl)
1188c916
<            WRITE (41914,REC=iq-iq_star+1) ephl_vogl(1:nmodes,1:neptemp,1:nepdope)
---
>            WRITE (41914,REC=iq-iq_star+1) ephl_vogl(1:nmodes)
1201c929
<            OPEN (99901,FILE=vogl_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*neptemp*nepdope*DP,STATUS='replace')
---
>            OPEN (99901,FILE=vogl_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*DP,STATUS='replace')
1209c937
<               OPEN (41914,FILE=vogl_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*neptemp*nepdope*DP,STATUS='old') 
---
>               OPEN (41914,FILE=vogl_ufmt,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*DP,STATUS='old') 
1213,1214c941,942
<                  READ (41914,REC=iq) ephl_vogl(1:nmodes,1:neptemp,1:nepdope)
<                  WRITE (99901,REC=iq_vogl) ephl_vogl(1:nmodes,1:neptemp,1:nepdope)
---
>                  READ (41914,REC=iq) ephl_vogl(1:nmodes)
>                  WRITE (99901,REC=iq_vogl) ephl_vogl(1:nmodes)
1284c1012
<         !DO ibnd = 1, nbndsub
---
>        ! DO ibnd = 1, nbndsub
1286c1014
<         !ENDDO
---
>        ! ENDDO 
1290d1017
<  
1349c1076
<   !
---
>   !  
1379c1106
<         ALLOCATE(rp(3,nfftmesh), dvimp(nfftmesh))
---
>         allocate(rp(3,nfftmesh), dvimp(nfftmesh))
1469c1196
<         dvimp = dvimp - vcoul_model - (dv_tot_far - vcoul_far)
---
>         IF (.not. alloy_pot) dvimp = dvimp - vcoul_model - (dv_tot_far - vcoul_far)
1529a1257
>      IF (.not. alloy_pot) THEN
1537a1266,1273
>      ELSE
>        alelpp_ = 0.d0
>        do imesh = 1, nfftmesh
>            alelpp_ = alelpp_ + exp(-ci*twopi*dot_product(xq_cart,rp(:,imesh))) * &
>                                         dvimp(imesh)
>         enddo
>         alelpp(iq,:,:) = alelpp_
>      ENDIF  ! alloy_pot
1540a1277
>      IF (alloy_pot) alelpp = real(alelpp)
1543a1281
>      IF (alloy_pot)  CALL mp_sum (alelpp,inter_pool_comm)
1552,1564d1289
<   !
<   !
<   if (eimp_mode == 7 .or. eimp_mode == 8) then
<      !
<      if (.not. lpolar) then
<         dielec0 = dielec
<      else
<         dielec0 = (epsi(1,1) + epsi(2,2) + epsi(3,3)) / 3.d0
<      endif
<      !
<   endif
<   !
<   !
1626,1733d1350
<   ! ==============================
<   ! Check phonon dispersion
<   ! ==============================
<   !
<   IF ((epcheck) .and. (my_pool_id .EQ. ionode_id)) THEN
<      !
<      ! output phonon frequency for checking
< 
<      open(2105, file='band_q.in')
<      filename = trim(adjustl(prefix)) // '.phonon_freq_fine.txt'
<      open(2106, file=filename)
<      read(2105,*) nk_band
<      read(2105,*) nu
<      if (.not. screen_polar) then
<         write(2106,*) nk_band*nu+1, nmodes
<      else
<         write(2106,*) nk_band*nu+1, nmodes, neptemp, nepdope
<      endif
<      !
<      if (.not. screen_polar) then
<         allocate (eig_q(nmodes, 1, 1, nk_band*nu+1))
<         allocate (uf_(nmodes, nmodes, 1, 1))
<      else
<         allocate (eig_q(nmodes, neptemp, nepdope, nk_band*nu+1))
<         allocate (uf_(nmodes, nmodes, neptemp, nepdope))
<      endif
<      allocate (xxq_band(3, nk_band*nu+1))
<      uf_ = (0.0d0,0.0d0)
<      !
<      ik_band = 0
<      do mu = 1, nu
< !        write(stdout,*) ' direction:',mu
<         read(2105,*) xkk, xkk2
<         if (mu==1) then
<            ik_band = ik_band + 1
<            xxq_band(:,ik_band) = xkk
<            if (eph_interp) then
< !              call ph_freq_interp (nmodes, xxq, eig_k)
<               if (screen_polar) then
<                  write(stdout,*) ' eph_interp cannot be used with screen_polar'
<                  stop
<               endif
< !CHECK: add this subroutine
< !              call ph_freq_interp_tetra (nmodes, xxq_band(:,ik_band), eig_q(:,1,1,1))
<               write (2106,'(f12.8,f12.8,f12.8,48f10.4)') &
<                    xxq(1:3), (abs(eig_q(ibnd,1,1,1))*rydcm1, ibnd=1,nmodes)
<            else
<               if (screen_polar) then
<                  CALL dynwan2bloch_s &
<                       ( nmodes, nrr_q, irvec, ndegen_q, xxq_band(:,ik_band), uf_, eig_q(:,:,:,ik_band), vq_,neptemp,nepdope)
<               else
<                  CALL dynwan2bloch &
<                       ( nmodes, nrr_q, irvec, ndegen_q, xxq_band(:,ik_band), uf_, eig_q(:,1,1,ik_band), vq_)
<               endif
<            endif
<         endif
<         !
<         do iq = 1, nk_band
<            ik_band = ik_band + 1
<            xxq_band(:,ik_band) = xkk + ((xkk2-xkk)*iq)/nk_band
< !           write(stdout,*) ' iq:',iq, '-------------------------------'
< !           write(stdout,*) ' xxq =',xxq(1:3)
<            if (eph_interp) then
< !              call ph_freq_interp (nmodes, xxq, eig_k)
< !CHECK: add this subroutine
< !              call ph_freq_interp_tetra (nmodes, xxq_band(:,ik_band), eig_q(:,1,1,1))
<               write (2106,'(f12.8,f12.8,f12.8,48f10.4)') &
<                    xxq(1:3), (abs(eig_q(ibnd,1,1,1))*rydcm1, ibnd=1,nmodes)
<            else
<               if (screen_polar) then
<                  CALL dynwan2bloch_s &
<                       ( nmodes, nrr_q, irvec, ndegen_q, xxq_band(:,ik_band), uf_, eig_q(:,:,:,ik_band), vq_,neptemp,nepdope)
<               else
<                  CALL dynwan2bloch &
<                       ( nmodes, nrr_q, irvec, ndegen_q, xxq_band(:,ik_band), uf_, eig_q(:,1,1,ik_band), vq_)
<               endif
<            endif
<         enddo
<      enddo
<      !
<      do itemp = 1, neptemp
<         do idope = 1, nepdope
<            if (.not. screen_polar) then
<               if ((itemp > 1) .or. (idope > 1)) cycle
<            endif
<            !
<            ik_band = 0
<            do mu = 1, nu
<               if (mu==1) then
<                  ik_band = ik_band + 1
<                  write (2106,'(f12.8,f12.8,f12.8,48f10.4)') &
<                       xxq_band(1:3,ik_band), (sqrt(abs(eig_q(ibnd,itemp,idope,ik_band)))*rydcm1, ibnd=1,nmodes)
<               endif
<               do iq = 1, nk_band
<                  ik_band = ik_band + 1
<                  write (2106,'(f12.8,f12.8,f12.8,48f10.4)') &
<                       xxq_band(1:3,ik_band), (sqrt(abs(eig_q(ibnd,itemp,idope,ik_band)))*rydcm1, ibnd=1,nmodes)
<               enddo
<            enddo
<         enddo
<      enddo
<      !
<      deallocate (eig_q)
<      deallocate (uf_)
<      close(2105)
<      close(2106)
<   ENDIF
< 
1738d1354
<   !
1744a1361,1362
>   ALLOCATE (sigmai_mode_all_inter(neptemp,nepdope,nmodes,nbnd_red,nk_irr_red))
>   ALLOCATE (sigmai_mode_all_intra(neptemp,nepdope,nmodes,nbnd_red,nk_irr_red))
1746a1365,1366
>   sigmai_mode_all_inter = 0.0d0
>   sigmai_mode_all_intra = 0.0d0
1752a1373,1378
>      IF (alloy_pot) THEN
>       ALLOCATE (sigmai_mode_all_alloy_intra(neptemp,nepdope,nbnd_red,nk_irr_red))
>       ALLOCATE (sigmai_mode_all_alloy_inter(neptemp,nepdope,nbnd_red,nk_irr_red))
>       sigmai_mode_all_alloy_inter = 0.0d0
>       sigmai_mode_all_alloy_intra = 0.0d0
>      ENDIF
1774d1399
< !     xkk = -xkk
1776,1778c1401
<      write(*,*) 'my pool id #', my_pool_id, 'xk =', xkk
<      !
<      ! find special k-points
---
>  ! find special k-points
1798,1808d1420
<      !
<      l_find = .false.
<      if (epcheck) then
<         if (((abs(xkk(1))==0.0).and.(abs(xkk(2))==0.0).and.(abs(xkk(3))==0.5)) .or. &
<             ((abs(xkk(1))==0.0).and.(abs(xkk(2))==0.5).and.(abs(xkk(3))==0.0)) .or. &
<             ((abs(xkk(1))==0.5).and.(abs(xkk(2))==0.0).and.(abs(xkk(3))==0.0))) then
<            l_find = .true.
<            write(*,*) ' finding l-point at #pool:',my_pool_id
<            write(*,*) ' xk =',xkk(1:3)
<         endif
<      endif
1823,1824c1435
<      if ((gamma_find .and. (xk_v=='G')) .or. (x_find .and. (xk_v=='X')) .or. &
<          (l_find .and. (xk_v=='L'))) then
---
>      if ((gamma_find .and. (xk_v=='G')) .or. (x_find .and. (xk_v=='X'))) then
1840d1450
<      !
1868c1478,1479
<      IF (eimp_mode == 2 .or. eimp_mode == 4 .or. eimp_mode == 6 .or. eimp_mode == 8) THEN
---
>      !CALL dmewan2bloch (nbndsub, nrr_k, irvec, ndegen_k, xkk, cufkk, dmef(:,:,:,1), etf(:,1), etf_ks(:,1))
>      IF (eimp_mode == 2 .or. eimp_mode == 4 .or. eimp_mode == 6) THEN
1895,1956d1505
<      ! wavefunction at k
< 
<      if (eimp_mode == 7 .or. eimp_mode == 8) then
<         !
< !        call evcwan2bloch (xkk, irvec, ndegen_k, cufkk, nbndsub, nrr_k, evc_fk, ig_max_red)
< 
<         xkk_ = xkk
<         do while (xkk_(1) < 0)
<            xkk_(1) = xkk_(1) + 1
<         enddo
<         do while (xkk_(1) >= 1)
<            xkk_(1) = xkk_(1) - 1
<         enddo
<         do while (xkk_(2) < 0)
<            xkk_(2) = xkk_(2) + 1
<         enddo
<         do while (xkk_(2) >= 1)
<            xkk_(2) = xkk_(2) - 1
<         enddo
<         do while (xkk_(3) < 0)
<            xkk_(3) = xkk_(3) + 1
<         enddo
<         do while (xkk_(3) >= 1)
<            xkk_(3) = xkk_(3) - 1
<         enddo
<         ijk_k(1) = nint(xkk_(1)*nkf1)
<         ijk_k(2) = nint(xkk_(2)*nkf2)
<         ijk_k(3) = nint(xkk_(3)*nkf3)
<         if (.not. epcheck) then
<            ik_red_ = map_mesh_rful(ijk_k(1)*nkf2*nkf3+ijk_k(2)*nkf3+ijk_k(3)+1)
<         else
<            ik_red_ = map_mesh_ful(ijk_k(1)*nkf2*nkf3+ijk_k(2)*nkf3+ijk_k(3)+1)
<         endif
< 
<         if (ik_red_ /= 0) then
<            evc_fk(:,:) = evc_fmesh(:,:,ik_red_)
<         else
<            CALL errore('ephwann_shuffle','evc_fk not found',1)
<         endif
<         if (.not. epcheck) then
<            if (rful2rirr(ik_red_) /= ik_red) &
<               CALL errore('ephwann_shuffle','rful2rirr(ik_ful_red) /= ik_irr_red',1)
<         else
<            if (rful2rirr(ful2rful(ik_red_)) /= ik_red) &
<               CALL errore('ephwann_shuffle','rful2rirr(ful2rful(ik_ful)) /= ik_irr_red',1)
<         endif
<         !
<         if (.false. .and. (gamma_find .or. x_find .or. l_find)) then
< 
<            ibnd = 10
<            write(*,*)
<            write(*,*) ' xk =',xkk(1:3)
<            write(*,*) ' check evc_fk:'
<            write(*,*) 1, evc_fk(1,ibnd)
<            write(*,*) 2, evc_fk(2,ibnd)
<            write(*,*) 3, evc_fk(3,ibnd)
<            write(*,*) 4, evc_fk(4,ibnd)
<            write(*,*) 5, evc_fk(5,ibnd)
< 
<         endif
<         !
<      endif
1972a1522,1524
> !#ifdef __PARA
> !     CALL mp_barrier(inter_pool_comm)
> !#endif
1989a1542,1544
> !#ifdef __PARA
> !     CALL mp_barrier(inter_pool_comm)
> !#endif
2002d1556
< !ERROR: save_m_mat for [epmatf] and [epf17] are wrong (recl length not correct)
2017,2020d1570
<         if (eimp_mode == 7 .or. eimp_mode == 8) then
<            eimpf_full = (0.0d0,0.0d0)
<         endif
<         !
2046d1595
< !        xxq = -xxq
2049,2066c1598,1602
<         if (.not.screen_polar) then
<            IF (save_m_ph) THEN
<               READ (17817,REC=iq) uf(1:nmodes,1:nmodes,1,1)
<            ELSE
<               uf(:,:,1,1) = uf_ful(:,:,1,1,iq)
<            ENDIF
<            do itemp = 1, neptemp
<               do idope = 1, nepdope
<                  uf(:,:,itemp,idope) = uf(:,:,1,1)
<               enddo
<            enddo
<         else
<            IF (save_m_ph) THEN
<               READ (17817,REC=iq) uf(1:nmodes,1:nmodes,1:neptemp,1:nepdope)
<            ELSE
<               uf(:,:,:,:) = uf_ful(:,:,:,:,iq)
<            ENDIF
<         endif
---
>         IF (save_m_ph) THEN
>            READ (17817,REC=iq) uf(1:nmodes,1:nmodes)
>         ELSE
>            uf(:,:) = uf_ful(:,:,iq)
>         ENDIF
2070c1606
<         IF (eimp_mode == 2 .or. eimp_mode == 4 .or. eimp_mode == 6 .or. eimp_mode == 8) then
---
>         IF (eimp_mode == 2 .or. eimp_mode == 4 .or. eimp_mode == 6) then
2076d1611
< !        if (iq > 1) cycle
2091,2096c1626,1631
<            !DO ibnd = 1, nbndsub
<            !   IF (etf(ibnd,ikq) .GT. ef_m) etf(ibnd,ikq) = etf(ibnd,ikq) + delta_egap
<            !ENDDO
<            DO ibnd = vbnd_num+1, nbndsub
<               etf(ibnd,ikq) = etf(ibnd,ikq) + delta_egap
<            ENDDO 
---
>          !  DO ibnd = 1, nbndsub
>          !     IF (etf(ibnd,ikq) .GT. ef_m) etf(ibnd,ikq) = etf(ibnd,ikq) + delta_egap
>          !  ENDDO
>         DO ibnd = vbnd_num+1, nbndsub
>            etf(ibnd,ikq) = etf(ibnd,ikq) + delta_egap
>         ENDDO 
2125c1660,1664
<         IF (eimp_mode == 2 .or. eimp_mode == 4 .or. eimp_mode == 6 .or. eimp_mode == 8) THEN
---
>         !CALL dmewan2bloch (nbndsub, nrr_k, irvec, ndegen_k, xkq, cufkq, dmef (:,:,:,ikq), etf(:,ikq), etf_ks(:,ikq))  
>         !DO ibnd = 1, nbndsub
>         !   vkq(:,ibnd) = 2.0d0*REAL(dmef(:,ibnd,ibnd,ikq))
>         !ENDDO
>         IF (eimp_mode == 2 .or. eimp_mode == 4 .or. eimp_mode == 6) THEN
2149a1689
>         !
2177,2187c1717,1718
<               IF (nptype .EQ. 'n') THEN
<                  IF ( (etf(ibnd,ikk) .GE. cbnd_emin .AND. etf(ibnd,ikk) .LE. cbnd_emin+cfsthick) .and. &
<                       (etf(jbnd,ikq) .GE. cbnd_emin .AND. etf(jbnd,ikq) .LE. cbnd_emin+cfsthick) ) within_range = .TRUE.
<               ELSEIF (nptype .EQ. 'p') THEN
<                  IF ( (etf(ibnd,ikk) .GE. vbnd_emax-vfsthick .AND. etf(ibnd,ikk) .LE. vbnd_emax) .and. &
<                       (etf(jbnd,ikq) .GE. vbnd_emax-vfsthick .AND. etf(jbnd,ikq) .LE. vbnd_emax) ) within_range = .TRUE.
<               ELSE
<                  IF ( (etf(ibnd,ikk) .GE. vbnd_emax-vfsthick .AND. etf(ibnd,ikk) .LE. cbnd_emin+cfsthick) .AND. &
<                       (etf(jbnd,ikq) .GE. vbnd_emax-vfsthick .AND. etf(jbnd,ikq) .LE. cbnd_emin+cfsthick) ) within_range = .TRUE.
<               ENDIF
< 
---
>               IF ( (etf(ibnd,ikk) .GE. vbnd_emax-vfsthick .AND. etf(ibnd,ikk) .LE. cbnd_emin+cfsthick) .AND. &
>                    (etf(jbnd,ikq) .GE. vbnd_emax-vfsthick-epthick .AND. etf(jbnd,ikq) .LE. cbnd_emin+cfsthick+epthick) ) within_range = .TRUE.
2192,2232d1722
<         ! when ep-check, always consider every e-ph coupling
<         if (epcheck) within_range = .true.
<         !
<         ! make sure the corresponding irreducible point of xkq is also within range
<         if (eimp_mode == 7 .or. eimp_mode == 8) then
<            !
<            xkq_ = xkq
<            do while (xkq_(1) < 0)
<               xkq_(1) = xkq_(1) + 1
<            enddo
<            do while (xkq_(1) >= 1)
<               xkq_(1) = xkq_(1) - 1
<            enddo
<            do while (xkq_(2) < 0)
<               xkq_(2) = xkq_(2) + 1
<            enddo
<            do while (xkq_(2) >= 1)
<               xkq_(2) = xkq_(2) - 1
<            enddo
<            do while (xkq_(3) < 0)
<               xkq_(3) = xkq_(3) + 1
<            enddo
<            do while (xkq_(3) >= 1)
<               xkq_(3) = xkq_(3) - 1
<            enddo
<            ijk_kq(1) = nint(xkq_(1)*nkf1)
<            ijk_kq(2) = nint(xkq_(2)*nkf2)
<            ijk_kq(3) = nint(xkq_(3)*nkf3)
<            ikq_ful = map_mesh_ful(ijk_kq(1)*nkf2*nkf3+ijk_kq(2)*nkf3+ijk_kq(3)+1)
< 
<            if (.not. epcheck) then
<               if (ful2rful(ikq_ful) == 0) then
< !                 write(*,*) ' energy of kq point ignored:', etf(ibndmin:ibndmax,ikq)*ryd2ev
<                  within_range = .false.
<               endif
<            endif
<            !
<         endif
<         !
<         CALL CPU_TIME (t9_1)
< 
2235,2263d1724
<            ! wavefunction at k+q
< 
<            if (eimp_mode == 7 .or. eimp_mode == 8) then
<               !
< !              call evcwan2bloch (xkq, irvec, ndegen_k, cufkq, nbndsub, nrr_k, evc_fkq, ig_max_red)
< 
<               if (.not. epcheck) then
<                  ikq_red = map_mesh_rful(ijk_kq(1)*nkf2*nkf3+ijk_kq(2)*nkf3+ijk_kq(3)+1)
<               else
<                  ikq_red = map_mesh_ful(ijk_kq(1)*nkf2*nkf3+ijk_kq(2)*nkf3+ijk_kq(3)+1)
<               endif
< 
<               if (ikq_red /= 0) then
<                  evc_fkq(:,:) = evc_fmesh(:,:,ikq_red)
< !                 write(stdout,*) ' ikq_red =', ikq_red
< !                 write(stdout,*) ' xkq =', xkq
< !                 write(stdout,*) ' xk(ikq_red) =', xkf_ful(:,ikq_red)
< !                 write(stdout,*) ' ijk_kq =', ijk_kq(1:3)
< !                 write(stdout,*) ' map_mesh_ful =', map_mesh_ful(1:3)
<               else
<                  write(*,*) ' ERROR. index of kq point:', ijk_kq(1)*nkf2*nkf3+ijk_kq(2)*nkf3+ijk_kq(3)+1
<                  write(*,*) ' kq point:', xkq_(1:3)
<                  write(*,*) ' energy of kq point:', etf(ibndmin:ibndmax,ikq)
<                  CALL errore('ephwann_shuffle','evc_fkq not found but within range',1)
<               endif
<               !
<            endif
<            !
<            CALL CPU_TIME (t9_2)
2269,2292c1730
< !CHECK: need to add e_ph_interp subroutine
<            if (eph_interp) then
<               !
<            else
<               if (.not. screen_polar) then
<                  CALL ephwan2bloch2 (nbndsub, nrr_q, irvec, ndegen_q, epmatwef, xxq, uf, cufkk, cufkq, epmatf(:,:,:,1,1), nmodes,1,1)
<               else
<                  CALL ephwan2bloch2 (nbndsub, nrr_q, irvec, ndegen_q, epmatwef, xxq, uf, cufkk, cufkq, epmatf(:,:,:,:,:), nmodes,neptemp,nepdope)
<               endif
<            endif
< 
<            !  when tranferring from Wanneir to Bloch
<            !  for the case of not using sreen_polar we only change epmatf(:,:,:,1,1)
<            !  here we need to copy
<            !
<            if (eph_interp .or. (.not. screen_polar)) then
<               do itemp = 1, neptemp
<                  do idope = 1, nepdope
<                     if ((itemp /= 1) .or. (idope /= 1)) &
<                        epmatf(:,:,:,itemp,idope) = epmatf(:,:,:,1,1)
<                  enddo
<               enddo
<            endif
< 
---
>            CALL ephwan2bloch2 (nbndsub, nrr_q, irvec, ndegen_q, epmatwef, xxq, uf, cufkk, cufkq, epmatf, nmodes)
2294,2295d1731
<            CALL CPU_TIME (t9_3)
< 
2306,2313c1742,1743
< 
<                        if (.not. screen_polar) then
<                           CALL rgd_blk_epw3(uf, epmatf(ibnd,jbnd,:,:,:), neptemp, nepdope, eph_vogl(:,:,:,iq), &
<                                             nmodes, bmatf(ibnd,jbnd), +1.d0)
<                        else
<                           CALL rgd_blk_epw3(uf, epmatf(ibnd,jbnd,:,:,:), neptemp, nepdope, eph_vogl(:,:,:,iq), &
<                                             nmodes, bmatf(ibnd,jbnd), +1.d0)
<                        endif
---
>                        CALL rgd_blk_epw3(uf, epmatf(ibnd,jbnd,:), eph_vogl(:,iq), &
>                                          nmodes, bmatf(ibnd,jbnd), +1.d0)
2320c1750
<            !
---
>            !    
2327,2423c1757,1759
<            if (eimp_mode == 7 .or. eimp_mode == 8) then
<               !
<               ! Fourier component of electron wavefunction products
<               !
<               eemat_f = 0
< 
<               do ibnd = ibndmin, ibndmax
<                  ibnd0 = ibnd-ibndmin+1
<                  !
<                  ind_g = 0
<                  do igz = -bg_max_red, bg_max_red
<                     do igy = -bg_max_red, bg_max_red
<                        do igx = -bg_max_red, bg_max_red
<                           !
<                           ind_g = ind_g + 1
<                           ig_shift = igz*dffts%nr2*dffts%nr1 + igy*dffts%nr1 + igx
<                           !
<                           evc_remap = 0.d0
<                           do ig = 1, ig_max_red
<                              if ((map_kq2k(ig,ind_g) >= 1) .and. (map_kq2k(ig,ind_g) <= ig_max_red)) &
<                                 evc_remap(ig) = evc_fk(map_kq2k(ig,ind_g),ibnd0)
<                           enddo
<                           !
<                           do jbnd = ibndmin, ibndmax
<                              jbnd0 = jbnd-ibndmin+1
<                              eemat_f(jbnd0,ibnd0,ind_g) = &   ! use reduced number of G points
<                                     ZDOTC (ig_max_red, evc_fkq(1,jbnd0), 1, evc_remap(1), 1)
<                           enddo
<                           !
<                        enddo
<                     enddo
<                  enddo
<               enddo
<               !
<               CALL CPU_TIME (t9_4)
< 
<               ! interpolate Fourier component of impurity potential
<               ! here the q-point used should correspond to the (k+q)-(k) used by wavefunctions
<               xxq_int = xxq
<               xxq_int(1) = xxq_int(1) - nint(xxq_int(1))
<               xxq_int(2) = xxq_int(2) - nint(xxq_int(2))
<               xxq_int(3) = xxq_int(3) - nint(xxq_int(3))
<               !
<               if (eimp_ls_mode == 0 .or. eimp_ls_mode == 2) then
<                  call eimp_interp_tetra(xxq_int, bg_max_red, ng_max_red, dvimpqf_sr)
<               else
<                  dvimpqf_sr = 0.d0
<               endif
< 
<               CALL CPU_TIME (t9_5)
<               !
<               ! calculate electron-impurity scattering matrix - short range plus long range
<               !
<               ! [IMPORTANT NOTE] this brings xq to first-BZ, but it is only centered around Gamma, not yet fully symmetric
<               xq_cart(1) = xxq(1) - NINT(xxq(1))
<               xq_cart(2) = xxq(2) - NINT(xxq(2))
<               xq_cart(3) = xxq(3) - NINT(xxq(3))
<               CALL cryst_to_cart ( 1, xq_cart, bg, 1 )   ! xq_cart in [2*pi/alat], [alat] being primitive unit cell lattice constant
<  
<               ! here the mapping should be established from xxq to the coarse mesh
< !              xq_cart(1:3) = xxq(1:3)
< 
<               CALL cryst_to_cart ( 1, xq_cart, bg, 1 )   ! xq_cart in [2*pi/alat]
<               !
<               ind_g = 0
<               eimpmat_f = (0.d0, 0.d0)
<               if (eimp_ls_mode < 2) then
<                  imp_charge_ = imp_charge
<               else
<                  imp_charge_ = 0.d0
<               endif
<               do igz = -bg_max_red, bg_max_red
<                  do igy = -bg_max_red, bg_max_red
<                     do igx = -bg_max_red, bg_max_red
<                        !
<                        ind_g = ind_g + 1
<                        G_cart = igx*bg(1:3,1) + igy*bg(1:3,2) + igz*bg(1:3,3)
<                        xqG = xq_cart + G_cart
<                        xqGl  = sqrt(xqG(1)**2 + xqG(2)**2 + xqG(3)**2) * (2.d0*pi/alat)
<                        !
<                        do idope = 1, nepdope
<                           do itemp = 1, neptemp
<                              ! note that the factor of 2*pi/hbar (hbar=1 in AU) is added later,
<                              ! specifically, pi is added in [selfen_elec.f90], while 2 is considered in later
<                              ! transport calculations
<                              dvimpqf_lr(itemp,idope) = - imp_charge_*(2.d0*(4.d0*pi)/omega/dielec0) / &
<                                          (xqGl**2.d0 + 1.d0/(L_D(itemp,idope)**2.d0))
<  
<                              eimpmat_f(:,:,itemp,idope) = eimpmat_f(:,:,itemp,idope) + &
<                                 (dvimpqf_sr(ind_g) + dvimpqf_lr(itemp,idope)) * eemat_f(:,:,ind_g)
<                           enddo
<                        enddo
<                     enddo
<                  enddo
<               enddo
<               !
<            endif
---
> !#ifdef __PARA
>  !    CALL mp_barrier(inter_pool_comm)
> !#endif
2425,2426c1761
< !           if ((epcheck) .and. (filqf /= '')) then
<            if (epcheck) then
---
>            if ((epcheck) .and. (filqf /= '')) then
2429c1764,1765
< 
---
>               !
>               write(*,*) ' print e-ph matrix at #pool:',my_pool_id, iq
2431c1767
<                  mbnd = NINT(nelec)/2 + 1
---
>                  ibnd = NINT(nelec)/2 + 1
2433c1769
<                  mbnd = NINT(nelec) + 1
---
>                  ibnd = NINT(nelec) + 1
2437,2513c1773,1774
<                  !
<                  write(*,*) ' ------------------------------------------------ '
<                  write(*,*) ' print e-ph matrix at #pool:',my_pool_id, iq
<                  write(*,*) ' check xq_cart :', xq_cart
< 
<                  ! test impurity matrix element
<                  eimpmat_r = (0.d0, 0.d0)
<                  do jbnd = ibndmin, ibndmax
<                     jbnd0 = jbnd-ibndmin+1
<                     do ibnd = ibndmin, ibndmax
<                        ibnd0 = ibnd-ibndmin+1
<                        !
<                        ind_g = 0
<                        do igz = -bg_max_red, bg_max_red
<                           do igy = -bg_max_red, bg_max_red
<                              do igx = -bg_max_red, bg_max_red
<                                 !
<                                 ind_g = ind_g + 1
<                                 eimpmat_r (jbnd,ibnd) = eimpmat_r (jbnd,ibnd) + &
< !                                        dvimp_q(1,igx+bg_max+1,igy+bg_max+1,igz+bg_max+1) * eemat_f(jbnd0,ibnd0,ind_g,iq)
<                                         dvimpqf_sr(ind_g) * eemat_f(jbnd0,ibnd0,ind_g)
<                              enddo
<                           enddo
<                        enddo
<                        !
< !                       do ind_g = 1, ng_max_red
< !                          eimpmat_r (jbnd,ibnd) = eimpmat_r (jbnd,ibnd) + &
< !                                  dvimpqf_sr(ind_g) * eemat_f(jbnd0,ibnd0,ind_g)
< !                       enddo
<                     enddo
<                  enddo
<            
<                  write(*,*) ' check evc_fk:'
<                  norm_evcfk = 0.d0
<                  do ig = 1, ig_max_red
<                     norm_evcfk = norm_evcfk + abs(evc_fk(ig,mbnd-ibndmin+1))**2.d0
<                  enddo
<                  write(*,*) ' norm_evcfk =', norm_evcfk
< 
<                  write(*,*)
<                  write(*,*) ' ig_max_red =', ig_max_red
<                  write(*,*) ' check eemat_f at G=0:'
<                  ind_g = 0
<                  do igz = -bg_max_red, bg_max_red
<                     do igy = -bg_max_red, bg_max_red
<                        do igx = -bg_max_red, bg_max_red
<                           !
<                           ind_g = ind_g + 1
<                           if ((igy == 0) .and. (igz == 0)) then
<                              if (cond_find) then
<                                 write(*,*) igz, igy, igx, eemat_f(mbnd-ibndmin+1,mbnd-ibndmin+1,ind_g)
<                              elseif (vale_find) then
<                                 write(*,*) igz, igy, igx, eemat_f(mbnd-ibndmin,mbnd-ibndmin,ind_g)
<                              endif
<                           endif
<                        enddo
<                     enddo
<                  enddo
<                  write(*,*) ' check dvimp_q at G=0:', dvimp_q(1,bg_max+1,bg_max+1,bg_max+1)
<                  write(*,*) ' check dvimpqf_sr at G=0:', dvimpqf_sr(bg_max_red*((2*bg_max_red+1)**2)+bg_max_red*(2*bg_max_red+1)+bg_max_red+1)
<       
<                  write(*,*)
<                  write(*,*) ' xxq = ', xxq(:)
<                  !write(*,*) ' eimpmat_r at CBM:', eimpmat_r(mbnd,mbnd)
<                  write(*,*) ' mbnd =', mbnd
<                  if (cond_find) then
<                     write(*,*) ' eimpmat_r at CBM:', eimpmat_r(mbnd,mbnd)
<                  elseif (vale_find) then
<                     write(*,*) ' eimpmat_r at VBM:', eimpmat_r(mbnd-3,mbnd-3), &
<                                                      eimpmat_r(mbnd-2,mbnd-2), eimpmat_r(mbnd-1,mbnd-1)
<                  endif
<                  !
<               endif
<               !
<               if (cond_find) then
<                  do ibnd_c = mbnd, mbnd+nbnd_c-1
<                     do jbnd_c = mbnd, mbnd+nbnd_c-1
---
>                  do ibnd_c = ibnd, ibnd+nbnd_c-1
>                     do jbnd_c = ibnd, ibnd+nbnd_c-1
2516,2517c1777,1778
<                                           wf_ful(1:nmodes,1,1,iq), &
<                                           abs(epmatf(ibnd_c,jbnd_c,1:nmodes,1,1))
---
>                                           wf_ful(1:nmodes,iq), &
>                                           abs(epmatf(ibnd_c,jbnd_c,1:nmodes))
2528,2529c1789,1790
<                  do ibnd_v = mbnd-nbnd_v, mbnd-1
<                     do jbnd_v = mbnd-nbnd_v, mbnd-1
---
>                  do ibnd_v = ibnd-nbnd_v, ibnd-1
>                     do jbnd_v = ibnd-nbnd_v, ibnd-1
2532,2533c1793,1794
<                                           wf_ful(1:nmodes,1,1,iq), &
<                                           abs(epmatf(ibnd_v,jbnd_v,1:nmodes,1,1))
---
>                                           wf_ful(1:nmodes,iq), &
>                                           abs(epmatf(ibnd_v,jbnd_v,1:nmodes))
2544d1804
<            !    
2549,2553c1809
<                  do itemp = 1, neptemp
<                     do idope = 1, nepdope
<                        epmatf(:,:,ignph_mode(imode),itemp,idope) = (0.0d0,0.0d0)
<                     enddo
<                  enddo
---
>                  epmatf(:,:,ignph_mode(imode)) = (0.0d0,0.0d0)
2561,2562c1817
<               !ERROR: writing epmatf is not correct
<               WRITE (17017,REC=iq) epmatf(ibndmin:ibndmax,ibndmin:ibndmax,1:nmodes,1,1)
---
>               WRITE (17017,REC=iq) epmatf(ibndmin:ibndmax,ibndmin:ibndmax,1:nmodes)
2572c1827
<                        epf17(iq,jbnd0,ibnd0,imode,:,:) = epmatf(jbnd,ibnd,imode,:,:)
---
>                        epf17(iq,jbnd0,ibnd0,imode) = epmatf(jbnd,ibnd,imode)
2576,2580c1831,1835
<                        eimpf_sr(iq,jbnd0,ibnd0) = eimpmatf(jbnd,ibnd)
<                     endif
<                     !
<                     if (eimp_mode == 7 .or. eimp_mode == 8) then
<                        eimpf_full(:,:,:,:,iq) = eimpmat_f(:,:,:,:)
---
>                        if (alloy_pot) then 
>                         alelpp(iq,jbnd0,ibnd0) = eimpmatf(jbnd,ibnd)
>                        else
>                         eimpf_sr(iq,jbnd0,ibnd0) = eimpmatf(jbnd,ibnd)
>                        endif
2582d1836
<                     !
2593,2603d1846
<         CALL CPU_TIME (t9_6)
< 
<         if (within_range .and. .false.) then
<            write(stdout,*) ' time test, iq#:', iq
<            write(stdout,*) ' total: t9_1 -> t9_6:', t9_6 - t9_1
<            write(stdout,*) ' t9_1 -> t9_2:', t9_2 - t9_1
<            write(stdout,*) ' t9_2 -> t9_3:', t9_3 - t9_2
<            write(stdout,*) ' t9_3 -> t9_4:', t9_4 - t9_3
<            write(stdout,*) ' t9_4 -> t9_5:', t9_5 - t9_4
<            write(stdout,*) ' t9_5 -> t9_6:', t9_6 - t9_5
<         endif
2610c1853,1856
<      !     
---
>      ! 
> !#ifdef __PARA
> !     CALL mp_barrier(inter_pool_comm)
> !#endif  
2611a1858,1860
> !#ifdef __PARA
> !     IF (alloy_pot)  CALL mp_sum (alelpp,inter_pool_comm)
> !#ENDIF
2618a1868,1869
>      ! write(*,*) 'Calling selfen_elec ik_red =', ik_red, " / ik_stop = ", ik_stop, ' at pool:', my_pool_id
>      !
2620a1872,1873
>      ! write(*,*) 'Finish selfen_elec ik_red =', ik_red, " / ik_stop = ", ik_stop, ' at pool:', my_pool_id
>      !
2622c1875
<         nscat_all(ik_red) = nscat
---
>        nscat_all(ik_red) = nscat
2656c1909,1910
<   ! 
---
>   !
>   ! write(*,*) 'finish k loop at pool:', my_pool_id
2666a1921
>   ! write(*,*) 'Before mp_barrier mp_sum sigmai_mode_all_emi/abs'
2671a1927,1932
>   CALL mp_sum (sigmai_mode_all_inter,inter_pool_comm)
>   CALL mp_sum (sigmai_mode_all_intra,inter_pool_comm)
> 
> 
>   !write(*,*) 'After mp_barrier mp_sum sigmai_mode_all_emi/abs'
> 
2673a1935,1938
>   if (alloy_pot)  CALL mp_sum (sigmai_mode_all_alloy_inter,inter_pool_comm)
>   if (alloy_pot)  CALL mp_sum (sigmai_mode_all_alloy_intra,inter_pool_comm)
> 
>   !write(*,*) 'After mp_sum sigmai_mode_all_ela_intra/inter sigmai_mode_all_alloy'
2683c1948
<   IF (save_t_el) THEN
---
>   IF (save_t_el .AND. .NOT. phdrag) THEN
2687a1953
>  ! write(*,*) 'finish line 1930'
2719c1985
<         !   IF (etf_all(ibnd,ik_red) .GT. ef_m) etf_all(ibnd,ik_red) = etf_all(ibnd,ik_red) + delta_egap
---
>          !  IF (etf_all(ibnd,ik_red) .GT. ef_m) etf_all(ibnd,ik_red) = etf_all(ibnd,ik_red) + delta_egap
2723c1989
<         ENDDO
---
>         ENDDO 
2755a2022,2025
>   IF (phdrag) CALL phdrag_shuffle (nqc, xqc)
>   IF (alloy_read) CALL read_alloy_el ()
>   !
>   !
2838c2108,2109
<      WRITE (stdout,'(/5x,a/)') 'Automatically save following variables to disk in ph-e calculation:'
---
>      WRITE (stdout,'(/5x,a)') 'Electron part will be export automatically when bte = 2'
>      WRITE (stdout,'(5x,a/)') 'Read etf(k+q), etf_ks(k+q) and cufkk(k+q) from saved files to reduce the time consumption'
2842d2112
<      IF (save_t_el) WRITE (stdout,'(/5x,a)') 'Read etf(k+q), etf_ks(k+q) and cufkk(k+q) from saved files to reduce the time consumption'
2870c2140
<         ALLOCATE(eph_vogl(nmodes,neptemp,nepdope,nq_irr))
---
>         ALLOCATE(eph_vogl(nmodes,nq_irr))
2894c2164
<               CALL polar_eph (uf_cart, xxq, eph_vogl(:,:,:,iq), neptemp, nepdope)
---
>               CALL polar_eph (uf_cart, xxq, eph_vogl(:,iq))
2896c2166
<               eph_vogl(:,:,:,iq) = 0.0d0
---
>               eph_vogl(:,iq) = 0.0d0
2954,2955c2224,2225
<         !   IF (etf_ham(ibnd) .GT. ef_m) etf_ham(ibnd) = etf_ham(ibnd) + delta_egap
<         !ENDDO
---
>          !  IF (etf_ham(ibnd) .GT. ef_m) etf_ham(ibnd) = etf_ham(ibnd) + delta_egap
>         !ENDDO 
2958c2228
<         ENDDO  
---
>         ENDDO 
2967a2238
> #ifdef __PARA
2968a2240
> #ENDIF
3016d2287
<      !
3024c2295
<       ALLOCATE (epmatf(nbndsub, nbndsub, nmodes, neptemp, nepdope))
---
>       ALLOCATE (epmatf(nbndsub, nbndsub, nmodes))
3034c2305
<       IF (.NOT. save_m_mat) ALLOCATE (epf17 (nk_ful, nbnd_red, nbnd_red, nmodes, neptemp, nepdope)) 
---
>       IF (.NOT. save_m_mat) ALLOCATE (epf17 (nk_ful, nbnd_red, nbnd_red, nmodes)) 
3168,3173c2439,2444
<               !DO ibnd = 1, nbndsub
<               !   IF (etf(ibnd,ikq) .GT. ef_m) etf(ibnd,ikq) = etf(ibnd,ikq) + delta_egap
<               !ENDDO
<               DO ibnd = vbnd_num+1, nbndsub
<                  etf(ibnd,ikq) = etf(ibnd,ikq) + delta_egap
<               ENDDO
---
>              ! DO ibnd = 1, nbndsub
>              !    IF (etf(ibnd,ikq) .GT. ef_m) etf(ibnd,ikq) = etf(ibnd,ikq) + delta_egap
>              ! ENDDO
>         DO ibnd = vbnd_num+1, nbndsub
>            etf(ibnd,ikq) = etf(ibnd,ikq) + delta_egap
>         ENDDO 
3204c2475
<                       (etf(jbnd,ikq) .GE. vbnd_emax-vfsthick .AND. etf(jbnd,ikq) .LE. cbnd_emin+cfsthick) ) within_range = .TRUE.
---
>                       (etf(jbnd,ikq) .GE. vbnd_emax-vfsthick-epthick .AND. etf(jbnd,ikq) .LE. cbnd_emin+cfsthick+epthick) ) within_range = .TRUE.
3232c2503
<                           CALL rgd_blk_epw3(uf_irr(:,:,iq), epmatf(ibnd,jbnd,:,:,:), neptemp, nepdope, eph_vogl(:,:,:,iq), nmodes, bmatf(ibnd,jbnd), +1.d0)
---
>                           CALL rgd_blk_epw3(uf_irr(:,:,iq), epmatf(ibnd,jbnd,:), eph_vogl(:,iq), nmodes, bmatf(ibnd,jbnd), +1.d0)
3249,3250c2520
<                  ! writing epmatf is wrong
<                  WRITE (17017,REC=ik) epmatf(ibndmin:ibndmax,ibndmin:ibndmax,1:nmodes,1,1)
---
>                  WRITE (17017,REC=ik) epmatf(ibndmin:ibndmax,ibndmin:ibndmax,1:nmodes)
3260c2530
<                           epf17(ik,jbnd0,ibnd0,imode,:,:) = epmatf(jbnd,ibnd,imode,:,:)
---
>                           epf17(ik,jbnd0,ibnd0,imode) = epmatf(jbnd,ibnd,imode)
3328a2599,2601
>  !    IF (shengbte_read) CALL read_shengbte ()
>  !    IF (shengbte_read) CALL phph_export ()
>  !    IF ((shengbte_read .EQ. .TRUE.) .AND. (file_exist)) CALL phcheck_scat (filename_check)
3331d2603
<      CALL mp_barrier (inter_pool_comm)
3335a2608
>  ! write(*,*) 'Before deallocate_shuffle'
3338a2612,2613
>  ! write(*,*) 'After deallocate_shuffle'
>   !
3601,3602c2876
<   USE epwcom,    ONLY : nqf1, nqf2, nqf3, smearing, bte, save_m_ph, ph_read, &
<                         screen_polar, neptemp, nepdope
---
>   USE epwcom,    ONLY : nqf1, nqf2, nqf3, smearing, bte, save_m_ph, ph_read
3617d2890
<   REAL(KIND=DP)       :: vph_temp(3,nmodes,neptemp,nepdope)
3619d2891
< !ERROR, vph_ful is not allocated to [neptemp,nepdope] when considering carrier screeening effect
3635,3643c2907,2909
<      if (screen_polar) then
<         OPEN (99901,FILE=filename1,FORM='unformatted',ACCESS='direct',RECL=nmodes*neptemp*nepdope*DP,STATUS='old')
<         OPEN (99902,FILE=filename2,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*nmodes*neptemp*nepdope*DP,STATUS='old')
<         OPEN (99903,FILE=filename3,FORM='unformatted',ACCESS='direct',RECL=3*nmodes*neptemp*nepdope*DP,STATUS='old')
<      else
<         OPEN (99901,FILE=filename1,FORM='unformatted',ACCESS='direct',RECL=nmodes*DP,STATUS='old')
<         OPEN (99902,FILE=filename2,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*nmodes*DP,STATUS='old')
<         OPEN (99903,FILE=filename3,FORM='unformatted',ACCESS='direct',RECL=3*nmodes*DP,STATUS='old')
<      endif
---
>      OPEN (99901,FILE=filename1,FORM='unformatted',ACCESS='direct',RECL=nmodes*DP,STATUS='old')
>      OPEN (99902,FILE=filename2,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*nmodes*DP,STATUS='old')
>      OPEN (99903,FILE=filename3,FORM='unformatted',ACCESS='direct',RECL=3*nmodes*DP,STATUS='old')
3646,3654c2912,2914
<      if (screen_polar) then
<         DO iq = 1, nq_ful
<            READ (99901,REC=iq) wf_ful(1:nmodes,1:neptemp,1:nepdope,iq)
<         ENDDO 
<      else
<         DO iq = 1, nq_ful
<            READ (99901,REC=iq) wf_ful(1:nmodes,1,1,iq)
<         ENDDO 
<      endif
---
>      DO iq = 1, nq_ful
>         READ (99901,REC=iq) wf_ful(1:nmodes,iq)
>      ENDDO 
3659,3667c2919,2921
<         if (screen_polar) then
<            DO iq = 1, nq_ful
<               READ (99902,REC=iq) uf_ful(1:nmodes,1:nmodes,1:neptemp,1:nepdope,iq)
<            ENDDO
<         else
<            DO iq = 1, nq_ful
<               READ (99902,REC=iq) uf_ful(1:nmodes,1:nmodes,1,1,iq)
<            ENDDO
<         endif
---
>         DO iq = 1, nq_ful
>            READ (99902,REC=iq) uf_ful(1:nmodes,1:nmodes,iq)
>         ENDDO
3672,3681c2926,2928
<      if (screen_polar) then
<         DO iq = 1, nq_ful
<            READ (99903,REC=iq) vph_temp(1:3,1:nmodes,1:neptemp,1:nepdope)
<            vph_ful(1:3,1:nmodes,iq) = vph_temp(1:3,1:nmodes,1,1)
<         ENDDO
<      else
<         DO iq = 1, nq_ful
<            READ (99903,REC=iq) vph_ful(1:3,1:nmodes,iq)
<         ENDDO
<      endif
---
>      DO iq = 1, nq_ful
>         READ (99903,REC=iq) vph_ful(1:3,1:nmodes,iq)
>      ENDDO
3710c2957
<   USE epwcom,    ONLY : nqf1, nqf2, nqf3, ephl_read, neptemp, nepdope
---
>   USE epwcom,    ONLY : nqf1, nqf2, nqf3, ephl_read
3735c2982
<      OPEN (99901,FILE=filename,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*neptemp*nepdope*DP,STATUS='old')
---
>      OPEN (99901,FILE=filename,FORM='unformatted',ACCESS='direct',RECL=2*nmodes*DP,STATUS='old')
3737c2984
<         READ (99901,REC=iq) eph_vogl(1:nmodes,1:neptemp,1:nepdope,iq)
---
>         READ (99901,REC=iq) eph_vogl(1:nmodes,iq)
3759,3760c3006,3009
<                     sigmai_mode_all_ela_intra, sigmai_mode_all_ela_inter, &
<                     etf_all, vel_all, wf_irr, vph_irr, &
---
>                     sigmai_mode_all_ela_intra, sigmai_mode_all_ela_inter, sigmai_mode_all_alloy_inter, &
>                     sigmai_mode_all_intra, sigmai_mode_all_inter, sigmai_mode_all_intra, &
>                     sigmai_mode_all_alloy_intra, &
>                     etf_all, vel_all, wf_irr, vph_irr, wf_all, vph_all, uf_all, &
3762c3011
<                     epf17, etf, etf_ks, wf, dmef, vmef, eph_vogl
---
>                     epf17, etf, etf_ks, wf, dmef, vmef, eph_vogl, eimpmatq, eimpmatwp, eimpmatwe
3782a3032,3034
>   IF (ALLOCATED (wf_all))              DEALLOCATE (wf_all)
>   IF (ALLOCATED (vph_all))             DEALLOCATE (vph_all)
>   IF (ALLOCATED (uf_all))              DEALLOCATE (uf_all)
3792a3045,3046
>      IF (ALLOCATED (sigmai_mode_all_alloy_intra)) DEALLOCATE (sigmai_mode_all_alloy_intra)
>      IF (ALLOCATED (sigmai_mode_all_alloy_inter)) DEALLOCATE (sigmai_mode_all_alloy_inter)
3793a3048,3052
>   IF (ALLOCATED (eimpmatq)) DEALLOCATE (eimpmatq)
>   IF (ALLOCATED (eimpmatwp)) DEALLOCATE (eimpmatwp)
>   IF (ALLOCATED (eimpmatwe)) DEALLOCATE (eimpmatwe)
>   IF (ALLOCATED (sigmai_mode_all_intra)) DEALLOCATE (sigmai_mode_all_intra)
>   IF (ALLOCATED (sigmai_mode_all_inter)) DEALLOCATE (sigmai_mode_all_inter)
3805a3065
> 
3912,4160d3171
< 
< ! =========================================================================
< SUBROUTINE eimp_interp_tetra (xq, bg_max_red, ng_max_red, dvimp_qf)
< ! =========================================================================
<    !
<    USE kinds,         ONLY : DP
<    USE pwcom,         ONLY : bg
<    USE phcom,         ONLY : nq1, nq2, nq3
<    use elph2,         only : dvimp_qc, bg_max, ng_max
<    use io_global,     only : stdout
<  
<    implicit none
<  
<    integer, intent(in) :: bg_max_red, ng_max_red
<    real(kind=DP), intent(in)   :: xq(3)
<    complex(kind=DP), intent(out) :: dvimp_qf(ng_max_red)
<  
<    integer :: nq000(4), nq100(4), nq010(4), nq001(4), &
<               nq101(4), nq011(4), nq110(4), nq111(4), &
<               iG1, iG1p, iG2, iG2p, iG3, iG3p, &
<               iq1, iq1p, iq2, iq2p, iq3, iq3p, &
<               igx, igy, igz, ind_g, ind_gx, ind_gy, ind_gz
<    real(kind=DP) :: xq1, xq2, xq3, xq000(3), xq100(3), xq010(3), xq001(3), &
<                     xq101(3), xq011(3), xq110(3), xq111(3), xq_v1(3), xq_v2(3), &
<                     xq_v3(3), xq_v4(3), xqint(3), interpx, interpy, interpz
<    complex(kind=DP) :: dvimpqf_int, dvimpq_v1, dvimpq_v2, dvimpq_v3, &
<                        dvimpq_v4
< 
<    dvimp_qf = 0.d0
<    iG1 = 0
<    iG2 = 0
<    iG3 = 0
< 
<    xq1 = xq(1)
<    do while (xq1 < 0)
<       xq1 = xq1 + 1
<       iG1 = iG1 - 1
<    enddo
<    do while (xq1 >= 1)
<       xq1 = xq1 - 1
<       iG1 = iG1 + 1
<    enddo
< 
<    xq2 = xq(2)
<    do while (xq2 < 0)
<       xq2 = xq2 + 1
<       iG2 = iG2 - 1
<    enddo
<    do while (xq2 >= 1)
<       xq2 = xq2 - 1
<       iG2 = iG2 + 1
<    enddo
< 
<    xq3 = xq(3)
<    do while (xq3 < 0)
<       xq3 = xq3 + 1
<       iG3 = iG3 - 1
<    enddo
<    do while (xq3 >= 1)
<       xq3 = xq3 - 1
<       iG3 = iG3 + 1
<    enddo
< 
<    iG1p = iG1
<    iq1 = int(xq1*nq1)
<    interpx = xq1*nq1 - iq1
<    iq1p = iq1 + 1
<    if (iq1p == nq1) then
<       iq1p = 0
<       iG1p = iG1p + 1
<    endif
< 
<    iG2p = iG2
<    iq2 = int(xq2*nq2)
<    interpy = xq2*nq2 - iq2
<    iq2p = iq2 + 1
<    if (iq2p == nq2) then
<       iq2p = 0
<       iG2p = iG2p + 1
<    endif
< 
<    iG3p = iG3
<    iq3 = int(xq3*nq3)
<    interpz = xq3*nq3 - iq3
<    iq3p = iq3 + 1
<    if (iq3p == nq3) then
<       iq3p = 0
<       iG3p = iG3p + 1
<    endif
< 
<    nq000(1:4) = (/iq1*nq2*nq3 + iq2*nq3 + iq3 + 1, iG1, iG2, iG3/)
<    nq100(1:4) = (/iq1p*nq2*nq3+ iq2*nq3 + iq3 + 1, iG1p,iG2, iG3/)
<    nq010(1:4) = (/iq1*nq2*nq3 + iq2p*nq3+ iq3 + 1, iG1, iG2p,iG3/)
<    nq001(1:4) = (/iq1*nq2*nq3 + iq2*nq3 + iq3p+ 1, iG1, iG2, iG3p/)
<    nq101(1:4) = (/iq1p*nq2*nq3+ iq2*nq3 + iq3p+ 1, iG1p,iG2, iG3p/)
<    nq011(1:4) = (/iq1*nq2*nq3 + iq2p*nq3+ iq3p+ 1, iG1, iG2p,iG3p/)
<    nq110(1:4) = (/iq1p*nq2*nq3+ iq2p*nq3+ iq3 + 1, iG1p,iG2p,iG3/)
<    nq111(1:4) = (/iq1p*nq2*nq3+ iq2p*nq3+ iq3p+ 1, iG1p,iG2p,iG3p/)
< 
< !   write(stdout,*) ' xq =', xq
< !   write(stdout,*) ' iG =', iG1,iG2,iG3
< !   write(stdout,*) ' iq =', iq1,iq2,iq3
< !   write(stdout,*) ' interp =', interpx,interpy,interpz
< !   write(stdout,*) ' nq000 =', nq000
< 
<    xq000 = 0.d0
<    xq100 = bg(1:3,1)
<    xq010 = bg(1:3,2)
<    xq001 = bg(1:3,3)
<    xq110 = bg(1:3,1) + bg(1:3,2)
<    xq101 = bg(1:3,1) + bg(1:3,3)
<    xq011 = bg(1:3,2) + bg(1:3,3)
<    xq111 = bg(1:3,1) + bg(1:3,2) + bg(1:3,3)
<    xqint = interpx*bg(1:3,1) + interpy*bg(1:3,2) + interpz*bg(1:3,3)
<    CALL cryst_to_cart ( 1, xq000, bg, 1 )
<    CALL cryst_to_cart ( 1, xq100, bg, 1 )
<    CALL cryst_to_cart ( 1, xq010, bg, 1 )
<    CALL cryst_to_cart ( 1, xq001, bg, 1 )
<    CALL cryst_to_cart ( 1, xq110, bg, 1 )
<    CALL cryst_to_cart ( 1, xq101, bg, 1 )
<    CALL cryst_to_cart ( 1, xq011, bg, 1 )
<    CALL cryst_to_cart ( 1, xq111, bg, 1 )
<    CALL cryst_to_cart ( 1, xqint, bg, 1 )
< 
<    ! interpolate the Fourier component of defect potential
< 
<    ind_g = 0
<    do igz = -bg_max_red, bg_max_red
<       ind_gz = igz+bg_max+1
<       do igy = -bg_max_red, bg_max_red
<          ind_gy = igy+bg_max+1
<          do igx = -bg_max_red, bg_max_red
<             ind_gx = igx+bg_max+1
<             !
<             ind_g = ind_g + 1
< 
<             ! find the tetrahedra inside the cube that encloses the q-point
<  
<             if (interpx>=interpy) then
<                if (interpz>=interpx) then
<                   dvimpq_v1 = dvimp_qc(nq001(1),nq001(2)+ind_gx,nq001(3)+ind_gy,nq001(4)+ind_gz)
<                   dvimpq_v2 = dvimp_qc(nq101(1),nq101(2)+ind_gx,nq101(3)+ind_gy,nq101(4)+ind_gz)
<                   dvimpq_v3 = dvimp_qc(nq000(1),nq000(2)+ind_gx,nq000(3)+ind_gy,nq000(4)+ind_gz)
<                   dvimpq_v4 = dvimp_qc(nq111(1),nq111(2)+ind_gx,nq111(3)+ind_gy,nq111(4)+ind_gz)
<                   xq_v1 = xq001
<                   xq_v2 = xq101
<                   xq_v3 = xq000
<                   xq_v4 = xq111
<                else
<                   if (interpz>=interpy) then
<                      dvimpq_v1 = dvimp_qc(nq000(1),nq000(2)+ind_gx,nq000(3)+ind_gy,nq000(4)+ind_gz)
<                      dvimpq_v2 = dvimp_qc(nq101(1),nq101(2)+ind_gx,nq101(3)+ind_gy,nq101(4)+ind_gz)
<                      dvimpq_v3 = dvimp_qc(nq100(1),nq100(2)+ind_gx,nq100(3)+ind_gy,nq100(4)+ind_gz)
<                      dvimpq_v4 = dvimp_qc(nq111(1),nq111(2)+ind_gx,nq111(3)+ind_gy,nq111(4)+ind_gz)
<                      xq_v1 = xq000
<                      xq_v2 = xq101
<                      xq_v3 = xq100
<                      xq_v4 = xq111
<                   else
<                      dvimpq_v1 = dvimp_qc(nq000(1),nq000(2)+ind_gx,nq000(3)+ind_gy,nq000(4)+ind_gz)
<                      dvimpq_v2 = dvimp_qc(nq110(1),nq110(2)+ind_gx,nq110(3)+ind_gy,nq110(4)+ind_gz)
<                      dvimpq_v3 = dvimp_qc(nq100(1),nq100(2)+ind_gx,nq100(3)+ind_gy,nq100(4)+ind_gz)
<                      dvimpq_v4 = dvimp_qc(nq111(1),nq111(2)+ind_gx,nq111(3)+ind_gy,nq111(4)+ind_gz)
<                      xq_v1 = xq000
<                      xq_v2 = xq110
<                      xq_v3 = xq100
<                      xq_v4 = xq111
<                   endif
<                endif
<             else
<                if (interpz<=interpx) then
<                   dvimpq_v1 = dvimp_qc(nq010(1),nq010(2)+ind_gx,nq010(3)+ind_gy,nq010(4)+ind_gz)
<                   dvimpq_v2 = dvimp_qc(nq111(1),nq111(2)+ind_gx,nq111(3)+ind_gy,nq111(4)+ind_gz)
<                   dvimpq_v3 = dvimp_qc(nq110(1),nq110(2)+ind_gx,nq110(3)+ind_gy,nq110(4)+ind_gz)
<                   dvimpq_v4 = dvimp_qc(nq000(1),nq000(2)+ind_gx,nq000(3)+ind_gy,nq000(4)+ind_gz)
<                   xq_v1 = xq010
<                   xq_v2 = xq111
<                   xq_v3 = xq110
<                   xq_v4 = xq000
<                else
<                   if (interpz<=interpy) then
<                      dvimpq_v1 = dvimp_qc(nq011(1),nq011(2)+ind_gx,nq011(3)+ind_gy,nq011(4)+ind_gz)
<                      dvimpq_v2 = dvimp_qc(nq111(1),nq111(2)+ind_gx,nq111(3)+ind_gy,nq111(4)+ind_gz)
<                      dvimpq_v3 = dvimp_qc(nq010(1),nq010(2)+ind_gx,nq010(3)+ind_gy,nq010(4)+ind_gz)
<                      dvimpq_v4 = dvimp_qc(nq000(1),nq000(2)+ind_gx,nq000(3)+ind_gy,nq000(4)+ind_gz)
<                      xq_v1 = xq011
<                      xq_v2 = xq111
<                      xq_v3 = xq010
<                      xq_v4 = xq000
<                   else
<                      dvimpq_v1 = dvimp_qc(nq001(1),nq001(2)+ind_gx,nq001(3)+ind_gy,nq001(4)+ind_gz)
<                      dvimpq_v2 = dvimp_qc(nq011(1),nq011(2)+ind_gx,nq011(3)+ind_gy,nq011(4)+ind_gz)
<                      dvimpq_v3 = dvimp_qc(nq111(1),nq111(2)+ind_gx,nq111(3)+ind_gy,nq111(4)+ind_gz)
<                      dvimpq_v4 = dvimp_qc(nq000(1),nq000(2)+ind_gx,nq000(3)+ind_gy,nq000(4)+ind_gz)
<                      xq_v1 = xq001
<                      xq_v2 = xq011
<                      xq_v3 = xq111
<                      xq_v4 = xq000
<                   endif
<                endif
<             endif
<             !
<             ! check
< !            if ((igx == 0) .and. (igy == 0) .and. (igz == 0)) then
< !               write(stdout,*)
< !               write(stdout,*) ' inside eimp_interp, test:'
< !               write(stdout,*) ' xq_int', xqint
< !               write(stdout,*) ' xq_v1..4', xq_v1, xq_v2, xq_v3, xq_v4
< !               write(stdout,*) ' dvimpq_v1..4', dvimpq_v1, dvimpq_v2, dvimpq_v3, dvimpq_v4
< !               write(stdout,*) ' dvimp_qc000:', dvimp_qc(nq000(1),nq000(2)+ind_gx,nq000(3)+ind_gy,nq000(4)+ind_gz)
< !            endif
< 
<             call tetra_interpl(xqint, xq_v1, xq_v2, xq_v3, xq_v4, &
<                                dvimpqf_int, dvimpq_v1, dvimpq_v2, dvimpq_v3, dvimpq_v4)
<  
<             dvimp_qf(ind_g) = dvimpqf_int
<             !
<          enddo
<       enddo
<    enddo
<    !
< END SUBROUTINE eimp_interp_tetra
< 
< 
< subroutine tetra_interpl(x0,x1,x2,x3,x4,f0,f1,f2,f3,f4)
<   USE kinds,         ONLY : DP
<   use io_global,     only : stdout
< 
<   implicit none
<   integer     :: info, ipiv(4)
<   real(DP)    :: x0(3), x1(3), x2(3), x3(3), x4(3)
<   complex(DP) :: f0, f1, f2, f3, f4
<   real(DP)    :: eta_trans(4,4), eta_list(4), x0_list(4)
< 
<   x0_list(1) = 1.d0
<   x0_list(2:4) = x0(1:3)
< 
<   eta_trans(1:4,1) = (/1.d0, x1(1), x1(2), x1(3)/)
<   eta_trans(1:4,2) = (/1.d0, x2(1), x2(2), x2(3)/)
<   eta_trans(1:4,3) = (/1.d0, x3(1), x3(2), x3(3)/)
<   eta_trans(1:4,4) = (/1.d0, x4(1), x4(2), x4(3)/)
< 
<   CALL DGESV(4, 1, eta_trans, 4, ipiv, x0_list, 4, info)
< 
<   eta_list = x0_list
<   f0 = eta_list(1)*f1 + eta_list(2)*f2 + eta_list(3)*f3 + eta_list(4)*f4
<   !
< end subroutine tetra_interpl
< 
Only in ./: ephwann_shuffle.o
diff ./epwcom.f90 ../../epw-qian/src/epwcom.f90
17,18c17,18
<   USE kinds,      ONLY :  DP
<   USE parameters, ONLY: npk
---
>   USE kinds,      ONLY : DP
>   USE parameters, ONLY : npk
33,35c33,35
<   REAL(KIND=DP)     :: egap_rbm, dt, efield, gradt, relax_time, mixing
<   LOGICAL           :: edos_read, asr_eph, ph_read, ephl_read, fscheck, &
<                        ifc_read, elop
---
>   REAL(KIND=DP)     :: egap_rbm, dt, efield, gradt, relax_time, mixing, epthick, phwmax, phkmax
>   LOGICAL           :: edos_read, asr_eph, ph_read, ephl_read, fscheck, ifc_read, elop, &
>                        phdrag, shengbte_read, alloy_read, alloy_pot ! Qian, for phonon drag and alloy-phon scattering
37a38
>   REAL(KIND=DP)      :: frac_type(2) ! Qian, for alloy-elec scattering, limited to binary alloy
45c46
<        nw_specfun, eimp_mode, eimp_ls_mode
---
>        nw_specfun, eimp_mode
117c118
<        dvimpsr, epbjump, epbrestore, eimp_sr, screen_polar, dvimpq, eph_interp
---
>        dvimpsr, epbjump, epbrestore, eimp_sr, screen_polar
178d178
<   !
Only in ./: epwcom.mod
Only in ./: epwcom.o
Only in ./: epw_explore.mod
Only in ./: epw_explore.o
Only in ./: epw_init.o
Only in ./: epw.o
diff ./epw_readin.f90 ../../epw-qian/src/epw_readin.f90
63c63,67
<                             vg_el, vg_ph, relax_time, fscheck, ifc_read, eimp_mode, bte_o, &
---
>                             vg_el, vg_ph, relax_time, fscheck, ifc_read, epthick, phdrag, phwmax, phkmax, &
>                             ! Qian 
>                             shengbte_read, alloy_read, alloy_pot, frac_type, &
>                             ! zjw
>                             eimp_mode, bte_o, &
66,67c70
<                             epbrestore, eimp_sr, elop, screen_polar, dvimpq, eimp_ls_mode, &
<                             eph_interp
---
>                             epbrestore, eimp_sr, elop, screen_polar
71c74
<   USE constants_epw, ONLY : ryd2mev, ryd2ev, ev2cmm1, kelvin2eV, au2fs, kB
---
>   USE constants_epw, ONLY : ryd2mev, ryd2ev, ev2cmm1, kelvin2eV, au2fs, au2ps, kB, ryd2thz
133c136,138
<        fscheck, ifc_read, mixing, eimp_mode, bte_o, dielec, imp_charge, &
---
>        fscheck, ifc_read, mixing, epthick, phdrag, phwmax, phkmax, &
>        shengbte_read, alloy_read, alloy_pot, frac_type, & ! Qian
>        eimp_mode, bte_o, dielec, imp_charge, &
136c141
<        eimp_sr, elop, screen_polar, dvimpq, eimp_ls_mode, eph_interp
---
>        eimp_sr, elop, screen_polar ! zjw
427a433
>   epthick  = 0.0d0   ! eV
443c449
<   smearing     = 'lortz'
---
>   smearing     = 'tetra'
458a465,469
>   phdrag       = .FALSE.
>   shengbte_read= .FALSE.
>   alloy_read   = .FALSE.
>   alloy_pot   = .FALSE.
>   frac_type   =  0.0d0
465,468d475
<   run          =  0
<   dt           =  0.0d0
<   efield       =  1.0d-10
<   gradt        =  1.0d-10
469a477,479
>   phwmax       =  9.9d10 ! THz
>   phkmax       =  10.0   ! length in the units of [2*pi/a]
>   ! zjw
471d480
<   eimp_ls_mode =  0
479d487
<   dvimpq       = .false.
491c499,503
<   eph_interp   = .false.
---
>   ! thl  need to develop
>   run          =  0
>   dt           =  0.0d0
>   efield       =  1.0d-10
>   gradt        =  1.0d-10
574a587
>   epthick = epthick / ryd2ev
577a591
>   phwmax = phwmax / ryd2thz
745c759,781
<      CALL errore ('epw_readin','multiple doping concentration cannot be used when bte = 3 and 30',1)
---
>      CALL errore ('epw_readin','multiple doping concentration cannot be used when bte = 3 and 30 or phdrag = TRUE',1)
>   !
>   IF (alloy_pot) THEN
>   IF (.not. (eimp_mode .EQ. 6)) CALL errore('epw_readin', 'eimp_mode should = 6 when input perturbed potential dv_tot',1)
>   ENDIF
>   !
>   IF (alloy_read .and. alloy_pot) CALL errore('epw_readin', &
>        &'can either input alel_rate or input perturbed potential dv_tot',1)
>   IF (phdrag .EQ. .TRUE.) THEN
>      !
>      IF (.NOT. (bte .EQ. 0 .OR. bte .EQ. 1))  &
>         CALL errore ('epw_readin','"bte" must be 0 or 1 when "phdrag" is TRUE',1)
>      !
>      IF (nkf1 .NE. nqf1 .OR. nkf2 .NE. nqf2 .OR. nkf3 .NE. nqf3) &
>         CALL errore ('epw_readin','fine k and fine q grid should be identical when "phdrag" is TRUE',1)
>      !
>   ENDIF
>   ! 
>   IF (shengbte_read .EQ. .TRUE.) THEN
>      !
>      IF (.NOT. (phdrag .EQ. .TRUE.))  &
>         CALL errore ('epw_readin','"phdrag" must be TRUE when "shengbte_read" is TRUE',1)
>   ENDIF  
Only in ./: epw_readin.o
Only in ./: epw_setup.o
Only in ./: epw_summary.o
Only in ./: epw.x
Only in ./: evcbloch2wan.f90
Only in ./: evcbloch2wan.o
Only in ./: evcwan2bloch.f90
Only in ./: evcwan2bloch.o
diff ./fermilocation.f90 ../../epw-qian/src/fermilocation.f90
15c15
<                             lpolar, dielec, screen_polar
---
>                             lpolar, dielec
54,55c54,55
<   ef_min = (E_cen - (0.5d0 * (cbnd_emin - vbnd_emax) + ef_extent)) * ryd2ev ! initial lower bound in searching fermi level
<   ef_max = (E_cen + (0.5d0 * (cbnd_emin - vbnd_emax) + ef_extent)) * ryd2ev ! initial upper bound in searching fermi level
---
>   ef_min = (E_cen - (0.5d0 * ABS(cbnd_emin - vbnd_emax) + ef_extent)) * ryd2ev ! initial lower bound in searching fermi level
>   ef_max = (E_cen + (0.5d0 * ABS(cbnd_emin - vbnd_emax) + ef_extent)) * ryd2ev ! initial upper bound in searching fermi level
125c125,126
<   ! if eimp_mode > 0 or screen_polar = true, calculate the Debye screening length here
---
>   ! if eimp_mode > 0 or screen_polar = true, calculate the Debye screening
>   ! length here
128c129
<   if (eimp_mode > 0 .or. screen_polar) then
---
>   if (eimp_mode > 0) then
Only in ./: fermilocation.o
diff ./fermiwindow.f90 ../../epw-qian/src/fermiwindow.f90
12,13c12,13
<                             vbnd_num, cbnd_num, cfsthick, vfsthick
<   USE epwcom,        ONLY : fsthick, nbndsub, egap_rbm, bte, nptype
---
>                             vbnd_num, cbnd_num, cfsthick, vfsthick, nelec_red
>   USE epwcom,        ONLY : fsthick, nbndsub, egap_rbm, bte, nptype, nbndskip
36,37c36,46
<   ! check spin
<   !IF (nspin .EQ. 1 .OR. nspin .EQ. 4) THEN
---
>   ! check nbndskip and spin
>   IF (nbndskip .NE. 0) THEN
>      IF (.NOT. lspinorb) THEN
>         nelec_red = NINT(nelec) - 2*nbndskip
>      ELSE
>         nelec_red = NINT(nelec) - nbndskip
>      ENDIF
>   ELSE
>      nelec_red = nelec
>   ENDIF
>   !
39c48
<      vbnd_num = NINT(nelec)/2
---
>      vbnd_num = NINT(DBLE(nelec_red)/2.0d0)
41c50
<      vbnd_num = NINT(nelec)
---
>      vbnd_num = nelec_red
89,93d97
<   !DO ik = 1, nk_irr
<   !   DO ibnd = 1, nbndsub
<   !      IF (etf(ibnd,ik) .GT. ef_m) etf(ibnd,ik) = etf(ibnd,ik) + delta_egap
<   !   ENDDO
<   !ENDDO
95,97c99,104
<      DO ibnd = vbnd_num+1, nbndsub
<         etf(ibnd,ik) = etf(ibnd,ik) + delta_egap
<      ENDDO
---
>     ! DO ibnd = 1, nbndsub
>      !   IF (etf(ibnd,ik) .GT. ef_m) etf(ibnd,ik) = etf(ibnd,ik) + delta_egap
>     ! ENDDO
>       DO ibnd = vbnd_num+1, nbndsub
>           etf(ibnd,ik) = etf(ibnd,ik) + delta_egap
>       ENDDO 
126,149c133,140
<         IF (nptype .EQ. 'n') THEN
<            if ((etf(ibnd,ik)>=cbnd_emin).and.(etf(ibnd,ik)<=cbnd_emin+cfsthick)) then
<               ibndmax = max(ibnd,ibndmax)
<               ibndmin = min(ibnd,ibndmin)
<               ebndmax = max(etf(ibnd,ik),ebndmax)
<               ebndmin = min(etf(ibnd,ik),ebndmin)
<            endif
<         ELSEIF (nptype .EQ. 'p') THEN 
<            if ((etf(ibnd,ik)<=vbnd_emax).and.(etf(ibnd,ik)>=vbnd_emax-vfsthick)) then
<               ibndmax = max(ibnd,ibndmax)
<               ibndmin = min(ibnd,ibndmin)
<               ebndmax = max(etf(ibnd,ik),ebndmax)
<               ebndmin = min(etf(ibnd,ik),ebndmin)
<            endif
<         ELSE
<            IF (ABS(etf(ibnd,ik)-cbnd_emin) .LE. cfsthick) THEN
<               ibndmax = max(ibnd,ibndmax)
<               ebndmax = max(etf(ibnd,ik),ebndmax)
<            ENDIF
<            !
<            IF (ABS(etf(ibnd,ik)-vbnd_emax) .LE. vfsthick) THEN
<               ibndmin = min(ibnd,ibndmin)
<               ebndmin = min(etf(ibnd,ik),ebndmin)
<            ENDIF
---
>         IF (ABS(etf(ibnd,ik)-cbnd_emin) .LE. cfsthick) THEN
>            ibndmax = max(ibnd,ibndmax)
>            ebndmax = max(etf(ibnd,ik),ebndmax)
>         ENDIF
>         !
>         IF (ABS(etf(ibnd,ik)-vbnd_emax) .LE. vfsthick) THEN
>            ibndmin = min(ibnd,ibndmin)
>            ebndmin = min(etf(ibnd,ik),ebndmin)
182,186c173,179
<   WRITE(stdout,'(/5x,a,f9.4)')         'Number of electron = ', nelec
<   WRITE(stdout,'(5x,a,i4,a,i4)')       'Number of v/c band = ', vbnd_num, '          / ', cbnd_num
<   WRITE(stdout,'(5x,a,i4,a,i4)')       'Band window        = ', ibndmin, '         to ', ibndmax
<   WRITE(stdout,'(5x,a,f9.4,a,f9.4,a)') 'v/c fsthick        = ', vfsthick*ryd2ev, '     / ', cfsthick*ryd2ev,  ' eV'
<   WRITE(stdout,'(5x,a,f9.4,a,f9.4,a)') 'Energy window      = ', ebndmin*ryd2ev, ' eV to ', ebndmax*ryd2ev, ' eV'
---
>   WRITE(stdout,'(/5x,a,i4)')           'Number of skipped bands = ', nbndskip
>   WRITE(stdout,'(5x,a,f9.4)')          'Number of DFT electrons = ', nelec
>   WRITE(stdout,'(5x,a,i4)')            'Number of EPW electrons = ', nelec_red
>   WRITE(stdout,'(5x,a,i4,a,i4)')       'Number of v/c bands     = ', vbnd_num, '          / ', cbnd_num
>   WRITE(stdout,'(5x,a,i4,a,i4)')       'Band window             = ', ibndmin, '         to ', ibndmax
>   WRITE(stdout,'(5x,a,f9.4,a,f9.4,a)') 'v/c fsthick             = ', vfsthick*ryd2ev, '     / ', cfsthick*ryd2ev,  ' eV'
>   WRITE(stdout,'(5x,a,f9.4,a,f9.4,a)') 'Energy window           = ', ebndmin*ryd2ev, ' eV to ', ebndmax*ryd2ev, ' eV'
245,268c238,245
<         IF (nptype .EQ. 'n') THEN
<            if ((etf(ibnd,ik)>=cbnd_emin).and.(etf(ibnd,ik)<=cbnd_emin+cfsthick)) then
<               ibndmax = max(ibnd,ibndmax)
<               ibndmin = min(ibnd,ibndmin)
<               ebndmax = max(etf(ibnd,ik),ebndmax)
<               ebndmin = min(etf(ibnd,ik),ebndmin)
<            endif
<         ELSEIF (nptype .EQ. 'p') THEN 
<            if ((etf(ibnd,ik)<=vbnd_emax).and.(etf(ibnd,ik)>=vbnd_emax-vfsthick)) then
<               ibndmax = max(ibnd,ibndmax)
<               ibndmin = min(ibnd,ibndmin)
<               ebndmax = max(etf(ibnd,ik),ebndmax)
<               ebndmin = min(etf(ibnd,ik),ebndmin)
<            endif
<         ELSE
<            IF (ABS(etf(ibnd,ik)-cbnd_emin) .LE. cfsthick) THEN
<               ibndmax = max(ibnd,ibndmax)
<               ebndmax = max(etf(ibnd,ik),ebndmax)
<            ENDIF
<            !
<            IF (ABS(etf(ibnd,ik)-vbnd_emax) .LE. vfsthick) THEN
<               ibndmin = min(ibnd,ibndmin)
<               ebndmin = min(etf(ibnd,ik),ebndmin)
<            ENDIF
---
>         IF (ABS(etf(ibnd,ik)-cbnd_emin) .LE. cfsthick) THEN
>            ibndmax = max(ibnd,ibndmax)
>            ebndmax = max(etf(ibnd,ik),ebndmax)
>         ENDIF
>         !
>         IF (ABS(etf(ibnd,ik)-vbnd_emax) .LE. vfsthick) THEN
>            ibndmin = min(ibnd,ibndmin)
>            ebndmin = min(etf(ibnd,ik),ebndmin)
Only in ./: fermiwindow.o
Only in ./: gen_freqgrid.o
Only in ./: gmap_sym.o
Only in ./: hambloch2wan.o
Only in ./: hamwan2bloch.o
Only in ./: input_tmp.in
Only in ../../epw-qian/src/: interp_thl.f90
Only in ./: io_dyn_mat2.mod
Only in ./: io_dyn_mat2.o
Only in ./: io_epw.mod
Only in ./: io_epw.o
Only in ./: kernels_aniso_iaxis.o
Only in ./: kernels_iso_iaxis.o
Only in ./: kernels_raxis.o
Only in ./: kfold.mod
Only in ./: kfold.o
Only in ./: kgen.f90.prog
Only in ./: klist_epw.mod
Only in ./: kpointdivision.o
Only in ./: ktokpmq.o
Only in ./: libepw.a
Only in ./: loadkmesh.o
Only in ./: loadqmesh.o
Only in ./: loadumat.o
diff ./make.depend ../../epw-qian/src/make.depend
83,85d82
< evcbloch2wan.o : constants_epw.o
< evcwan2bloch.o : epwcom.o
< evcwan2bloch.o : constants_epw.o
100a98
> ephwann_shuffle.o : para_thl.o
167d164
< velwan2bloch.o : epwcom.o
210c207,218
< fermilocation : elph2.o
---
> fermilocation.o : elph2.o
> phdrag_shuffle.o : elph2.o
> phdrag_shuffle.o : epwcom.o
> phdrag_shuffle.o : constants_epw.o
> phdrag_shuffle.o : bte.o
> phdrag_shuffle.o : tetra.o
> phdrag_shuffle.o : para_thl.o
> bte_phcheck.o : elph2.o
> bte_phcheck.o : epwcom.o
> bte_phcheck.o : constants_epw.o
> bte_phcheck.o : bte.o
> bte_phcheck.o : para_thl.o
diff ./Makefile ../../epw-qian/src/Makefile
11c11
< MODFLAGS = -I../../iotk/src -I../../Modules -I../../LAXlib -I../../iotk/src \
---
> MODFLAGS = -I../../iotk/src -I../../Modules -I../../LAXlib -I../../iotk/src -I../../wannier90-2.1.0/src/obj \
72,73d71
< evcbloch2wan.o \
< evcwan2bloch.o \
114d111
< velwan2bloch.o \
140a138,140
> interp_thl.o \
> phdrag_shuffle.o \
> bte_phcheck.o \
147c147
< W90LIB = ../../wannier90-2.0.1/libwannier.a
---
> W90LIB = ../../wannier90-2.1.0/libwannier.a
169c169,171
< 	sed -i "s/allocate(fermi_energy_list(nfermi),stat=ierr)/if (.not. allocated(fermi_energy_list) ) allocate(fermi_energy_list(nfermi))/g" ../../wannier90-2.0.1/src/parameters.F90 ; sed -i "s/allocate(kubo_freq_list(kubo_nfreq),stat=ierr)/if (.not. allocated(kubo_freq_list) ) allocate(kubo_freq_list(kubo_nfreq)) /g" ../../wannier90-2.0.1/src/parameters.F90 ; cp wannier_lib.f90 wannier_lib.F90 ; cp wannier_lib.F90 ../../wannier90-2.0.1/src/ 
---
> 	sed -i "s/allocate(fermi_energy_list(nfermi),stat=ierr)/if (.not. allocated(fermi_energy_list) ) allocate(fermi_energy_list(nfermi))/g" ../../wannier90-2.1.0/src/parameters.F90 ; sed -i "s/allocate(kubo_freq_list(kubo_nfreq),stat=ierr)/if (.not. allocated(kubo_freq_list) ) allocate(kubo_freq_list(kubo_nfreq)) /g" ../../wannier90-2.1.0/src/parameters.F90 ;
> # cp wannier_lib.f90 wannier_lib.F90 ; cp wannier_lib.F90 ../../wannier90-2.0.1/src/ 
> 
Only in ../../epw-qian/src/: make.inc
Only in ./: make.sys
Only in ./: nesting_fn.o
Only in ./: openfilepw.o
Only in ./: output_epw.mod
Only in ./: pade.o
Only in ./: para_thl.mod
Only in ./: para_thl.o
Only in ../../epw-qian/src/: phdrag_shuffle.f90
Only in ./: plot_band.o
Only in ./: poolgather.o
Only in ./: print_clock_epw.o
Only in ./: printout_base.mod
Only in ./: printout_base.o
Only in ./: pw2wan90epw.o
Only in ./: readdvscf.o
Only in ./: readgmap.o
Only in ./: readigk.o
Only in ./: readmat_shuffle2.o
Only in ./: README
Only in ./: readwfc.o
Only in ./: refold.o
Only in ./: reset_sym.o
diff ./rigid_epw.f90 ../../epw-qian/src/rigid_epw.f90
10c10
<   SUBROUTINE rgd_blk (nr1,nr2,nr3,nat,dyn,ntemp,ndope,ddyn_l,q,tau,epsil,zeu,bg,omega,sign)
---
>   SUBROUTINE rgd_blk (nr1,nr2,nr3,nat,dyn,ddyn_l,q,tau,epsil,zeu,bg,omega,sign)
24,25c24
<   USE epwcom,    ONLY : vg_ph, L_D, screen_polar
<   use pwcom, only : tpiba2, tpiba
---
>   USE epwcom,    ONLY : vg_ph
30,31c29
<   integer ::  ntemp, ndope
<   complex(DP) :: dyn(3*nat,3*nat,ntemp,ndope) ! dynamical matrix
---
>   complex(DP) :: dyn(3*nat,3*nat) ! dynamical matrix
49,51c47,48
<   real(DP) :: geg                    !  <q+G| epsil | q+G>
<   real(DP) :: sgeg, dielec
<   integer :: na,nb, i,j, m1, m2, m3, itemp, idope
---
>   real(DP):: geg                    !  <q+G| epsil | q+G>
>   integer :: na,nb, i,j, m1, m2, m3
53c50
<   real(DP) :: alph, fac,g1,g2,g3, facgd(ntemp,ndope), arg, gmax
---
>   real(DP) :: alph, fac,g1,g2,g3, facgd, arg, gmax
55c52
<   complex(dp) :: facg(ntemp,ndope)
---
>   complex(dp) :: facg
94,95d90
< !ERROR: here [dielec] only works for isotropic materials
<   dielec = (epsil(1,1) + epsil(2,2) + epsil(3,3)) / 3.d0
97d91
<   !
110,129d103
<      ! -- Consider the carrier screening effect
<      !
<      facgd = 0.d0
<      if ((.not. screen_polar) .or. (sign < 0)) then
<         if (geg > 0.d0) &
<            facgd = fac*exp(-geg/alph/4.0d0)/geg
<      else
< !        write(stdout,*) 'L_D_check:'
<         do itemp = 1, ntemp
<            do idope = 1, ndope
< !              write(stdout,*) itemp,ief,' - L_D =', L_D(itemp,ief)*0.529177d0, 'Ang'
< !              write(stdout,*) '           - g^2 =',sqrt(g1**2+g2**2+g3**2)*tpiba
< 
<               sgeg  = ((g1**2+g2**2+g3**2) * tpiba2 + 1.d0/(L_D(itemp,idope)**2.d0)) * dielec / tpiba2
<               ! only consider screening for non-zero G point
<               facgd(itemp,idope) = fac*exp(-geg/alph/4.0d0)/sgeg
<            enddo
<         enddo
<      endif
< 
132c106
< !        facgd = fac*exp(-geg/alph/4.0d0)/geg
---
>         facgd = fac*exp(-geg/alph/4.0d0)/geg
146c120
<                  dyn( (na-1)*3+i,(na-1)*3+j,:,: ) = dyn((na-1)*3+i,(na-1)*3+j,:,:) - facgd(:,:) * &
---
>                  dyn( (na-1)*3+i,(na-1)*3+j ) = dyn((na-1)*3+i,(na-1)*3+j) - facgd * &
161,176d134
<      ! -- Consider the carrier screening effect
<      !
<      facgd = 0.d0
<      if ((.not. screen_polar) .or. (sign < 0)) then
<         if (geg > 0.d0) &
<            facgd = fac*exp(-geg/alph/4.0d0)/geg
<      else
<         do itemp = 1, ntemp
<            do idope = 1, ndope
<               sgeg  = ((g1**2+g2**2+g3**2) * tpiba2 + 1.d0/(L_D(itemp,idope)**2.d0)) * dielec / tpiba2
<               ! only consider screening for non-zero G point
<               facgd(itemp,idope) = fac*exp(-geg/alph/4.0d0)/sgeg
<            enddo
<         enddo
<      endif
<      !
187c145
< !        facgd = fac*exp(-geg/alph/4.0d0)/geg
---
>         facgd = fac*exp(-geg/alph/4.0d0)/geg
197,198c155
< ! ERROR: calculation of ddyn_l does not consider screening effect
<               facg(:,:) = facgd(:,:) * CMPLX(cos(arg),sin(arg),kind=DP)
---
>               facg = facgd * CMPLX(cos(arg),sin(arg),kind=DP)
201c158
<                     dyn( (na-1)*3+i,(nb-1)*3+j,:,: ) = dyn((na-1)*3+i,(nb-1)*3+j,:,:) + facg(:,:) *      &
---
>                     dyn( (na-1)*3+i,(nb-1)*3+j ) = dyn((na-1)*3+i,(nb-1)*3+j) + facg *      &
209c166
<                                                              facg(1,1) * (                                            &
---
>                                                              facg * (                                            &
420c377
< SUBROUTINE rgd_blk_epw3(uq,epmat,ntemp,ndope,ep_polar,nmodes,bmat,sign)
---
> SUBROUTINE rgd_blk_epw3(uq,epmat,ep_polar,nmodes,bmat,sign)
427c384
<        nmodes, ntemp, ndope
---
>        nmodes
429,431c386,388
<        uq(nmodes, nmodes,ntemp,ndope),      &! phonon eigenvec
<        epmat(nmodes,ntemp,ndope),     &! e-ph matrix
<        ep_polar(nmodes,ntemp,ndope),  &
---
>        uq(nmodes, nmodes),      &! phonon eigenvec
>        epmat(nmodes),     &! e-ph matrix
>        ep_polar(nmodes),  &
436c393
<   integer :: na, ipol, im, itemp, idope
---
>   integer :: na, ipol, im
441,451c398,404
<   do itemp = 1, ntemp
<      do idope = 1, ndope
<         DO na = 1,nat
<            DO ipol = 1,3
<               DO im = 1,nmodes 
<                  epmat(im,itemp,idope) = epmat(im,itemp,idope) + ep_polar(3*(na-1)+ipol,itemp,idope) * uq(3*(na-1)+ipol,im,itemp,idope)*bmat
<               ENDDO
<            ENDDO !ipol
<         ENDDO !nat
<      enddo
<   enddo
---
>   DO na = 1,nat
>      DO ipol = 1,3
>         DO im = 1,nmodes 
>            epmat(im) = epmat(im) + ep_polar(3*(na-1)+ipol) * uq(3*(na-1)+ipol,im)*bmat
>         ENDDO
>      ENDDO !ipol
>   ENDDO !nat
632c585
< SUBROUTINE polar_eph (uact, xq0, eph_vertex, ntemp, ndope)
---
> SUBROUTINE polar_eph (uact, xq0, eph_vertex)
639d591
<   use epwcom,    only : L_D, screen_polar
645,646c597
<   integer :: ntemp, ndope
<   complex(DP) :: uact (3*nat, 3*nat), eph_vertex (3*nat,ntemp,ndope), &
---
>   complex(DP) :: uact (3*nat, 3*nat), eph_vertex (3*nat), &
650,653c601,602
<   integer :: na, mu, ig, imode, i, j, k, ipol, ibnd, ir, &
<              itemp, idope
<   real(DP) :: fac, gmg, geg, alpha, g0(3), arg, &
<               vpolarq(ntemp,ndope), dielec, sgeg
---
>   integer :: na, mu, ig, imode, i, j, k, ipol, ibnd, ir
>   real(DP) :: fac, gmg, geg, vpolarq, alpha, g0(3), arg
659,665d607
<   ! ERROR: this is only true for isotropic materials  
<   dielec = (epsi(1,1) + epsi(2,2) + epsi(3,3)) / 3.d0
< 
<   ! convergence factor
<   alpha = 1.d0 * tpiba2
<   fac = e2 / tpiba2
<   !
667,674c609
<   DO ig = 1, ngms
<      g1 = g (1,ig) + xq0 (1)
<      g2 = g (2,ig) + xq0 (2)
<      g3 = g (3,ig) + xq0 (3)
<      gmg = (g1**2 + g2**2 + g3**2)
<      geg = (g1*(epsi(1,1)*g1+epsi(1,2)*g2+epsi(1,3)*g3)+ &
<             g2*(epsi(2,1)*g1+epsi(2,2)*g2+epsi(2,3)*g3)+ &
<             g3*(epsi(3,1)*g1+epsi(3,2)*g2+epsi(3,3)*g3))
---
>   DO imode = 1, 3*nat
676,685c611,612
<      if (.not. screen_polar) then
<         vpolarq = - fac * (exp ( - geg * tpiba2 * 0.25d0 / alpha) / geg) * fpi / omega
<      else
<         do itemp = 1, ntemp
<            do idope = 1, ndope
<               sgeg  = (gmg * tpiba2 + 1.d0/(L_D(itemp,idope)**2.d0)) * dielec / tpiba2
<               vpolarq(itemp,idope) = - fac * (exp ( - geg * tpiba2 * 0.25d0 / alpha) / sgeg) * fpi / omega
<            enddo
<         enddo
<      endif
---
>      ! convergence factor
>      alpha = 1.d0 * tpiba2
693,696c620,625
<         arg = tpi*(g(1,ig)*tau(1,na)+g(2,ig)*tau(2,na)+g(3,ig)*tau(3,na))
<         gtau = cmplx (cos(arg), -sin(arg))
<         !
<         DO imode = 1, 3*nat
---
>         IF (abs (uact (mu + 1,imode) ) + abs (uact (mu + 2,imode) ) + abs (uact (mu + &
>              3,imode) ) .gt.1.0d-12) THEN
>            u1 = uact (mu + 1,imode)
>            u2 = uact (mu + 2,imode)
>            u3 = uact (mu + 3,imode)
>            fac = e2 / tpiba2
698,702c627,636
<            IF (abs (uact (mu + 1,imode) ) + abs (uact (mu + 2,imode) ) + abs (uact (mu + &
<                 3,imode) ) .gt.1.0d-12) THEN
<               u1 = uact (mu + 1,imode)
<               u2 = uact (mu + 2,imode)
<               u3 = uact (mu + 3,imode)
---
>            DO ig = 1, ngms
>               arg = tpi*(g(1,ig)*tau(1,na)+g(2,ig)*tau(2,na)+g(3,ig)*tau(3,na))
>               gtau = cmplx (cos(arg), -sin(arg))
>               g1 = g (1,ig) + xq0 (1)
>               g2 = g (2,ig) + xq0 (2)
>               g3 = g (3,ig) + xq0 (3)
>               gmg = (g1**2 + g2**2 + g3**2)
>               geg = (g1*(epsi(1,1)*g1+epsi(1,2)*g2+epsi(1,3)*g3)+ &
>                      g2*(epsi(2,1)*g1+epsi(2,2)*g2+epsi(2,3)*g3)+ &
>                      g3*(epsi(3,1)*g1+epsi(3,2)*g2+epsi(3,3)*g3))
707c641,643
<               eph_vertex(imode,:,:) = eph_vertex(imode,:,:) + vpolarq(:,:) * uzg * fact * gtau
---
>               vpolarq = - fac * (exp ( - geg * tpiba2 * 0.25d0 / alpha) / geg) * fpi / omega
>               !
>               eph_vertex(imode) = eph_vertex(imode) + vpolarq * uzg * fact * gtau
709c645
<            ENDIF
---
>            ENDDO 
711c647
<         enddo
---
>         ENDIF
Only in ./: rigid_epw.o
Only in ./: rotate_eigenm.o
Only in ./: rotate_epmat.o
diff ./selfen_elec.f90 ../../epw-qian/src/selfen_elec.f90
16a17
>   USE ions_base,     ONLY : nat
23c24
<                             eimp_sr, screen_polar
---
>                             eimp_sr, frac_type, alloy_pot
26a28
>                             sigmai_mode_all_inter, sigmai_mode_all_intra, &
29,30c31,32
<                             eimpf_full
<   USE constants_epw, ONLY : pi, twopi, ryd2ev, au2cm, bohr2ang, ci
---
>                             sigmai_mode_all_alloy_inter, sigmai_mode_all_alloy_intra, alelpp
>   USE constants_epw, ONLY : pi, twopi, ryd2ev, au2cm, bohr2ang, ci, ryd2thz
52c54
<                                 cosa(nbndsub,nbndsub,nq_ful)
---
>                                 cosa(nbndsub,nbndsub,nq_ful), g2_alel
53a56
>                                 sigmai_intra(nq_ful), sigmai_inter(nq_ful), &
56c59,60
<                                 weight_ela(nq_ful)
---
>                                 weight_ela(nq_ful), weight_alel(nq_ful), sigmai_alloy_intra(nq_ful), &
>                                 sigmai_alloy_inter(nq_ful)
63c67
<   REAL(KIND=DP), ALLOCATABLE :: tetra_c_abs(:,:,:,:), tetra_c_emi(:,:,:,:), &
---
>   REAL(KIND=DP), ALLOCATABLE :: tetra_c_abs(:,:), tetra_c_emi(:,:), &
80,81c84,85
<   complex(kind=DP)           :: eimpf_tmp
<   complex(kind=DP), allocatable :: eimpf_lr_valley(:,:,:), eimpf_sr_valley(:,:,:)
---
>   complex(kind=DP)           :: eimpf_tmp, alelpp_tmp
>   complex(kind=DP), allocatable :: eimpf_lr_valley(:,:,:), eimpf_sr_valley(:,:,:), alelpp_valley(:,:,:)
98,104c102,103
<      if (screen_polar) then
<         ALLOCATE (tetra_c_abs(4,ntetra,neptemp,nepdope))
<         ALLOCATE (tetra_c_emi(4,ntetra,neptemp,nepdope))
<      else
<         ALLOCATE (tetra_c_abs(4,ntetra,1,1))
<         ALLOCATE (tetra_c_emi(4,ntetra,1,1))
<      endif
---
>      ALLOCATE (tetra_c_abs(4,ntetra))
>      ALLOCATE (tetra_c_emi(4,ntetra))
112c111
<   if ((eimp_mode == 1) .or. (eimp_mode == 3) .or. (eimp_mode == 5) .or. (eimp_mode == 7)) then
---
>   if ((eimp_mode == 1) .or. (eimp_mode == 3)) then
116c115
<   elseif ((eimp_mode == 2) .or. (eimp_mode == 4) .or. (eimp_mode == 6) .or. (eimp_mode == 8)) then
---
>   elseif ((eimp_mode == 2) .or. (eimp_mode == 4)) then
149c148
<   if ((eimp_mode > 0) .and. (eimp_mode < 7) .and. (ik_red == ik_star)) then
---
>   if ((eimp_mode > 0) .and. (ik_red == ik_star)) then
188,189c187,189
< !ERROR: currently only works for conduction band
<   ! for eimp_mode = 3 or 4, and eimp_mode = 5 or 6 with eimp_sr = false
---
> !  write(stdout,*) 'test'
> !  write(stdout,*) ' xkk:',xkk
> !  write(stdout,*) ' xkk+:',xkk + (/0.1, 0.3, 0.2/)
201,202c201,202
<      call valley_degen(xkq, xkq_v, ikq_v)
<      !
---
>      call valley_degen(xkq, xkq_v, ikq_v)  
> !     if (iq == 1)  write(*,*) 'Check if line 199 outputs'
207c207
<         valley_map(1,iq) = 0   ! intra-valley
---
>         valley_map(1,iq) = 0  ! intravalley
209c209
<         valley_map(1,iq) = 1   ! inter-valley
---
>         valley_map(1,iq) = 1  ! intervalley
239a240
> !  write(*,*) 'Check if line 237 outputs'
243,248c244,249
<      if (eimp_mode < 7) then
<         allocate ( eimpf_lr_valley (nq_ful,neptemp,nepdope) )
<         allocate ( eimpf_sr_valley (nq_ful,nbnd_red,nbnd_red) )
<         eimpf_lr_valley = 0.d0
<         eimpf_sr_valley = 0.d0
<      endif
---
>      allocate ( eimpf_lr_valley (nq_ful,neptemp,nepdope) )
>      allocate ( eimpf_sr_valley (nq_ful,nbnd_red,nbnd_red) )
>      allocate ( alelpp_valley (nq_ful,nbnd_red,nbnd_red) )
>      alelpp_valley = 0.d0
>      eimpf_lr_valley = 0.d0
>      eimpf_sr_valley = 0.d0
250,254c251
<      if (eimp_mode == 7 .or. eimp_mode == 8) then
<         !
<         ! we do not allocate valley arrays but directly use eimpf_full
<         !
<      elseif (eimp_mode == 5 .or. eimp_mode == 6) then
---
>      if (eimp_mode == 5 .or. eimp_mode == 6) then
260c257
<               if (valley_map(1,iq) == 0) then
---
>              ! if (valley_map(1,iq) == 0) then
263c260
<               endif
---
>              ! endif
266a264
>         IF (alloy_pot) alelpp_valley = alelpp
284c282
<            if (valley_map(1,iq) == 0) then
---
>            !if (valley_map(1,iq) == 0) then
287c285
<            endif
---
>            !endif
293a292
> !  write(*,*) 'Check if line 289 outputs'
315a315,328
>               ! tetrahedron
>               ! linewidth due to absorption of phonon
>               DO iq = 1, nq_ful
>                  ekq_tetra(iq) = -wf_ful(imode,iq) + etf(jbnd,2*iq)
>               ENDDO
>               CALL eigen_tet(ntetra,ekq_tetra,tetra_i,tetra_w,nq_ful)
>               CALL weight_tet(nq_ful,ntetra,etf(ibnd,1),tetra_i,tetra_w,tetra_c_abs,wkt)
>               !
>               ! linewidth due to emission of phonon
>               DO iq = 1, nq_ful
>                  ekq_tetra(iq) = wf_ful(imode, iq) + etf(jbnd,2*iq)
>               ENDDO
>               CALL eigen_tet(ntetra,ekq_tetra,tetra_i,tetra_w,nq_ful)
>               CALL weight_tet(nq_ful,ntetra,etf(ibnd,1),tetra_i,tetra_w,tetra_c_emi,wkt)
317,353d329
<               if (screen_polar) then
<                  do itemp = 1, neptemp
<                     do idope = 1, nepdope
<                        ! tetrahedron
<                        ! linewidth due to absorption of phonon
<                        DO iq = 1, nq_ful
<                           ekq_tetra(iq) = -wf_ful(imode,itemp,idope,iq) + etf(jbnd,2*iq)
<                        ENDDO
<                        CALL eigen_tet(ntetra,ekq_tetra,tetra_i,tetra_w,nq_ful)
<                        CALL weight_tet(nq_ful,ntetra,etf(ibnd,1),tetra_i,tetra_w,tetra_c_abs(:,:,itemp,idope),wkt)
<                        !
<                        ! linewidth due to emission of phonon
<                        DO iq = 1, nq_ful
<                           ekq_tetra(iq) = wf_ful(imode,itemp,idope,iq) + etf(jbnd,2*iq)
<                        ENDDO
<                        CALL eigen_tet(ntetra,ekq_tetra,tetra_i,tetra_w,nq_ful)
<                        CALL weight_tet(nq_ful,ntetra,etf(ibnd,1),tetra_i,tetra_w,tetra_c_emi(:,:,itemp,idope),wkt)
<                        !
<                     enddo
<                  enddo
<               else
<                  ! tetrahedron
<                  ! linewidth due to absorption of phonon
<                  DO iq = 1, nq_ful
<                     ekq_tetra(iq) = -wf_ful(imode,1,1,iq) + etf(jbnd,2*iq)
<                  ENDDO
<                  CALL eigen_tet(ntetra,ekq_tetra,tetra_i,tetra_w,nq_ful)
<                  CALL weight_tet(nq_ful,ntetra,etf(ibnd,1),tetra_i,tetra_w,tetra_c_abs(:,:,1,1),wkt)
<                  !
<                  ! linewidth due to emission of phonon
<                  DO iq = 1, nq_ful
<                     ekq_tetra(iq) = wf_ful(imode,1,1,iq) + etf(jbnd,2*iq)
<                  ENDDO
<                  CALL eigen_tet(ntetra,ekq_tetra,tetra_i,tetra_w,nq_ful)
<                  CALL weight_tet(nq_ful,ntetra,etf(ibnd,1),tetra_i,tetra_w,tetra_c_emi(:,:,1,1),wkt)
<                  !
<               endif
376a353,354
>                  sigmai_inter = 0.0d0
>                  sigmai_intra = 0.0d0
380a359,363
>                     IF (alloy_pot) THEN
>                      weight_alel= 0.0d0
>                      sigmai_alloy_inter = 0.0d0
>                      sigmai_alloy_intra = 0.0d0
>                     ENDIF
401,405c384
<                        if (screen_polar) then
<                           wq = wf_ful(imode,itemp,idope,iq)
<                        else
<                           wq = wf_ful(imode,1,1,iq)
<                        endif
---
>                        wq = wf_ful(imode,iq)
412,414d390
<                        ! NOTE: epf17 takes into account the screening effect
<                        ! when [screen_polar] is true
<                        !
419c395
<                           epf = epf17(iq,jbnd0,ibnd0,imode,itemp,idope)
---
>                           epf = epf17(iq,jbnd0,ibnd0,imode)
427,443c403,409
< 
<                        if (wq /= 0.d0) then
<                           if (eimp_mode > 0) then
<                              if (defectdens /= 0) then
<                                 g2_eimp = n_dop * (abs(eimpf_lr_valley(iq,itemp,idope))**2.d0) + &
<                                           n_imp * (abs(eimpf_sr_valley(iq,jbnd0,ibnd0))**2.d0)
<                              else
<                                 if (eimp_mode < 7) then
<                                    eimpf_tmp = eimpf_lr_valley(iq,itemp,idope) + &
<                                                eimpf_sr_valley(iq,jbnd0,ibnd0)
<                                    g2_eimp = n_dop * (abs(eimpf_tmp)**2.d0)
<                                 elseif (eimp_mode == 7 .or. eimp_mode == 8) then
<                                   
<                                    eimpf_tmp = eimpf_full(jbnd0,ibnd0,itemp,idope,iq)
<                                    g2_eimp = n_dop * (abs(eimpf_tmp)**2.d0)
<                                 endif
<                              endif
---
> !
> !             write(*,*) 'Check if line 399 outputs'
> !
>                        if (eimp_mode > 0) then
>                           if (defectdens /= 0) then
>                              g2_eimp = n_dop * (abs(eimpf_lr_valley(iq,itemp,idope))**2.d0) + &
>                                        n_imp * (abs(eimpf_sr_valley(iq,jbnd0,ibnd0))**2.d0)
445c411,421
<                              g2_eimp = 0.d0
---
>                           if (alloy_pot) then
> !             g  = (frac_num*DBLE(nat)) * (cupl_mat(ib,jb,ik,ikk,1)-cupl_mat(ib,jb,ik,ikk,2))
> !               g2 = ABS(g)**2
>                              alelpp_tmp = alelpp_valley(iq,jbnd0,ibnd0)  ! for 2x2x2 supercel binary Si-fcc lattice only
>                              g2_alel = ABS(alelpp_tmp)**2
>                              eimpf_tmp = eimpf_lr_valley(iq,itemp,idope) 
>                              g2_eimp = n_dop * (abs(eimpf_tmp)**2.d0)
>                           else
>                              eimpf_tmp = eimpf_lr_valley(iq,itemp,idope)   ! to compare with thesis Si/Ge long range only code
>                              g2_eimp = n_dop * (abs(eimpf_tmp)**2.d0)
>                           endif
447,448d422
<                        else
<                           g2_eimp = 0.d0
450a425,426
> !
> !
457,463c433,434
<                              if (screen_polar) then
<                                 weight_abs(iq) = weight_abs(iq) + pi * g2 * tetra_c_abs(itetra_(2,iktetra,iq),itetra_(1,iktetra,iq),itemp,idope)
<                                 weight_emi(iq) = weight_emi(iq) + pi * g2 * tetra_c_emi(itetra_(2,iktetra,iq),itetra_(1,iktetra,iq),itemp,idope)
<                              else
<                                 weight_abs(iq) = weight_abs(iq) + pi * g2 * tetra_c_abs(itetra_(2,iktetra,iq),itetra_(1,iktetra,iq),1,1)
<                                 weight_emi(iq) = weight_emi(iq) + pi * g2 * tetra_c_emi(itetra_(2,iktetra,iq),itetra_(1,iktetra,iq),1,1)
<                              endif
---
>                              weight_abs(iq) = weight_abs(iq) + pi * g2 * tetra_c_abs(itetra_(2,iktetra,iq),itetra_(1,iktetra,iq))
>                              weight_emi(iq) = weight_emi(iq) + pi * g2 * tetra_c_emi(itetra_(2,iktetra,iq),itetra_(1,iktetra,iq))
468a440,443
>                              if (alloy_pot .and. (imode == 1)) then
>                                 weight_alel(iq) = weight_alel(iq) + pi * g2_alel * tetra_c_ela(itetra_(2,iktetra,iq),itetra_(1,iktetra,iq))
>                              endif
>                              !
476c451
<                           if ((eimp_mode > 0) .and. (imode == 1)) then
---
>                           if ((eimp_mode > 0)) then
479,480c454,459
<                                 sigmai_ela_intra(iq) = (1.d0 - cosa(ibnd,jbnd,iq)) * weight_ela(iq)
< !                                sigmai_ela_intra(iq) = (1.d0-wgkq) * (1.d0 - cosa(ibnd,jbnd,iq)) * weight_ela(iq)
---
>             if (imode == 1)  then
>                sigmai_ela_intra(iq) = (1.d0 - cosa(ibnd,jbnd,iq)) * weight_ela(iq)
>             end if
>             sigmai_intra(iq) = sigmai_abs(iq) + sigmai_emi(iq)
>             IF ((alloy_pot) .and. (imode == 1)) sigmai_alloy_intra(iq) =  64*weight_alel(iq)*frac_type(1)*frac_type(2)
> !
482,483c461,464
<                                 sigmai_ela_inter(iq) = (1.d0 - cosa(ibnd,jbnd,iq)) * weight_ela(iq)
< !                                sigmai_ela_inter(iq) = (1.d0-wgkq) * (1.d0 - cosa(ibnd,jbnd,iq)) * weight_ela(iq)
---
>             if (imode == 1) sigmai_ela_inter(iq) = (1.d0 - cosa(ibnd,jbnd,iq)) * weight_ela(iq)
>             sigmai_inter(iq) = sigmai_abs(iq) + sigmai_emi(iq)
>             IF ((alloy_pot) .and. (imode == 1))  sigmai_alloy_inter(iq) =  64*weight_alel(iq)*frac_type(1)*frac_type(2)
> !                                 
484a466,469
> !           THL's alloy-elec scattering
> !           erate_tmp = erate_tmp + g2 * tetra_c_dv(itetra_(2,iktetra,ikk),itetra_(1,iktetra,ikk))
> !           erate =  tpi * (frac_type(1)*frac_type(2)/(frac_num*DBLE(nat))) * erate_tmp 
>                             
495,497c480,485
<                           if ((eimp_mode > 0) .and. (imode == 1)) then
<                              weight_ela(iq) = weight_ela(iq) + pi * g2_eimp * (1.0d0/nq_ful) * w0gauss((ekk-ekq)/degaussw,0) / degaussw 
<                              if (valley_map(1,iq) == 0) then
---
>        if ((eimp_mode > 0) .and. (imode == 1))  weight_ela(iq) = weight_ela(iq) + pi * g2_eimp * (1.0d0/nq_ful) * w0gauss((ekk-ekq)/degaussw,0) / degaussw 
> 
>        if (alloy_pot .and. (imode == 1))  weight_alel(iq) = weight_alel(iq) + pi * g2_alel * (1.0d0/nq_ful) * w0gauss((ekk-ekq)/degaussw,0) / degaussw 
> 
>                if ((eimp_mode > 0)) then
>                      if (valley_map(1,iq) == 0) then
499,505c487,501
<                                 sigmai_ela_intra(iq) = (1.d0 - cosa(ibnd,jbnd,iq)) * weight_ela(iq)
< !                                sigmai_ela_intra(iq) = (1.d0-wgkq) * (1.d0 - cosa(ibnd,jbnd,iq)) * weight_ela(iq)
<                              elseif (valley_map(1,iq) == 1) then
<                                 sigmai_ela_inter(iq) = (1.d0 - cosa(ibnd,jbnd,iq)) * weight_ela(iq)
< !                                sigmai_ela_inter(iq) = (1.d0-wgkq) * (1.d0 - cosa(ibnd,jbnd,iq)) * weight_ela(iq)
<                              endif
<                           endif
---
>             if (imode == 1)  sigmai_ela_intra(iq) = (1.d0 - cosa(ibnd,jbnd,iq)) * weight_ela(iq)
>             sigmai_intra(iq) = sigmai_abs(iq) + sigmai_emi(iq)
>             IF ((alloy_pot) .and. (imode == 1)) sigmai_alloy_intra(iq) =  64*weight_alel(iq)*frac_type(1)*frac_type(2)
> !
>                      elseif (valley_map(1,iq) == 1) then
>             if (imode == 1) sigmai_ela_inter(iq) = (1.d0 - cosa(ibnd,jbnd,iq)) * weight_ela(iq)
>             sigmai_inter(iq) = sigmai_abs(iq) + sigmai_emi(iq)
>             IF ((alloy_pot) .and. (imode == 1))  sigmai_alloy_inter(iq) =  64*weight_alel(iq)*frac_type(1)*frac_type(2)
> !                                 
>                      endif
> !           THL's alloy-elec scattering
> !           erate_tmp = erate_tmp + g2 * tetra_c_dv(itetra_(2,iktetra,ikk),itetra_(1,iktetra,ikk))
> !           erate =  tpi * (frac_type(1)*frac_type(2)/(frac_num*DBLE(nat))) * erate_tmp 
>                             
>               endif
527a524,526
> !
> !             write(*,*) 'Check if line 512 outputs'
> !
531a531,533
>                 sigmai_mode_all_inter(itemp,idope,imode,ibnd0,ik_red) = sigmai_mode_all_inter(itemp,idope,imode,ibnd0,ik_red) + SUM(sigmai_inter(:))
>                  sigmai_mode_all_intra(itemp,idope,imode,ibnd0,ik_red) = sigmai_mode_all_intra(itemp,idope,imode,ibnd0,ik_red) + SUM(sigmai_intra(:))
> 
538a541,546
>                  !  al-el scattering rate
>                  IF (alloy_pot)  THEN
>  sigmai_mode_all_alloy_inter(itemp,idope,ibnd0,ik_red)  = sigmai_mode_all_alloy_inter(itemp,idope,ibnd0,ik_red)   + SUM(sigmai_alloy_inter(:))
>  sigmai_mode_all_alloy_intra(itemp,idope,ibnd0,ik_red)  = sigmai_mode_all_alloy_intra(itemp,idope,ibnd0,ik_red)   + SUM(sigmai_alloy_intra(:))
>                  ENDIF
>                  ! 
540a549
>                !write(*,*) 'Check if line 532 outputs'
620c629
<   if (.false. .and. (xkk(1) == 0) .and. (xkk(2) == 0.25) .and. (xkk(3) == 0.25)) then
---
>   if (.true. .and. (xkk(1) == 0) .and. (xkk(2) == 0.25) .and. (xkk(3) == 0.25)) then
629c638,639
<    
---
>      if (alloy_pot) &
>         write(*,*) ' sigmai_mode_all_alloy_intra =', 0.5d0/sigmai_mode_all_alloy_intra(1,13,1,ik_red)
681a692,693
>    USE io_files,      ONLY : prefix
>    USE epwcom,        ONLY : alloy_pot
682a695
>    USE io_global,   ONLY :stdout
692a706,822
>  IF ((TRIM(prefix) .eq. 'Si') .or. (TRIM(prefix) .eq. 'Ge')) THEN   ! only for Qian's SiGe alloys
>     
> IF (SQRT((xk(1)-0.5d0)**2 + (xk(2)-0.5d0)**2+ (xk(3)-0.5d0)**2) .LT. 0.0625) THEN 
> xk_v = (/0.5,0.5,0.5/) 
> ik_v =1 
> ENDIF 
> IF (SQRT((xk(1)-0.5d0)**2 + xk(2)**2+ xk(3)**2) .LT. 0.0625) THEN 
> xk_v = (/0.5,0.0,0.0/) 
> ik_v =2 
> ENDIF
> IF (SQRT(xk(1)**2 + (xk(2)-0.5d0)**2+ xk(3)**2) .LT. 0.0625) THEN 
> xk_v = (/0.0,0.5,0.0/) 
> ik_v =3 
> ENDIF
> IF (SQRT(xk(1)**2 + xk(2)**2+ (xk(3)-0.5d0)**2) .LT. 0.0625) THEN 
> xk_v = (/0.0,0.0,0.5/) 
> ik_v =4 
> ENDIF 
> IF (SQRT((xk(1)-0.5d0)**2 + (xk(2)-1.0d0)**2+ (xk(3)-1.0d0)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.5,1.0,1.0/) 
> ik_v =2 
> ENDIF
> IF (SQRT((xk(1)-1.0d0)**2 + (xk(2)-0.5d0)**2+ (xk(3)-1.0d0)**2) .LT. 0.0625)  THEN 
> xk_v = (/1.0,0.5,1.0/) 
> ik_v =3
> ENDIF
> IF (SQRT((xk(1)-1.0d0)**2 + (xk(2)-1.0d0)**2+ (xk(3)-0.5d0)**2) .LT. 0.0625)  THEN 
> xk_v = (/1.0,1.0,0.5/) 
> ik_v =4 
> ENDIF
> IF (SQRT((xk(1)-0.5d0)**2 + (xk(2)-1.0d0)**2+ xk(3)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.5,1.0,0.0/) 
> ik_v =2 
> ENDIF
> IF (SQRT((xk(1)-1.0d0)**2 + (xk(2)-0.5d0)**2+ xk(3)**2) .LT. 0.0625)  THEN 
> xk_v = (/1.0,0.5,0.0/) 
> ik_v =3 
> ENDIF
> IF (SQRT((xk(1)-1.0d0)**2 + xk(2)**2+ (xk(3)-0.5d0)**2) .LT. 0.0625)  THEN 
> xk_v = (/1.0,0.0,0.5/) 
> ik_v =4 
> ENDIF
> IF (SQRT((xk(1)-0.5d0)**2 + xk(2)**2+ (xk(3)-1.0d0)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.5,0.0,1.0/) 
> ik_v =2 
> ENDIF
> IF (SQRT(xk(1)**2 + (xk(2)-0.5d0)**2+ (xk(3)-1.0d0)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.0,0.5,1.0/) 
> ik_v =3 
> ENDIF
> IF (SQRT(xk(1)**2 + (xk(2)-1.0d0)**2+ (xk(3)-0.5d0)**2) .LT. 0.0625) THEN 
> xk_v = (/0.0,1.0,0.5/) 
> ik_v =4 
> ENDIF
>  ! crystal: L 0.5 0.5 0.5, 0/1 0/1 0.5, 0/1 0.5 0/1, 0.5 0/1 0/1
> 
> IF (SQRT((xk(1)-0.425d0)**2 + (xk(2)-0.425d0)**2+ xk(3)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.425,0.425,0.0/) 
> ik_v =5
> ENDIF
> IF (SQRT((xk(1)-0.425d0)**2 + (xk(3)-0.425d0)**2+ xk(2)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.425,0.0,0.425/) 
> ik_v =6 
> ENDIF
> IF (SQRT((xk(3)-0.425d0)**2 + (xk(2)-0.425d0)**2+ xk(1)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.0,0.425,0.425/) 
> ik_v =7 
> ENDIF
> IF (SQRT((xk(1)-0.425d0)**2 + (xk(2)-0.425d0)**2+ (xk(3)-1.0d0)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.425,0.425,1.0/) 
> ik_v =5 
> ENDIF
> IF (SQRT((xk(1)-0.425d0)**2 + (xk(3)-0.425d0)**2+ (xk(2)-1.0d0)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.425,1.0,0.425/) 
> ik_v =6 
> ENDIF
> IF (SQRT((xk(3)-0.425d0)**2 + (xk(2)-0.425d0)**2+ (xk(1)-1.0d0)**2) .LT. 0.0625)  THEN 
> xk_v = (/1.0,0.425,0.425/) 
> ik_v =7 
> ENDIF
> IF (SQRT((xk(1)-0.575d0)**2 + (xk(2)-0.575d0)**2+ xk(3)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.575,0.575,0.0/) 
> ik_v =8 
> ENDIF
> IF (SQRT((xk(1)-0.575d0)**2 + (xk(3)-0.575d0)**2+ xk(2)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.575,0.0,0.575/) 
> ik_v =9 
> ENDIF
> IF (SQRT((xk(3)-0.575d0)**2 + (xk(2)-0.575d0)**2+ xk(1)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.0,0.575,0.575/) 
> ik_v =10 
> ENDIF
> IF (SQRT((xk(1)-0.575d0)**2 + (xk(2)-0.575d0)**2+ (xk(3)-1.0d0)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.575,0.575,1.0/) 
> ik_v =8
> ENDIF
> IF (SQRT((xk(1)-0.575d0)**2 + (xk(3)-0.575d0)**2+ (xk(2)-1.0d0)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.575,1.0,0.575/) 
> ik_v =9 
> ENDIF
> IF (SQRT((xk(3)-0.575d0)**2 + (xk(2)-0.575d0)**2+ (xk(1)-1.0d0)**2) .LT. 0.0625) THEN 
> xk_v = (/1.0,0.575,0.575/) 
> ik_v =10 
> ENDIF
>   ! Si crystal: near X 0/1 0.425 0.425 or 0/1 0.575 0.575
> 
> IF (SQRT(xk(1)**2+ xk(2)**2 + xk(3)**2) .LT. 0.0625)  THEN 
> xk_v = (/0.0,0.0,0.0/) 
> ik_v =11 
> ENDIF
> IF (SQRT((xk(1)-1.0d0)**2+ (xk(2)-1.0d0)**2 + (xk(3)-1.0d0)**2) .LT. 0.0625) THEN 
> xk_v = (/1.0,1.0,1.0/) 
> ik_v =11 
> ENDIF
>  !gamma
> 
>  ELSE
693a824,825
>     !  write(*,*) 'Check if line 677 outputs'
>     !  WRITE (*,'(3x,a,3f8.2)')'xk =', xk(1:3)
695,698c827,832
<       dxk = xk - cbnd_emin_xk(:,ik)
<       dxk(1) = mod(dxk(1), 1.d0)
<       dxk(2) = mod(dxk(2), 1.d0)
<       dxk(3) = mod(dxk(3), 1.d0)
---
>       dxk(:) = xk(:) - cbnd_emin_xk(:,ik)
>     ! WRITE (*,'(3x,a,3f8.2)')  'cbnd_emin_xk(:,ik) =', cbnd_emin_xk(1:3,ik)
>     ! WRITE (*,'(3x,a,i4,a,3f8.2)')  'ik =', ik, ', dxk =', dxk(1:3)
>       dxk(1) = mod(dxk(1), 1.0d0)
>       dxk(2) = mod(dxk(2), 1.0d0)
>       dxk(3) = mod(dxk(3), 1.0d0)
720a855
>    ENDIF
722a858
> 
Only in ./: selfen_elec.o
diff ./selfen_phon.f90 ../../epw-qian/src/selfen_phon.f90
2c2
< SUBROUTINE selfen_phon (iq)
---
> SUBROUTINE selfen_phon (iq0)
11c11
<   USE epwcom,        ONLY : nbndsub, fsthick, eptemp, degaussw, save_m_mat, &
---
>   USE epwcom,        ONLY : nbndsub, fsthick, eptemp, degaussw, save_m_mat, epthick, phdrag, &
13d12
<   USE pwcom,         ONLY : nelec
15c14
<                             etf, epf17, wf_irr, gammai_mode_all, ef_epw
---
>                             etf, epf17, wf_irr, wf_all, gammai_mode_all, ef_epw
25c24
<   INTEGER, INTENT(IN)        :: iq
---
>   INTEGER, INTENT(IN)        :: iq0
29,31c28,30
<   INTEGER                    :: ik, ikk, ikq, ibnd0, jbnd0, ibnd, jbnd, imode, itemp, idope
<   REAL(KIND=DP)              :: g2, xk(3), ekk, ekq, wq, ef0, wgkk, wgkq, inv_temp
<   REAL(KIND=DP)              :: gammai(nk_ful), weight(nk_ful)
---
>   INTEGER                    :: ik, iq, ikk, ikq, ibnd0, jbnd0, ibnd, jbnd, imode, itemp, idope, iq_red, nscat_k, ik_exp(nk_ful)
>   REAL(KIND=DP)              :: g2, xk(3), ekk, ekq, wq, wgq, ef0, wgkk, wgkq, inv_temp
>   REAL(KIND=DP)              :: gammai(nk_ful), gammai_phd(nk_ful), weight(nk_ful), gammai_exp(nk_ful)
35a35,38
>   ! gamma file
>   CHARACTER(LEN=256)         :: file_ufmt
>   CHARACTER(LEN=12)          :: tnph
>   CHARACTER(LEN=10)          :: q_num, ibnd_num, jbnd_num, imode_num, itemp_num, idope_num
44a48,56
>   ! if bte=2, iq0 belongs to nq_irr, while if phdrag=T, iq0 belongs to nq_irr_red
>   IF (phdrag) THEN
>      iq_red = iq0
>      iq = rirr2irr_q(iq0) ! transform to nq_irr space
>   ELSE ! bte=2
>      iq_red = iq0 ! in the same space, for gammai_mode_all
>      iq = iq0
>   ENDIF
>   !
74c86,90
<      wq = wf_irr(imode,iq)
---
>      IF (phdrag) THEN
>         wq = wf_all(imode,iq_red)
>      ELSE ! bte=2
>         wq = wf_irr(imode,iq)
>      ENDIF
97a114,118
>               IF (phdrag) THEN
>                  wgq = wgauss(-wq*inv_temp,-99)
>                  wgq = wgq/(1.0d0-2.0d0*wgq)
>               ENDIF
>               !
107a129
>                  gammai_phd = 0.0d0
113a136,137
>                     xk(:) = xkf_ful(:,ik)
>                     !
116,117c140,143
<                     IF ( (etf(ibnd,ikk) .GE. vbnd_emax-vfsthick .AND. etf(ibnd,ikk) .LE. cbnd_emin+cfsthick) .AND. &
<                          (etf(jbnd,ikq) .GE. vbnd_emax-vfsthick .AND. etf(jbnd,ikq) .LE. cbnd_emin+cfsthick) ) within_range = .TRUE.
---
>                     IF ( (MAXVAL(ABS(xk(:))) .GT. eps) .AND. &
>                          (etf(ibnd,ikk) .GE. vbnd_emax-vfsthick .AND. etf(ibnd,ikk) .LE. cbnd_emin+cfsthick) .AND. &
>                          (etf(jbnd,ikq) .GE. vbnd_emax-vfsthick-epthick .AND. etf(jbnd,ikq) .LE. cbnd_emin+cfsthick+epthick) ) within_range = .TRUE.
> 
131,132c157
<                           ! ERROR, not consider temperature and carrier concentration
<                           epf = epf17(ik,jbnd0,ibnd0,imode,1,1)
---
>                           epf = epf17(ik,jbnd0,ibnd0,imode)
150a176
>                           IF (phdrag) gammai_phd(ik) = wsp * (wgkk*(1.0d0-wgkq)*wgq) * weight(ik)
165c191,227
<                  gammai_mode_all(itemp,idope,imode,iq) = gammai_mode_all(itemp,idope,imode,iq) + SUM(gammai(:))
---
>                  gammai_mode_all(itemp,idope,imode,iq_red) = gammai_mode_all(itemp,idope,imode,iq_red) + SUM(gammai(:))
>                  !
>                  !
>                  ! output binary file
>                  IF (phdrag) THEN
>                     !
>                     nscat_k = 0
>                     DO ik = 1, nk_ful
>                        IF (gammai_phd(ik) .NE. 0.0d0) THEN
>                           nscat_k = nscat_k + 1
>                           ik_exp(nscat_k) = ik
>                           gammai_exp(nscat_k) = gammai_phd(ik)
>                        ENDIF
>                     ENDDO
>                     !
>                     IF (nscat_k .EQ. 0) THEN
>                        nscat_k = 1
>                        ik_exp(nscat_k) = 1
>                        gammai_exp(nscat_k) = 0.0d0
>                     ENDIF
>                     !
>                     WRITE(q_num,'(i10)') iq_red
>                     WRITE(ibnd_num,'(i10)') ibnd0
>                     WRITE(jbnd_num,'(i10)') jbnd0
>                     WRITE(imode_num,'(i10)') imode
>                     WRITE(itemp_num,'(i10)') itemp
>                     WRITE(idope_num,'(i10)') idope
>                     !
>                     tnph = 'T'//TRIM(ADJUSTL(itemp_num))//'_N'//TRIM(ADJUSTL(idope_num))//'_ph'//TRIM(ADJUSTL(imode_num))
>                     !
>                     file_ufmt = 'BTE/GAMMAI/'//TRIM(ADJUSTL(tnph))//'/gammai_'//TRIM(ADJUSTL(q_num))//'_'//TRIM(ADJUSTL(ibnd_num)) &
>                                                                                                     //'_'//TRIM(ADJUSTL(jbnd_num))
>                     OPEN (80300,FILE=file_ufmt,FORM='unformatted',ACCESS='direct',RECL=4+nscat_k*(4+DP),STATUS='replace')
>                     WRITE (80300,REC=1) nscat_k, ik_exp(1:nscat_k), gammai_exp(1:nscat_k)
>                     CLOSE (80300)
>                     !
>                  ENDIF
Only in ./: selfen_phon.o
Only in ./: set_ndnmbr.o
Only in ./: setphases.o
Only in ./: setphases_wrap.o
Only in ./: sgama2.o
Only in ./: sgam_at2.o
Only in ./: sort.o
diff ./spectral_func.f90 ../../epw-qian/src/spectral_func.f90
167,168c167
<               ! ERROR, not consider temperature and carrier concentration
<               epf(:,:) = epf17 ( ik, :, :, imode, 1, 1)
---
>               epf(:,:) = epf17 ( ik, :, :, imode)
579,580c578
<               ! ERROR, not consider temperature and carrier concentration
<               epf(:,:) = epf17 ( iq, :, :, imode, 1, 1)
---
>               epf(:,:) = epf17 ( iq, :, :, imode)
Only in ./: spectral_func.o
Only in ./: star_q2.o
Only in ./: stop_epw.o
Only in ./: tetrahedron.mod
Only in ./: tetra.o
Only in ./: units_epw.mod
Only in ./: velwan2bloch.f90
Only in ./: velwan2bloch.o
diff ./vgwan2bloch.f90 ../../epw-qian/src/vgwan2bloch.f90
68c68
< SUBROUTINE vgwan2bloch_q (xkk, xxq, vph, ntemp, ndope)
---
> SUBROUTINE vgwan2bloch_q (xkk, xxq, vph)
74d73
<   use epwcom, only : screen_polar
88d86
<   integer :: ntemp, ndope
93c91
<   REAL(KIND=DP), INTENT(OUT) :: vph(3,nmodes,ntemp,ndope)
---
>   REAL(KIND=DP), INTENT(OUT) :: vph(3,nmodes)
95,96c93,94
<   INTEGER                    :: ir, imode, itemp, idope
<   REAL(KIND=DP)              :: eig_1(nmodes,ntemp,ndope), eig_2(nmodes,ntemp,ndope), &
---
>   INTEGER                    :: ir, imode
>   REAL(KIND=DP)              :: eig_1(nmodes), eig_2(nmodes), &
99c97
<   COMPLEX(KIND=DP)           :: cuf(nmodes,nmodes,ntemp,ndope), v(3,nmodes,ntemp,ndope) ! will not be used further
---
>   COMPLEX(KIND=DP)           :: cuf(nmodes,nmodes), v(3,nmodes) ! will not be used further
117,121c115
<      if (screen_polar) then
<         CALL dynwan2bloch_s (nmodes, nrr_q, irvec, ndegen_q, xkq_1, cuf, eig_1, v, ntemp, ndope)
<      else
<         CALL dynwan2bloch (nmodes, nrr_q, irvec, ndegen_q, xkq_1, cuf(:,:,1,1), eig_1(:,1,1), v(:,:,1,1))
<      endif
---
>      CALL dynwan2bloch (nmodes, nrr_q, irvec, ndegen_q, xkq_1, cuf, eig_1, v)
123,127c117
<      if (screen_polar) then
<         CALL dynwan2bloch_s (nmodes, nrr_q, irvec, ndegen_q, xkq_2, cuf, eig_2, v, ntemp, ndope)
<      else
<         CALL dynwan2bloch (nmodes, nrr_q, irvec, ndegen_q, xkq_2, cuf(:,:,1,1), eig_2(:,1,1), v(:,:,1,1))
<      endif
---
>      CALL dynwan2bloch (nmodes, nrr_q, irvec, ndegen_q, xkq_2, cuf, eig_2, v)
131,149c121,135
<         do itemp = 1, ntemp
<            do idope = 1, ndope
<               !
<               IF (eig_1(imode,itemp,idope) .GT. 0.0d0) THEN
<                  eig_1(imode,itemp,idope) =  SQRT(ABS(eig_1(imode,itemp,idope)))
<               ELSE
<                  eig_1(imode,itemp,idope) =  -SQRT(ABS(eig_1(imode,itemp,idope)))
<               ENDIF
<               !
<               IF (eig_2(imode,itemp,idope) .GT. 0.0d0) THEN
<                  eig_2(imode,itemp,idope) =  SQRT(ABS(eig_2(imode,itemp,idope)))
<               ELSE
<                  eig_2(imode,itemp,idope) =  -SQRT(ABS(eig_2(imode,itemp,idope)))
<               ENDIF
<               !
<               vph(ir,imode,itemp,idope) = (eig_2(imode,itemp,idope)-eig_1(imode,itemp,idope)) / ((twopi/alat)*dq) ! [Ry*Bohr]
<               !
<            enddo
<         enddo
---
>         !
>         IF (eig_1(imode) .GT. 0.0d0) THEN
>            eig_1(imode) =  SQRT(ABS(eig_1(imode)))
>         ELSE
>            eig_1(imode) =  -SQRT(ABS(eig_1(imode)))
>         ENDIF
>         !
>         IF (eig_2(imode) .GT. 0.0d0) THEN
>            eig_2(imode) =  SQRT(ABS(eig_2(imode)))
>         ELSE
>            eig_2(imode) =  -SQRT(ABS(eig_2(imode)))
>         ENDIF
>         !
>         vph(ir,imode) = (eig_2(imode)-eig_1(imode)) / ((twopi/alat)*dq) ! [Ry*Bohr]
>         !
Only in ./: vgwan2bloch.o
Only in ./: vmebloch2wan.o
Only in ./: vmewan2bloch.o
Only in ./: wannierize.o
Only in ./: wannier_lib.f90
Only in ./: wannier_lib.F90
Only in ./: wannier.mod
Only in ./: wannier.o
Only in ./: wigner_seitz2.o
Only in ./: wigner_seitz.o
diff ./write_ephmat.f90 ../../epw-qian/src/write_ephmat.f90
227,228c227
<                  ! ERROR, not consider temperature and carrier concentration
<                  epf(:,:) = epf17( ik, :, :, imode, 1, 1 )
---
>                  epf(:,:) = epf17( ik, :, :, imode )
Only in ./: write_ephmat.o
Only in ./: wsweight.o
